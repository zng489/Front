// Version 1.31.0 three-render-objects - https://github.com/vasturiano/three-render-objects
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('three')) :
  typeof define === 'function' && define.amd ? define(['three'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ThreeRenderObjects = factory(global.THREE));
})(this, (function (three$1) { 'use strict';

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z = ".scene-nav-info {\n  bottom: 5px;\n  width: 100%;\n  text-align: center;\n  color: slategrey;\n  opacity: 0.7;\n  font-size: 10px;\n}\n\n.scene-tooltip {\n  top: 0;\n  color: lavender;\n  font-size: 15px;\n}\n\n.scene-nav-info, .scene-tooltip {\n  position: absolute;\n  font-family: sans-serif;\n  pointer-events: none;\n  user-select: none;\n}\n\n.scene-container canvas:focus {\n  outline: none;\n}";
  styleInject(css_248z);

  function _arrayLikeToArray$1(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithHoles$1(r) {
    if (Array.isArray(r)) return r;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray$1(r);
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _iterableToArrayLimit$1(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _slicedToArray$1(r, e) {
    return _arrayWithHoles$1(r) || _iterableToArrayLimit$1(r, e) || _unsupportedIterableToArray$1(r, e) || _nonIterableRest$1();
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray$1(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _unsupportedIterableToArray$1(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
    }
  }

  /**
   * @license
   * Copyright 2010-2024 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  const REVISION = '169';
  const CullFaceNone = 0;
  const CullFaceBack = 1;
  const CullFaceFront = 2;
  const PCFShadowMap$1 = 1;
  const VSMShadowMap = 3;
  const FrontSide = 0;
  const BackSide = 1;
  const DoubleSide = 2;
  const NoBlending = 0;
  const NormalBlending = 1;
  const AdditiveBlending = 2;
  const SubtractiveBlending = 3;
  const MultiplyBlending = 4;
  const CustomBlending = 5;
  const AddEquation = 100;
  const SubtractEquation = 101;
  const ReverseSubtractEquation = 102;
  const MinEquation = 103;
  const MaxEquation = 104;
  const ZeroFactor = 200;
  const OneFactor = 201;
  const SrcColorFactor = 202;
  const OneMinusSrcColorFactor = 203;
  const SrcAlphaFactor = 204;
  const OneMinusSrcAlphaFactor = 205;
  const DstAlphaFactor = 206;
  const OneMinusDstAlphaFactor = 207;
  const DstColorFactor = 208;
  const OneMinusDstColorFactor = 209;
  const SrcAlphaSaturateFactor = 210;
  const NeverDepth = 0;
  const AlwaysDepth = 1;
  const LessDepth = 2;
  const LessEqualDepth = 3;
  const EqualDepth = 4;
  const GreaterEqualDepth = 5;
  const GreaterDepth = 6;
  const NotEqualDepth = 7;
  const MultiplyOperation = 0;
  const MixOperation = 1;
  const AddOperation = 2;
  const NoToneMapping = 0;
  const LinearToneMapping = 1;
  const ReinhardToneMapping = 2;
  const CineonToneMapping = 3;
  const ACESFilmicToneMapping = 4;
  const AgXToneMapping = 6;
  const NeutralToneMapping = 7;

  const UVMapping = 300;
  const CubeReflectionMapping = 301;
  const CubeRefractionMapping = 302;
  const EquirectangularReflectionMapping = 303;
  const EquirectangularRefractionMapping = 304;
  const CubeUVReflectionMapping = 306;
  const RepeatWrapping = 1000;
  const ClampToEdgeWrapping = 1001;
  const MirroredRepeatWrapping = 1002;
  const NearestFilter = 1003;
  const NearestMipmapNearestFilter = 1004;
  const NearestMipmapLinearFilter = 1005;
  const LinearFilter = 1006;
  const LinearMipmapNearestFilter = 1007;
  const LinearMipmapLinearFilter = 1008;
  const UnsignedByteType = 1009;
  const ByteType = 1010;
  const ShortType = 1011;
  const UnsignedShortType = 1012;
  const IntType = 1013;
  const UnsignedIntType = 1014;
  const FloatType = 1015;
  const HalfFloatType = 1016;
  const UnsignedShort4444Type = 1017;
  const UnsignedShort5551Type = 1018;
  const UnsignedInt248Type = 1020;
  const UnsignedInt5999Type = 35902;
  const AlphaFormat = 1021;
  const RGBFormat = 1022;
  const RGBAFormat = 1023;
  const LuminanceFormat = 1024;
  const LuminanceAlphaFormat = 1025;
  const DepthFormat = 1026;
  const DepthStencilFormat = 1027;
  const RedFormat = 1028;
  const RedIntegerFormat = 1029;
  const RGFormat = 1030;
  const RGIntegerFormat = 1031;
  const RGBIntegerFormat = 1032;
  const RGBAIntegerFormat = 1033;

  const RGB_S3TC_DXT1_Format = 33776;
  const RGBA_S3TC_DXT1_Format = 33777;
  const RGBA_S3TC_DXT3_Format = 33778;
  const RGBA_S3TC_DXT5_Format = 33779;
  const RGB_PVRTC_4BPPV1_Format = 35840;
  const RGB_PVRTC_2BPPV1_Format = 35841;
  const RGBA_PVRTC_4BPPV1_Format = 35842;
  const RGBA_PVRTC_2BPPV1_Format = 35843;
  const RGB_ETC1_Format = 36196;
  const RGB_ETC2_Format = 37492;
  const RGBA_ETC2_EAC_Format = 37496;
  const RGBA_ASTC_4x4_Format = 37808;
  const RGBA_ASTC_5x4_Format = 37809;
  const RGBA_ASTC_5x5_Format = 37810;
  const RGBA_ASTC_6x5_Format = 37811;
  const RGBA_ASTC_6x6_Format = 37812;
  const RGBA_ASTC_8x5_Format = 37813;
  const RGBA_ASTC_8x6_Format = 37814;
  const RGBA_ASTC_8x8_Format = 37815;
  const RGBA_ASTC_10x5_Format = 37816;
  const RGBA_ASTC_10x6_Format = 37817;
  const RGBA_ASTC_10x8_Format = 37818;
  const RGBA_ASTC_10x10_Format = 37819;
  const RGBA_ASTC_12x10_Format = 37820;
  const RGBA_ASTC_12x12_Format = 37821;
  const RGBA_BPTC_Format = 36492;
  const RED_RGTC1_Format = 36283;
  const SIGNED_RED_RGTC1_Format = 36284;
  const RED_GREEN_RGTC2_Format = 36285;
  const SIGNED_RED_GREEN_RGTC2_Format = 36286;
  const TangentSpaceNormalMap = 0;
  const ObjectSpaceNormalMap = 1;

  // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
  const NoColorSpace = '';
  const SRGBColorSpace = 'srgb';
  const LinearSRGBColorSpace = 'srgb-linear';
  const DisplayP3ColorSpace = 'display-p3';
  const LinearDisplayP3ColorSpace = 'display-p3-linear';

  const LinearTransfer = 'linear';
  const SRGBTransfer = 'srgb';

  const Rec709Primaries = 'rec709';
  const P3Primaries = 'p3';

  const ZeroStencilOp = 0;
  const KeepStencilOp = 7680;
  const ReplaceStencilOp = 7681;
  const IncrementStencilOp = 7682;
  const DecrementStencilOp = 7683;
  const IncrementWrapStencilOp = 34055;
  const DecrementWrapStencilOp = 34056;
  const InvertStencilOp = 5386;

  const NeverStencilFunc = 512;
  const LessStencilFunc = 513;
  const EqualStencilFunc = 514;
  const LessEqualStencilFunc = 515;
  const GreaterStencilFunc = 516;
  const NotEqualStencilFunc = 517;
  const GreaterEqualStencilFunc = 518;
  const AlwaysStencilFunc = 519;

  const NeverCompare = 512;
  const LessCompare = 513;
  const EqualCompare = 514;
  const LessEqualCompare = 515;
  const GreaterCompare = 516;
  const NotEqualCompare = 517;
  const GreaterEqualCompare = 518;
  const AlwaysCompare = 519;

  const StaticDrawUsage = 35044;
  const DynamicDrawUsage = 35048;

  const WebGLCoordinateSystem = 2000;
  const WebGPUCoordinateSystem = 2001;

  /**
   * https://github.com/mrdoob/eventdispatcher.js/
   */

  class EventDispatcher {

  	addEventListener( type, listener ) {

  		if ( this._listeners === undefined ) this._listeners = {};

  		const listeners = this._listeners;

  		if ( listeners[ type ] === undefined ) {

  			listeners[ type ] = [];

  		}

  		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

  			listeners[ type ].push( listener );

  		}

  	}

  	hasEventListener( type, listener ) {

  		if ( this._listeners === undefined ) return false;

  		const listeners = this._listeners;

  		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

  	}

  	removeEventListener( type, listener ) {

  		if ( this._listeners === undefined ) return;

  		const listeners = this._listeners;
  		const listenerArray = listeners[ type ];

  		if ( listenerArray !== undefined ) {

  			const index = listenerArray.indexOf( listener );

  			if ( index !== - 1 ) {

  				listenerArray.splice( index, 1 );

  			}

  		}

  	}

  	dispatchEvent( event ) {

  		if ( this._listeners === undefined ) return;

  		const listeners = this._listeners;
  		const listenerArray = listeners[ event.type ];

  		if ( listenerArray !== undefined ) {

  			event.target = this;

  			// Make a copy, in case listeners are removed while iterating.
  			const array = listenerArray.slice( 0 );

  			for ( let i = 0, l = array.length; i < l; i ++ ) {

  				array[ i ].call( this, event );

  			}

  			event.target = null;

  		}

  	}

  }

  const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

  let _seed = 1234567;


  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 180 / Math.PI;

  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  function generateUUID() {

  	const d0 = Math.random() * 0xffffffff | 0;
  	const d1 = Math.random() * 0xffffffff | 0;
  	const d2 = Math.random() * 0xffffffff | 0;
  	const d3 = Math.random() * 0xffffffff | 0;
  	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
  			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
  			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
  			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

  	// .toLowerCase() here flattens concatenated strings to save heap memory space.
  	return uuid.toLowerCase();

  }

  function clamp$1( value, min, max ) {

  	return Math.max( min, Math.min( max, value ) );

  }

  // compute euclidean modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  function euclideanModulo( n, m ) {

  	return ( ( n % m ) + m ) % m;

  }

  // Linear mapping from range <a1, a2> to range <b1, b2>
  function mapLinear( x, a1, a2, b1, b2 ) {

  	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  }

  // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
  function inverseLerp( x, y, value ) {

  	if ( x !== y ) {

  		return ( value - x ) / ( y - x );

  	} else {

  		return 0;

  	}

  }

  // https://en.wikipedia.org/wiki/Linear_interpolation
  function lerp( x, y, t ) {

  	return ( 1 - t ) * x + t * y;

  }

  // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
  function damp( x, y, lambda, dt ) {

  	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

  }

  // https://www.desmos.com/calculator/vcsjnyz7x4
  function pingpong( x, length = 1 ) {

  	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

  }

  // http://en.wikipedia.org/wiki/Smoothstep
  function smoothstep$1( x, min, max ) {

  	if ( x <= min ) return 0;
  	if ( x >= max ) return 1;

  	x = ( x - min ) / ( max - min );

  	return x * x * ( 3 - 2 * x );

  }

  function smootherstep( x, min, max ) {

  	if ( x <= min ) return 0;
  	if ( x >= max ) return 1;

  	x = ( x - min ) / ( max - min );

  	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  }

  // Random integer from <low, high> interval
  function randInt( low, high ) {

  	return low + Math.floor( Math.random() * ( high - low + 1 ) );

  }

  // Random float from <low, high> interval
  function randFloat( low, high ) {

  	return low + Math.random() * ( high - low );

  }

  // Random float from <-range/2, range/2> interval
  function randFloatSpread( range ) {

  	return range * ( 0.5 - Math.random() );

  }

  // Deterministic pseudo-random float in the interval [ 0, 1 ]
  function seededRandom( s ) {

  	if ( s !== undefined ) _seed = s;

  	// Mulberry32 generator

  	let t = _seed += 0x6D2B79F5;

  	t = Math.imul( t ^ t >>> 15, t | 1 );

  	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

  	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

  }

  function degToRad( degrees ) {

  	return degrees * DEG2RAD;

  }

  function radToDeg( radians ) {

  	return radians * RAD2DEG;

  }

  function isPowerOfTwo( value ) {

  	return ( value & ( value - 1 ) ) === 0 && value !== 0;

  }

  function ceilPowerOfTwo( value ) {

  	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

  }

  function floorPowerOfTwo( value ) {

  	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

  }

  function setQuaternionFromProperEuler( q, a, b, c, order ) {

  	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

  	// rotations are applied to the axes in the order specified by 'order'
  	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  	// angles are in radians

  	const cos = Math.cos;
  	const sin = Math.sin;

  	const c2 = cos( b / 2 );
  	const s2 = sin( b / 2 );

  	const c13 = cos( ( a + c ) / 2 );
  	const s13 = sin( ( a + c ) / 2 );

  	const c1_3 = cos( ( a - c ) / 2 );
  	const s1_3 = sin( ( a - c ) / 2 );

  	const c3_1 = cos( ( c - a ) / 2 );
  	const s3_1 = sin( ( c - a ) / 2 );

  	switch ( order ) {

  		case 'XYX':
  			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
  			break;

  		case 'YZY':
  			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
  			break;

  		case 'ZXZ':
  			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
  			break;

  		case 'XZX':
  			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
  			break;

  		case 'YXY':
  			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
  			break;

  		case 'ZYZ':
  			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
  			break;

  		default:
  			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

  	}

  }

  function denormalize( value, array ) {

  	switch ( array.constructor ) {

  		case Float32Array:

  			return value;

  		case Uint32Array:

  			return value / 4294967295.0;

  		case Uint16Array:

  			return value / 65535.0;

  		case Uint8Array:

  			return value / 255.0;

  		case Int32Array:

  			return Math.max( value / 2147483647.0, - 1.0 );

  		case Int16Array:

  			return Math.max( value / 32767.0, - 1.0 );

  		case Int8Array:

  			return Math.max( value / 127.0, - 1.0 );

  		default:

  			throw new Error( 'Invalid component type.' );

  	}

  }

  function normalize$1( value, array ) {

  	switch ( array.constructor ) {

  		case Float32Array:

  			return value;

  		case Uint32Array:

  			return Math.round( value * 4294967295.0 );

  		case Uint16Array:

  			return Math.round( value * 65535.0 );

  		case Uint8Array:

  			return Math.round( value * 255.0 );

  		case Int32Array:

  			return Math.round( value * 2147483647.0 );

  		case Int16Array:

  			return Math.round( value * 32767.0 );

  		case Int8Array:

  			return Math.round( value * 127.0 );

  		default:

  			throw new Error( 'Invalid component type.' );

  	}

  }

  const MathUtils = {
  	DEG2RAD: DEG2RAD,
  	RAD2DEG: RAD2DEG,
  	generateUUID: generateUUID,
  	clamp: clamp$1,
  	euclideanModulo: euclideanModulo,
  	mapLinear: mapLinear,
  	inverseLerp: inverseLerp,
  	lerp: lerp,
  	damp: damp,
  	pingpong: pingpong,
  	smoothstep: smoothstep$1,
  	smootherstep: smootherstep,
  	randInt: randInt,
  	randFloat: randFloat,
  	randFloatSpread: randFloatSpread,
  	seededRandom: seededRandom,
  	degToRad: degToRad,
  	radToDeg: radToDeg,
  	isPowerOfTwo: isPowerOfTwo,
  	ceilPowerOfTwo: ceilPowerOfTwo,
  	floorPowerOfTwo: floorPowerOfTwo,
  	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
  	normalize: normalize$1,
  	denormalize: denormalize
  };

  class Vector2 {

  	constructor( x = 0, y = 0 ) {

  		Vector2.prototype.isVector2 = true;

  		this.x = x;
  		this.y = y;

  	}

  	get width() {

  		return this.x;

  	}

  	set width( value ) {

  		this.x = value;

  	}

  	get height() {

  		return this.y;

  	}

  	set height( value ) {

  		this.y = value;

  	}

  	set( x, y ) {

  		this.x = x;
  		this.y = y;

  		return this;

  	}

  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;

  		return this;

  	}

  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	clone() {

  		return new this.constructor( this.x, this.y );

  	}

  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;

  		return this;

  	}

  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;

  		return this;

  	}

  	addScalar( s ) {

  		this.x += s;
  		this.y += s;

  		return this;

  	}

  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;

  		return this;

  	}

  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;

  		return this;

  	}

  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;

  		return this;

  	}

  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;

  		return this;

  	}

  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;

  		return this;

  	}

  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;

  		return this;

  	}

  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;

  		return this;

  	}

  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;

  		return this;

  	}

  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	applyMatrix3( m ) {

  		const x = this.x, y = this.y;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

  		return this;

  	}

  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );

  		return this;

  	}

  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );

  		return this;

  	}

  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

  		return this;

  	}

  	clampScalar( minVal, maxVal ) {

  		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
  		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

  		return this;

  	}

  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	}

  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );

  		return this;

  	}

  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );

  		return this;

  	}

  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );

  		return this;

  	}

  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );

  		return this;

  	}

  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;

  		return this;

  	}

  	dot( v ) {

  		return this.x * v.x + this.y * v.y;

  	}

  	cross( v ) {

  		return this.x * v.y - this.y * v.x;

  	}

  	lengthSq() {

  		return this.x * this.x + this.y * this.y;

  	}

  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y );

  	}

  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y );

  	}

  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	angle() {

  		// computes the angle in radians with respect to the positive x-axis

  		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

  		return angle;

  	}

  	angleTo( v ) {

  		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

  		if ( denominator === 0 ) return Math.PI / 2;

  		const theta = this.dot( v ) / denominator;

  		// clamp, to handle numerical problems

  		return Math.acos( clamp$1( theta, - 1, 1 ) );

  	}

  	distanceTo( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	}

  	distanceToSquared( v ) {

  		const dx = this.x - v.x, dy = this.y - v.y;
  		return dx * dx + dy * dy;

  	}

  	manhattanDistanceTo( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

  	}

  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;

  		return this;

  	}

  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;

  		return this;

  	}

  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) );

  	}

  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );

  		return this;

  	}

  	rotateAround( center, angle ) {

  		const c = Math.cos( angle ), s = Math.sin( angle );

  		const x = this.x - center.x;
  		const y = this.y - center.y;

  		this.x = x * c - y * s + center.x;
  		this.y = x * s + y * c + center.y;

  		return this;

  	}

  	random() {

  		this.x = Math.random();
  		this.y = Math.random();

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;

  	}

  }

  class Matrix3 {

  	constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		Matrix3.prototype.isMatrix3 = true;

  		this.elements = [

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		];

  		if ( n11 !== undefined ) {

  			this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

  		}

  	}

  	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		const te = this.elements;

  		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
  		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
  		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

  		return this;

  	}

  	identity() {

  		this.set(

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	copy( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
  		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
  		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

  		return this;

  	}

  	extractBasis( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrix3Column( this, 0 );
  		yAxis.setFromMatrix3Column( this, 1 );
  		zAxis.setFromMatrix3Column( this, 2 );

  		return this;

  	}

  	setFromMatrix4( m ) {

  		const me = m.elements;

  		this.set(

  			me[ 0 ], me[ 4 ], me[ 8 ],
  			me[ 1 ], me[ 5 ], me[ 9 ],
  			me[ 2 ], me[ 6 ], me[ 10 ]

  		);

  		return this;

  	}

  	multiply( m ) {

  		return this.multiplyMatrices( this, m );

  	}

  	premultiply( m ) {

  		return this.multiplyMatrices( m, this );

  	}

  	multiplyMatrices( a, b ) {

  		const ae = a.elements;
  		const be = b.elements;
  		const te = this.elements;

  		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
  		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
  		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

  		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
  		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
  		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
  		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
  		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
  		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
  		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
  		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
  		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

  		return this;

  	}

  	multiplyScalar( s ) {

  		const te = this.elements;

  		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
  		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
  		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

  		return this;

  	}

  	determinant() {

  		const te = this.elements;

  		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
  			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
  			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

  		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  	}

  	invert() {

  		const te = this.elements,

  			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
  			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
  			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

  			t11 = n33 * n22 - n32 * n23,
  			t12 = n32 * n13 - n33 * n12,
  			t13 = n23 * n12 - n22 * n13,

  			det = n11 * t11 + n21 * t12 + n31 * t13;

  		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

  		const detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
  		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

  		te[ 3 ] = t12 * detInv;
  		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
  		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

  		te[ 6 ] = t13 * detInv;
  		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
  		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

  		return this;

  	}

  	transpose() {

  		let tmp;
  		const m = this.elements;

  		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
  		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
  		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

  		return this;

  	}

  	getNormalMatrix( matrix4 ) {

  		return this.setFromMatrix4( matrix4 ).invert().transpose();

  	}

  	transposeIntoArray( r ) {

  		const m = this.elements;

  		r[ 0 ] = m[ 0 ];
  		r[ 1 ] = m[ 3 ];
  		r[ 2 ] = m[ 6 ];
  		r[ 3 ] = m[ 1 ];
  		r[ 4 ] = m[ 4 ];
  		r[ 5 ] = m[ 7 ];
  		r[ 6 ] = m[ 2 ];
  		r[ 7 ] = m[ 5 ];
  		r[ 8 ] = m[ 8 ];

  		return this;

  	}

  	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

  		const c = Math.cos( rotation );
  		const s = Math.sin( rotation );

  		this.set(
  			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
  			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
  			0, 0, 1
  		);

  		return this;

  	}

  	//

  	scale( sx, sy ) {

  		this.premultiply( _m3.makeScale( sx, sy ) );

  		return this;

  	}

  	rotate( theta ) {

  		this.premultiply( _m3.makeRotation( - theta ) );

  		return this;

  	}

  	translate( tx, ty ) {

  		this.premultiply( _m3.makeTranslation( tx, ty ) );

  		return this;

  	}

  	// for 2D Transforms

  	makeTranslation( x, y ) {

  		if ( x.isVector2 ) {

  			this.set(

  				1, 0, x.x,
  				0, 1, x.y,
  				0, 0, 1

  			);

  		} else {

  			this.set(

  				1, 0, x,
  				0, 1, y,
  				0, 0, 1

  			);

  		}

  		return this;

  	}

  	makeRotation( theta ) {

  		// counterclockwise

  		const c = Math.cos( theta );
  		const s = Math.sin( theta );

  		this.set(

  			c, - s, 0,
  			s, c, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	makeScale( x, y ) {

  		this.set(

  			x, 0, 0,
  			0, y, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	//

  	equals( matrix ) {

  		const te = this.elements;
  		const me = matrix.elements;

  		for ( let i = 0; i < 9; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	}

  	fromArray( array, offset = 0 ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		const te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];

  		array[ offset + 3 ] = te[ 3 ];
  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];

  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];
  		array[ offset + 8 ] = te[ 8 ];

  		return array;

  	}

  	clone() {

  		return new this.constructor().fromArray( this.elements );

  	}

  }

  const _m3 = /*@__PURE__*/ new Matrix3();

  function arrayNeedsUint32$1( array ) {

  	// assumes larger values usually on last

  	for ( let i = array.length - 1; i >= 0; -- i ) {

  		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

  	}

  	return false;

  }

  function createElementNS( name ) {

  	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

  }

  function createCanvasElement() {

  	const canvas = createElementNS( 'canvas' );
  	canvas.style.display = 'block';
  	return canvas;

  }

  const _cache$2 = {};

  function warnOnce( message ) {

  	if ( message in _cache$2 ) return;

  	_cache$2[ message ] = true;

  	console.warn( message );

  }

  /**
   * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
   * or clipping. Based on W3C specifications for sRGB and Display P3,
   * and ICC specifications for the D50 connection space. Values in/out
   * are _linear_ sRGB and _linear_ Display P3.
   *
   * Note that both sRGB and Display P3 use the sRGB transfer functions.
   *
   * Reference:
   * - http://www.russellcottrell.com/photo/matrixCalculator.htm
   */

  const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().set(
  	0.8224621, 0.177538, 0.0,
  	0.0331941, 0.9668058, 0.0,
  	0.0170827, 0.0723974, 0.9105199,
  );

  const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().set(
  	1.2249401, - 0.2249404, 0.0,
  	- 0.0420569, 1.0420571, 0.0,
  	- 0.0196376, - 0.0786361, 1.0982735
  );

  /**
   * Defines supported color spaces by transfer function and primaries,
   * and provides conversions to/from the Linear-sRGB reference space.
   */
  const COLOR_SPACES = {
  	[ LinearSRGBColorSpace ]: {
  		transfer: LinearTransfer,
  		primaries: Rec709Primaries,
  		luminanceCoefficients: [ 0.2126, 0.7152, 0.0722 ],
  		toReference: ( color ) => color,
  		fromReference: ( color ) => color,
  	},
  	[ SRGBColorSpace ]: {
  		transfer: SRGBTransfer,
  		primaries: Rec709Primaries,
  		luminanceCoefficients: [ 0.2126, 0.7152, 0.0722 ],
  		toReference: ( color ) => color.convertSRGBToLinear(),
  		fromReference: ( color ) => color.convertLinearToSRGB(),
  	},
  	[ LinearDisplayP3ColorSpace ]: {
  		transfer: LinearTransfer,
  		primaries: P3Primaries,
  		luminanceCoefficients: [ 0.2289, 0.6917, 0.0793 ],
  		toReference: ( color ) => color.applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),
  		fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ),
  	},
  	[ DisplayP3ColorSpace ]: {
  		transfer: SRGBTransfer,
  		primaries: P3Primaries,
  		luminanceCoefficients: [ 0.2289, 0.6917, 0.0793 ],
  		toReference: ( color ) => color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),
  		fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB(),
  	},
  };

  const SUPPORTED_WORKING_COLOR_SPACES = new Set( [ LinearSRGBColorSpace, LinearDisplayP3ColorSpace ] );

  const ColorManagement = {

  	enabled: true,

  	_workingColorSpace: LinearSRGBColorSpace,

  	get workingColorSpace() {

  		return this._workingColorSpace;

  	},

  	set workingColorSpace( colorSpace ) {

  		if ( ! SUPPORTED_WORKING_COLOR_SPACES.has( colorSpace ) ) {

  			throw new Error( `Unsupported working color space, "${ colorSpace }".` );

  		}

  		this._workingColorSpace = colorSpace;

  	},

  	convert: function ( color, sourceColorSpace, targetColorSpace ) {

  		if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

  			return color;

  		}

  		const sourceToReference = COLOR_SPACES[ sourceColorSpace ].toReference;
  		const targetFromReference = COLOR_SPACES[ targetColorSpace ].fromReference;

  		return targetFromReference( sourceToReference( color ) );

  	},

  	fromWorkingColorSpace: function ( color, targetColorSpace ) {

  		return this.convert( color, this._workingColorSpace, targetColorSpace );

  	},

  	toWorkingColorSpace: function ( color, sourceColorSpace ) {

  		return this.convert( color, sourceColorSpace, this._workingColorSpace );

  	},

  	getPrimaries: function ( colorSpace ) {

  		return COLOR_SPACES[ colorSpace ].primaries;

  	},

  	getTransfer: function ( colorSpace ) {

  		if ( colorSpace === NoColorSpace ) return LinearTransfer;

  		return COLOR_SPACES[ colorSpace ].transfer;

  	},

  	getLuminanceCoefficients: function ( target, colorSpace = this._workingColorSpace ) {

  		return target.fromArray( COLOR_SPACES[ colorSpace ].luminanceCoefficients );

  	},

  };


  function SRGBToLinear( c ) {

  	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

  }

  function LinearToSRGB( c ) {

  	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

  }

  let _canvas;

  class ImageUtils {

  	static getDataURL( image ) {

  		if ( /^data:/i.test( image.src ) ) {

  			return image.src;

  		}

  		if ( typeof HTMLCanvasElement === 'undefined' ) {

  			return image.src;

  		}

  		let canvas;

  		if ( image instanceof HTMLCanvasElement ) {

  			canvas = image;

  		} else {

  			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

  			_canvas.width = image.width;
  			_canvas.height = image.height;

  			const context = _canvas.getContext( '2d' );

  			if ( image instanceof ImageData ) {

  				context.putImageData( image, 0, 0 );

  			} else {

  				context.drawImage( image, 0, 0, image.width, image.height );

  			}

  			canvas = _canvas;

  		}

  		if ( canvas.width > 2048 || canvas.height > 2048 ) {

  			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

  			return canvas.toDataURL( 'image/jpeg', 0.6 );

  		} else {

  			return canvas.toDataURL( 'image/png' );

  		}

  	}

  	static sRGBToLinear( image ) {

  		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

  			const canvas = createElementNS( 'canvas' );

  			canvas.width = image.width;
  			canvas.height = image.height;

  			const context = canvas.getContext( '2d' );
  			context.drawImage( image, 0, 0, image.width, image.height );

  			const imageData = context.getImageData( 0, 0, image.width, image.height );
  			const data = imageData.data;

  			for ( let i = 0; i < data.length; i ++ ) {

  				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

  			}

  			context.putImageData( imageData, 0, 0 );

  			return canvas;

  		} else if ( image.data ) {

  			const data = image.data.slice( 0 );

  			for ( let i = 0; i < data.length; i ++ ) {

  				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

  					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

  				} else {

  					// assuming float

  					data[ i ] = SRGBToLinear( data[ i ] );

  				}

  			}

  			return {
  				data: data,
  				width: image.width,
  				height: image.height
  			};

  		} else {

  			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
  			return image;

  		}

  	}

  }

  let _sourceId = 0;

  class Source {

  	constructor( data = null ) {

  		this.isSource = true;

  		Object.defineProperty( this, 'id', { value: _sourceId ++ } );

  		this.uuid = generateUUID();

  		this.data = data;
  		this.dataReady = true;

  		this.version = 0;

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

  			return meta.images[ this.uuid ];

  		}

  		const output = {
  			uuid: this.uuid,
  			url: ''
  		};

  		const data = this.data;

  		if ( data !== null ) {

  			let url;

  			if ( Array.isArray( data ) ) {

  				// cube texture

  				url = [];

  				for ( let i = 0, l = data.length; i < l; i ++ ) {

  					if ( data[ i ].isDataTexture ) {

  						url.push( serializeImage( data[ i ].image ) );

  					} else {

  						url.push( serializeImage( data[ i ] ) );

  					}

  				}

  			} else {

  				// texture

  				url = serializeImage( data );

  			}

  			output.url = url;

  		}

  		if ( ! isRootObject ) {

  			meta.images[ this.uuid ] = output;

  		}

  		return output;

  	}

  }

  function serializeImage( image ) {

  	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

  		// default images

  		return ImageUtils.getDataURL( image );

  	} else {

  		if ( image.data ) {

  			// images of DataTexture

  			return {
  				data: Array.from( image.data ),
  				width: image.width,
  				height: image.height,
  				type: image.data.constructor.name
  			};

  		} else {

  			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
  			return {};

  		}

  	}

  }

  let _textureId = 0;

  class Texture extends EventDispatcher {

  	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

  		super();

  		this.isTexture = true;

  		Object.defineProperty( this, 'id', { value: _textureId ++ } );

  		this.uuid = generateUUID();

  		this.name = '';

  		this.source = new Source( image );
  		this.mipmaps = [];

  		this.mapping = mapping;
  		this.channel = 0;

  		this.wrapS = wrapS;
  		this.wrapT = wrapT;

  		this.magFilter = magFilter;
  		this.minFilter = minFilter;

  		this.anisotropy = anisotropy;

  		this.format = format;
  		this.internalFormat = null;
  		this.type = type;

  		this.offset = new Vector2( 0, 0 );
  		this.repeat = new Vector2( 1, 1 );
  		this.center = new Vector2( 0, 0 );
  		this.rotation = 0;

  		this.matrixAutoUpdate = true;
  		this.matrix = new Matrix3();

  		this.generateMipmaps = true;
  		this.premultiplyAlpha = false;
  		this.flipY = true;
  		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  		this.colorSpace = colorSpace;

  		this.userData = {};

  		this.version = 0;
  		this.onUpdate = null;

  		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
  		this.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

  	}

  	get image() {

  		return this.source.data;

  	}

  	set image( value = null ) {

  		this.source.data = value;

  	}

  	updateMatrix() {

  		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		this.name = source.name;

  		this.source = source.source;
  		this.mipmaps = source.mipmaps.slice( 0 );

  		this.mapping = source.mapping;
  		this.channel = source.channel;

  		this.wrapS = source.wrapS;
  		this.wrapT = source.wrapT;

  		this.magFilter = source.magFilter;
  		this.minFilter = source.minFilter;

  		this.anisotropy = source.anisotropy;

  		this.format = source.format;
  		this.internalFormat = source.internalFormat;
  		this.type = source.type;

  		this.offset.copy( source.offset );
  		this.repeat.copy( source.repeat );
  		this.center.copy( source.center );
  		this.rotation = source.rotation;

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrix.copy( source.matrix );

  		this.generateMipmaps = source.generateMipmaps;
  		this.premultiplyAlpha = source.premultiplyAlpha;
  		this.flipY = source.flipY;
  		this.unpackAlignment = source.unpackAlignment;
  		this.colorSpace = source.colorSpace;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		this.needsUpdate = true;

  		return this;

  	}

  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

  			return meta.textures[ this.uuid ];

  		}

  		const output = {

  			metadata: {
  				version: 4.6,
  				type: 'Texture',
  				generator: 'Texture.toJSON'
  			},

  			uuid: this.uuid,
  			name: this.name,

  			image: this.source.toJSON( meta ).uuid,

  			mapping: this.mapping,
  			channel: this.channel,

  			repeat: [ this.repeat.x, this.repeat.y ],
  			offset: [ this.offset.x, this.offset.y ],
  			center: [ this.center.x, this.center.y ],
  			rotation: this.rotation,

  			wrap: [ this.wrapS, this.wrapT ],

  			format: this.format,
  			internalFormat: this.internalFormat,
  			type: this.type,
  			colorSpace: this.colorSpace,

  			minFilter: this.minFilter,
  			magFilter: this.magFilter,
  			anisotropy: this.anisotropy,

  			flipY: this.flipY,

  			generateMipmaps: this.generateMipmaps,
  			premultiplyAlpha: this.premultiplyAlpha,
  			unpackAlignment: this.unpackAlignment

  		};

  		if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

  		if ( ! isRootObject ) {

  			meta.textures[ this.uuid ] = output;

  		}

  		return output;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	transformUv( uv ) {

  		if ( this.mapping !== UVMapping ) return uv;

  		uv.applyMatrix3( this.matrix );

  		if ( uv.x < 0 || uv.x > 1 ) {

  			switch ( this.wrapS ) {

  				case RepeatWrapping:

  					uv.x = uv.x - Math.floor( uv.x );
  					break;

  				case ClampToEdgeWrapping:

  					uv.x = uv.x < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

  						uv.x = Math.ceil( uv.x ) - uv.x;

  					} else {

  						uv.x = uv.x - Math.floor( uv.x );

  					}

  					break;

  			}

  		}

  		if ( uv.y < 0 || uv.y > 1 ) {

  			switch ( this.wrapT ) {

  				case RepeatWrapping:

  					uv.y = uv.y - Math.floor( uv.y );
  					break;

  				case ClampToEdgeWrapping:

  					uv.y = uv.y < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

  						uv.y = Math.ceil( uv.y ) - uv.y;

  					} else {

  						uv.y = uv.y - Math.floor( uv.y );

  					}

  					break;

  			}

  		}

  		if ( this.flipY ) {

  			uv.y = 1 - uv.y;

  		}

  		return uv;

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) {

  			this.version ++;
  			this.source.needsUpdate = true;

  		}

  	}

  	set needsPMREMUpdate( value ) {

  		if ( value === true ) {

  			this.pmremVersion ++;

  		}

  	}

  }

  Texture.DEFAULT_IMAGE = null;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.DEFAULT_ANISOTROPY = 1;

  class Vector4 {

  	constructor( x = 0, y = 0, z = 0, w = 1 ) {

  		Vector4.prototype.isVector4 = true;

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  	}

  	get width() {

  		return this.z;

  	}

  	set width( value ) {

  		this.z = value;

  	}

  	get height() {

  		return this.w;

  	}

  	set height( value ) {

  		this.w = value;

  	}

  	set( x, y, z, w ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  		return this;

  	}

  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;
  		this.w = scalar;

  		return this;

  	}

  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	setZ( z ) {

  		this.z = z;

  		return this;

  	}

  	setW( w ) {

  		this.w = w;

  		return this;

  	}

  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			case 3: this.w = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			case 3: return this.w;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	clone() {

  		return new this.constructor( this.x, this.y, this.z, this.w );

  	}

  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;
  		this.w = ( v.w !== undefined ) ? v.w : 1;

  		return this;

  	}

  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;
  		this.w += v.w;

  		return this;

  	}

  	addScalar( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;
  		this.w += s;

  		return this;

  	}

  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;
  		this.w = a.w + b.w;

  		return this;

  	}

  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;
  		this.w += v.w * s;

  		return this;

  	}

  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;
  		this.w -= v.w;

  		return this;

  	}

  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;
  		this.w -= s;

  		return this;

  	}

  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;
  		this.w = a.w - b.w;

  		return this;

  	}

  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;
  		this.w *= v.w;

  		return this;

  	}

  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;
  		this.w *= scalar;

  		return this;

  	}

  	applyMatrix4( m ) {

  		const x = this.x, y = this.y, z = this.z, w = this.w;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
  		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

  		return this;

  	}

  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	setAxisAngleFromQuaternion( q ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

  		// q is assumed to be normalized

  		this.w = 2 * Math.acos( q.w );

  		const s = Math.sqrt( 1 - q.w * q.w );

  		if ( s < 0.0001 ) {

  			this.x = 1;
  			this.y = 0;
  			this.z = 0;

  		} else {

  			this.x = q.x / s;
  			this.y = q.y / s;
  			this.z = q.z / s;

  		}

  		return this;

  	}

  	setAxisAngleFromRotationMatrix( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		let angle, x, y, z; // variables for result
  		const epsilon = 0.01,		// margin to allow for rounding errors
  			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

  			te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
  		     ( Math.abs( m13 - m31 ) < epsilon ) &&
  		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

  			// singularity found
  			// first check for identity matrix which must have +1 for all terms
  			// in leading diagonal and zero in other terms

  			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
  			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
  			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
  			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

  				// this singularity is identity matrix so angle = 0

  				this.set( 1, 0, 0, 0 );

  				return this; // zero angle, arbitrary axis

  			}

  			// otherwise this singularity is angle = 180

  			angle = Math.PI;

  			const xx = ( m11 + 1 ) / 2;
  			const yy = ( m22 + 1 ) / 2;
  			const zz = ( m33 + 1 ) / 2;
  			const xy = ( m12 + m21 ) / 4;
  			const xz = ( m13 + m31 ) / 4;
  			const yz = ( m23 + m32 ) / 4;

  			if ( ( xx > yy ) && ( xx > zz ) ) {

  				// m11 is the largest diagonal term

  				if ( xx < epsilon ) {

  					x = 0;
  					y = 0.707106781;
  					z = 0.707106781;

  				} else {

  					x = Math.sqrt( xx );
  					y = xy / x;
  					z = xz / x;

  				}

  			} else if ( yy > zz ) {

  				// m22 is the largest diagonal term

  				if ( yy < epsilon ) {

  					x = 0.707106781;
  					y = 0;
  					z = 0.707106781;

  				} else {

  					y = Math.sqrt( yy );
  					x = xy / y;
  					z = yz / y;

  				}

  			} else {

  				// m33 is the largest diagonal term so base result on this

  				if ( zz < epsilon ) {

  					x = 0.707106781;
  					y = 0.707106781;
  					z = 0;

  				} else {

  					z = Math.sqrt( zz );
  					x = xz / z;
  					y = yz / z;

  				}

  			}

  			this.set( x, y, z, angle );

  			return this; // return 180 deg rotation

  		}

  		// as we have reached here there are no singularities so we can handle normally

  		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
  			( m13 - m31 ) * ( m13 - m31 ) +
  			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

  		if ( Math.abs( s ) < 0.001 ) s = 1;

  		// prevent divide by zero, should not happen if matrix is orthogonal and should be
  		// caught by singularity test above, but I've left it in just in case

  		this.x = ( m32 - m23 ) / s;
  		this.y = ( m13 - m31 ) / s;
  		this.z = ( m21 - m12 ) / s;
  		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

  		return this;

  	}

  	setFromMatrixPosition( m ) {

  		const e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];
  		this.w = e[ 15 ];

  		return this;

  	}

  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );
  		this.w = Math.min( this.w, v.w );

  		return this;

  	}

  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );
  		this.w = Math.max( this.w, v.w );

  		return this;

  	}

  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
  		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

  		return this;

  	}

  	clampScalar( minVal, maxVal ) {

  		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
  		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
  		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
  		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

  		return this;

  	}

  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	}

  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );
  		this.w = Math.floor( this.w );

  		return this;

  	}

  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );
  		this.w = Math.ceil( this.w );

  		return this;

  	}

  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );
  		this.w = Math.round( this.w );

  		return this;

  	}

  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );
  		this.z = Math.trunc( this.z );
  		this.w = Math.trunc( this.w );

  		return this;

  	}

  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;
  		this.w = - this.w;

  		return this;

  	}

  	dot( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  	}

  	lengthSq() {

  		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  	}

  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  	}

  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  	}

  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;
  		this.w += ( v.w - this.w ) * alpha;

  		return this;

  	}

  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;
  		this.z = v1.z + ( v2.z - v1.z ) * alpha;
  		this.w = v1.w + ( v2.w - v1.w ) * alpha;

  		return this;

  	}

  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  	}

  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];
  		this.w = array[ offset + 3 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;
  		array[ offset + 3 ] = this.w;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );
  		this.w = attribute.getW( index );

  		return this;

  	}

  	random() {

  		this.x = Math.random();
  		this.y = Math.random();
  		this.z = Math.random();
  		this.w = Math.random();

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;
  		yield this.z;
  		yield this.w;

  	}

  }

  /*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */
  class RenderTarget extends EventDispatcher {

  	constructor( width = 1, height = 1, options = {} ) {

  		super();

  		this.isRenderTarget = true;

  		this.width = width;
  		this.height = height;
  		this.depth = 1;

  		this.scissor = new Vector4( 0, 0, width, height );
  		this.scissorTest = false;

  		this.viewport = new Vector4( 0, 0, width, height );

  		const image = { width: width, height: height, depth: 1 };

  		options = Object.assign( {
  			generateMipmaps: false,
  			internalFormat: null,
  			minFilter: LinearFilter,
  			depthBuffer: true,
  			stencilBuffer: false,
  			resolveDepthBuffer: true,
  			resolveStencilBuffer: true,
  			depthTexture: null,
  			samples: 0,
  			count: 1
  		}, options );

  		const texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

  		texture.flipY = false;
  		texture.generateMipmaps = options.generateMipmaps;
  		texture.internalFormat = options.internalFormat;

  		this.textures = [];

  		const count = options.count;
  		for ( let i = 0; i < count; i ++ ) {

  			this.textures[ i ] = texture.clone();
  			this.textures[ i ].isRenderTargetTexture = true;

  		}

  		this.depthBuffer = options.depthBuffer;
  		this.stencilBuffer = options.stencilBuffer;

  		this.resolveDepthBuffer = options.resolveDepthBuffer;
  		this.resolveStencilBuffer = options.resolveStencilBuffer;

  		this.depthTexture = options.depthTexture;

  		this.samples = options.samples;

  	}

  	get texture() {

  		return this.textures[ 0 ];

  	}

  	set texture( value ) {

  		this.textures[ 0 ] = value;

  	}

  	setSize( width, height, depth = 1 ) {

  		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

  			this.width = width;
  			this.height = height;
  			this.depth = depth;

  			for ( let i = 0, il = this.textures.length; i < il; i ++ ) {

  				this.textures[ i ].image.width = width;
  				this.textures[ i ].image.height = height;
  				this.textures[ i ].image.depth = depth;

  			}

  			this.dispose();

  		}

  		this.viewport.set( 0, 0, width, height );
  		this.scissor.set( 0, 0, width, height );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		this.width = source.width;
  		this.height = source.height;
  		this.depth = source.depth;

  		this.scissor.copy( source.scissor );
  		this.scissorTest = source.scissorTest;

  		this.viewport.copy( source.viewport );

  		this.textures.length = 0;

  		for ( let i = 0, il = source.textures.length; i < il; i ++ ) {

  			this.textures[ i ] = source.textures[ i ].clone();
  			this.textures[ i ].isRenderTargetTexture = true;

  		}

  		// ensure image object is not shared, see #20328

  		const image = Object.assign( {}, source.texture.image );
  		this.texture.source = new Source( image );

  		this.depthBuffer = source.depthBuffer;
  		this.stencilBuffer = source.stencilBuffer;

  		this.resolveDepthBuffer = source.resolveDepthBuffer;
  		this.resolveStencilBuffer = source.resolveStencilBuffer;

  		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

  		this.samples = source.samples;

  		return this;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  }

  class WebGLRenderTarget extends RenderTarget {

  	constructor( width = 1, height = 1, options = {} ) {

  		super( width, height, options );

  		this.isWebGLRenderTarget = true;

  	}

  }

  class DataArrayTexture extends Texture {

  	constructor( data = null, width = 1, height = 1, depth = 1 ) {

  		super( null );

  		this.isDataArrayTexture = true;

  		this.image = { data, width, height, depth };

  		this.magFilter = NearestFilter;
  		this.minFilter = NearestFilter;

  		this.wrapR = ClampToEdgeWrapping;

  		this.generateMipmaps = false;
  		this.flipY = false;
  		this.unpackAlignment = 1;

  		this.layerUpdates = new Set();

  	}

  	addLayerUpdate( layerIndex ) {

  		this.layerUpdates.add( layerIndex );

  	}

  	clearLayerUpdates() {

  		this.layerUpdates.clear();

  	}

  }

  class Quaternion {

  	constructor( x = 0, y = 0, z = 0, w = 1 ) {

  		this.isQuaternion = true;

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  	}

  	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

  		// fuzz-free, array-based Quaternion SLERP operation

  		let x0 = src0[ srcOffset0 + 0 ],
  			y0 = src0[ srcOffset0 + 1 ],
  			z0 = src0[ srcOffset0 + 2 ],
  			w0 = src0[ srcOffset0 + 3 ];

  		const x1 = src1[ srcOffset1 + 0 ],
  			y1 = src1[ srcOffset1 + 1 ],
  			z1 = src1[ srcOffset1 + 2 ],
  			w1 = src1[ srcOffset1 + 3 ];

  		if ( t === 0 ) {

  			dst[ dstOffset + 0 ] = x0;
  			dst[ dstOffset + 1 ] = y0;
  			dst[ dstOffset + 2 ] = z0;
  			dst[ dstOffset + 3 ] = w0;
  			return;

  		}

  		if ( t === 1 ) {

  			dst[ dstOffset + 0 ] = x1;
  			dst[ dstOffset + 1 ] = y1;
  			dst[ dstOffset + 2 ] = z1;
  			dst[ dstOffset + 3 ] = w1;
  			return;

  		}

  		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

  			let s = 1 - t;
  			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
  				dir = ( cos >= 0 ? 1 : - 1 ),
  				sqrSin = 1 - cos * cos;

  			// Skip the Slerp for tiny steps to avoid numeric problems:
  			if ( sqrSin > Number.EPSILON ) {

  				const sin = Math.sqrt( sqrSin ),
  					len = Math.atan2( sin, cos * dir );

  				s = Math.sin( s * len ) / sin;
  				t = Math.sin( t * len ) / sin;

  			}

  			const tDir = t * dir;

  			x0 = x0 * s + x1 * tDir;
  			y0 = y0 * s + y1 * tDir;
  			z0 = z0 * s + z1 * tDir;
  			w0 = w0 * s + w1 * tDir;

  			// Normalize in case we just did a lerp:
  			if ( s === 1 - t ) {

  				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

  				x0 *= f;
  				y0 *= f;
  				z0 *= f;
  				w0 *= f;

  			}

  		}

  		dst[ dstOffset ] = x0;
  		dst[ dstOffset + 1 ] = y0;
  		dst[ dstOffset + 2 ] = z0;
  		dst[ dstOffset + 3 ] = w0;

  	}

  	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

  		const x0 = src0[ srcOffset0 ];
  		const y0 = src0[ srcOffset0 + 1 ];
  		const z0 = src0[ srcOffset0 + 2 ];
  		const w0 = src0[ srcOffset0 + 3 ];

  		const x1 = src1[ srcOffset1 ];
  		const y1 = src1[ srcOffset1 + 1 ];
  		const z1 = src1[ srcOffset1 + 2 ];
  		const w1 = src1[ srcOffset1 + 3 ];

  		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
  		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
  		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
  		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

  		return dst;

  	}

  	get x() {

  		return this._x;

  	}

  	set x( value ) {

  		this._x = value;
  		this._onChangeCallback();

  	}

  	get y() {

  		return this._y;

  	}

  	set y( value ) {

  		this._y = value;
  		this._onChangeCallback();

  	}

  	get z() {

  		return this._z;

  	}

  	set z( value ) {

  		this._z = value;
  		this._onChangeCallback();

  	}

  	get w() {

  		return this._w;

  	}

  	set w( value ) {

  		this._w = value;
  		this._onChangeCallback();

  	}

  	set( x, y, z, w ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  		this._onChangeCallback();

  		return this;

  	}

  	clone() {

  		return new this.constructor( this._x, this._y, this._z, this._w );

  	}

  	copy( quaternion ) {

  		this._x = quaternion.x;
  		this._y = quaternion.y;
  		this._z = quaternion.z;
  		this._w = quaternion.w;

  		this._onChangeCallback();

  		return this;

  	}

  	setFromEuler( euler, update = true ) {

  		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

  		// http://www.mathworks.com/matlabcentral/fileexchange/
  		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  		//	content/SpinCalc.m

  		const cos = Math.cos;
  		const sin = Math.sin;

  		const c1 = cos( x / 2 );
  		const c2 = cos( y / 2 );
  		const c3 = cos( z / 2 );

  		const s1 = sin( x / 2 );
  		const s2 = sin( y / 2 );
  		const s3 = sin( z / 2 );

  		switch ( order ) {

  			case 'XYZ':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'YXZ':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			case 'ZXY':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'ZYX':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			case 'YZX':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'XZY':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			default:
  				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

  		}

  		if ( update === true ) this._onChangeCallback();

  		return this;

  	}

  	setFromAxisAngle( axis, angle ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

  		// assumes axis is normalized

  		const halfAngle = angle / 2, s = Math.sin( halfAngle );

  		this._x = axis.x * s;
  		this._y = axis.y * s;
  		this._z = axis.z * s;
  		this._w = Math.cos( halfAngle );

  		this._onChangeCallback();

  		return this;

  	}

  	setFromRotationMatrix( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		const te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

  			trace = m11 + m22 + m33;

  		if ( trace > 0 ) {

  			const s = 0.5 / Math.sqrt( trace + 1.0 );

  			this._w = 0.25 / s;
  			this._x = ( m32 - m23 ) * s;
  			this._y = ( m13 - m31 ) * s;
  			this._z = ( m21 - m12 ) * s;

  		} else if ( m11 > m22 && m11 > m33 ) {

  			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

  			this._w = ( m32 - m23 ) / s;
  			this._x = 0.25 * s;
  			this._y = ( m12 + m21 ) / s;
  			this._z = ( m13 + m31 ) / s;

  		} else if ( m22 > m33 ) {

  			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

  			this._w = ( m13 - m31 ) / s;
  			this._x = ( m12 + m21 ) / s;
  			this._y = 0.25 * s;
  			this._z = ( m23 + m32 ) / s;

  		} else {

  			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

  			this._w = ( m21 - m12 ) / s;
  			this._x = ( m13 + m31 ) / s;
  			this._y = ( m23 + m32 ) / s;
  			this._z = 0.25 * s;

  		}

  		this._onChangeCallback();

  		return this;

  	}

  	setFromUnitVectors( vFrom, vTo ) {

  		// assumes direction vectors vFrom and vTo are normalized

  		let r = vFrom.dot( vTo ) + 1;

  		if ( r < Number.EPSILON ) {

  			// vFrom and vTo point in opposite directions

  			r = 0;

  			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

  				this._x = - vFrom.y;
  				this._y = vFrom.x;
  				this._z = 0;
  				this._w = r;

  			} else {

  				this._x = 0;
  				this._y = - vFrom.z;
  				this._z = vFrom.y;
  				this._w = r;

  			}

  		} else {

  			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

  			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
  			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
  			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
  			this._w = r;

  		}

  		return this.normalize();

  	}

  	angleTo( q ) {

  		return 2 * Math.acos( Math.abs( clamp$1( this.dot( q ), - 1, 1 ) ) );

  	}

  	rotateTowards( q, step ) {

  		const angle = this.angleTo( q );

  		if ( angle === 0 ) return this;

  		const t = Math.min( 1, step / angle );

  		this.slerp( q, t );

  		return this;

  	}

  	identity() {

  		return this.set( 0, 0, 0, 1 );

  	}

  	invert() {

  		// quaternion is assumed to have unit length

  		return this.conjugate();

  	}

  	conjugate() {

  		this._x *= - 1;
  		this._y *= - 1;
  		this._z *= - 1;

  		this._onChangeCallback();

  		return this;

  	}

  	dot( v ) {

  		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  	}

  	lengthSq() {

  		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  	}

  	length() {

  		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  	}

  	normalize() {

  		let l = this.length();

  		if ( l === 0 ) {

  			this._x = 0;
  			this._y = 0;
  			this._z = 0;
  			this._w = 1;

  		} else {

  			l = 1 / l;

  			this._x = this._x * l;
  			this._y = this._y * l;
  			this._z = this._z * l;
  			this._w = this._w * l;

  		}

  		this._onChangeCallback();

  		return this;

  	}

  	multiply( q ) {

  		return this.multiplyQuaternions( this, q );

  	}

  	premultiply( q ) {

  		return this.multiplyQuaternions( q, this );

  	}

  	multiplyQuaternions( a, b ) {

  		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

  		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
  		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

  		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
  		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
  		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
  		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

  		this._onChangeCallback();

  		return this;

  	}

  	slerp( qb, t ) {

  		if ( t === 0 ) return this;
  		if ( t === 1 ) return this.copy( qb );

  		const x = this._x, y = this._y, z = this._z, w = this._w;

  		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

  		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

  		if ( cosHalfTheta < 0 ) {

  			this._w = - qb._w;
  			this._x = - qb._x;
  			this._y = - qb._y;
  			this._z = - qb._z;

  			cosHalfTheta = - cosHalfTheta;

  		} else {

  			this.copy( qb );

  		}

  		if ( cosHalfTheta >= 1.0 ) {

  			this._w = w;
  			this._x = x;
  			this._y = y;
  			this._z = z;

  			return this;

  		}

  		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

  		if ( sqrSinHalfTheta <= Number.EPSILON ) {

  			const s = 1 - t;
  			this._w = s * w + t * this._w;
  			this._x = s * x + t * this._x;
  			this._y = s * y + t * this._y;
  			this._z = s * z + t * this._z;

  			this.normalize(); // normalize calls _onChangeCallback()

  			return this;

  		}

  		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
  		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
  		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
  			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

  		this._w = ( w * ratioA + this._w * ratioB );
  		this._x = ( x * ratioA + this._x * ratioB );
  		this._y = ( y * ratioA + this._y * ratioB );
  		this._z = ( z * ratioA + this._z * ratioB );

  		this._onChangeCallback();

  		return this;

  	}

  	slerpQuaternions( qa, qb, t ) {

  		return this.copy( qa ).slerp( qb, t );

  	}

  	random() {

  		// sets this quaternion to a uniform random unit quaternnion

  		// Ken Shoemake
  		// Uniform random rotations
  		// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

  		const theta1 = 2 * Math.PI * Math.random();
  		const theta2 = 2 * Math.PI * Math.random();

  		const x0 = Math.random();
  		const r1 = Math.sqrt( 1 - x0 );
  		const r2 = Math.sqrt( x0 );

  		return this.set(
  			r1 * Math.sin( theta1 ),
  			r1 * Math.cos( theta1 ),
  			r2 * Math.sin( theta2 ),
  			r2 * Math.cos( theta2 ),
  		);

  	}

  	equals( quaternion ) {

  		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  	}

  	fromArray( array, offset = 0 ) {

  		this._x = array[ offset ];
  		this._y = array[ offset + 1 ];
  		this._z = array[ offset + 2 ];
  		this._w = array[ offset + 3 ];

  		this._onChangeCallback();

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._w;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this._x = attribute.getX( index );
  		this._y = attribute.getY( index );
  		this._z = attribute.getZ( index );
  		this._w = attribute.getW( index );

  		this._onChangeCallback();

  		return this;

  	}

  	toJSON() {

  		return this.toArray();

  	}

  	_onChange( callback ) {

  		this._onChangeCallback = callback;

  		return this;

  	}

  	_onChangeCallback() {}

  	*[ Symbol.iterator ]() {

  		yield this._x;
  		yield this._y;
  		yield this._z;
  		yield this._w;

  	}

  }

  class Vector3 {

  	constructor( x = 0, y = 0, z = 0 ) {

  		Vector3.prototype.isVector3 = true;

  		this.x = x;
  		this.y = y;
  		this.z = z;

  	}

  	set( x, y, z ) {

  		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

  		this.x = x;
  		this.y = y;
  		this.z = z;

  		return this;

  	}

  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;

  		return this;

  	}

  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	setZ( z ) {

  		this.z = z;

  		return this;

  	}

  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	clone() {

  		return new this.constructor( this.x, this.y, this.z );

  	}

  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;

  		return this;

  	}

  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;

  		return this;

  	}

  	addScalar( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;

  		return this;

  	}

  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;

  		return this;

  	}

  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;

  		return this;

  	}

  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;

  		return this;

  	}

  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;

  		return this;

  	}

  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;

  		return this;

  	}

  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;

  		return this;

  	}

  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;

  		return this;

  	}

  	multiplyVectors( a, b ) {

  		this.x = a.x * b.x;
  		this.y = a.y * b.y;
  		this.z = a.z * b.z;

  		return this;

  	}

  	applyEuler( euler ) {

  		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

  	}

  	applyAxisAngle( axis, angle ) {

  		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

  	}

  	applyMatrix3( m ) {

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
  		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

  		return this;

  	}

  	applyNormalMatrix( m ) {

  		return this.applyMatrix3( m ).normalize();

  	}

  	applyMatrix4( m ) {

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

  		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
  		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
  		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

  		return this;

  	}

  	applyQuaternion( q ) {

  		// quaternion q is assumed to have unit length

  		const vx = this.x, vy = this.y, vz = this.z;
  		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  		// t = 2 * cross( q.xyz, v );
  		const tx = 2 * ( qy * vz - qz * vy );
  		const ty = 2 * ( qz * vx - qx * vz );
  		const tz = 2 * ( qx * vy - qy * vx );

  		// v + q.w * t + cross( q.xyz, t );
  		this.x = vx + qw * tx + qy * tz - qz * ty;
  		this.y = vy + qw * ty + qz * tx - qx * tz;
  		this.z = vz + qw * tz + qx * ty - qy * tx;

  		return this;

  	}

  	project( camera ) {

  		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

  	}

  	unproject( camera ) {

  		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

  	}

  	transformDirection( m ) {

  		// input: THREE.Matrix4 affine matrix
  		// vector interpreted as a direction

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

  		return this.normalize();

  	}

  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;
  		this.z /= v.z;

  		return this;

  	}

  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );

  		return this;

  	}

  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );

  		return this;

  	}

  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

  		return this;

  	}

  	clampScalar( minVal, maxVal ) {

  		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
  		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
  		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

  		return this;

  	}

  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	}

  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );

  		return this;

  	}

  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );

  		return this;

  	}

  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );

  		return this;

  	}

  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );
  		this.z = Math.trunc( this.z );

  		return this;

  	}

  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;

  		return this;

  	}

  	dot( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z;

  	}

  	// TODO lengthSquared?

  	lengthSq() {

  		return this.x * this.x + this.y * this.y + this.z * this.z;

  	}

  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  	}

  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  	}

  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;

  		return this;

  	}

  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;
  		this.z = v1.z + ( v2.z - v1.z ) * alpha;

  		return this;

  	}

  	cross( v ) {

  		return this.crossVectors( this, v );

  	}

  	crossVectors( a, b ) {

  		const ax = a.x, ay = a.y, az = a.z;
  		const bx = b.x, by = b.y, bz = b.z;

  		this.x = ay * bz - az * by;
  		this.y = az * bx - ax * bz;
  		this.z = ax * by - ay * bx;

  		return this;

  	}

  	projectOnVector( v ) {

  		const denominator = v.lengthSq();

  		if ( denominator === 0 ) return this.set( 0, 0, 0 );

  		const scalar = v.dot( this ) / denominator;

  		return this.copy( v ).multiplyScalar( scalar );

  	}

  	projectOnPlane( planeNormal ) {

  		_vector$c.copy( this ).projectOnVector( planeNormal );

  		return this.sub( _vector$c );

  	}

  	reflect( normal ) {

  		// reflect incident vector off plane orthogonal to normal
  		// normal is assumed to have unit length

  		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

  	}

  	angleTo( v ) {

  		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

  		if ( denominator === 0 ) return Math.PI / 2;

  		const theta = this.dot( v ) / denominator;

  		// clamp, to handle numerical problems

  		return Math.acos( clamp$1( theta, - 1, 1 ) );

  	}

  	distanceTo( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	}

  	distanceToSquared( v ) {

  		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

  		return dx * dx + dy * dy + dz * dz;

  	}

  	manhattanDistanceTo( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

  	}

  	setFromSpherical( s ) {

  		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

  	}

  	setFromSphericalCoords( radius, phi, theta ) {

  		const sinPhiRadius = Math.sin( phi ) * radius;

  		this.x = sinPhiRadius * Math.sin( theta );
  		this.y = Math.cos( phi ) * radius;
  		this.z = sinPhiRadius * Math.cos( theta );

  		return this;

  	}

  	setFromCylindrical( c ) {

  		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

  	}

  	setFromCylindricalCoords( radius, theta, y ) {

  		this.x = radius * Math.sin( theta );
  		this.y = y;
  		this.z = radius * Math.cos( theta );

  		return this;

  	}

  	setFromMatrixPosition( m ) {

  		const e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];

  		return this;

  	}

  	setFromMatrixScale( m ) {

  		const sx = this.setFromMatrixColumn( m, 0 ).length();
  		const sy = this.setFromMatrixColumn( m, 1 ).length();
  		const sz = this.setFromMatrixColumn( m, 2 ).length();

  		this.x = sx;
  		this.y = sy;
  		this.z = sz;

  		return this;

  	}

  	setFromMatrixColumn( m, index ) {

  		return this.fromArray( m.elements, index * 4 );

  	}

  	setFromMatrix3Column( m, index ) {

  		return this.fromArray( m.elements, index * 3 );

  	}

  	setFromEuler( e ) {

  		this.x = e._x;
  		this.y = e._y;
  		this.z = e._z;

  		return this;

  	}

  	setFromColor( c ) {

  		this.x = c.r;
  		this.y = c.g;
  		this.z = c.b;

  		return this;

  	}

  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  	}

  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );

  		return this;

  	}

  	random() {

  		this.x = Math.random();
  		this.y = Math.random();
  		this.z = Math.random();

  		return this;

  	}

  	randomDirection() {

  		// https://mathworld.wolfram.com/SpherePointPicking.html

  		const theta = Math.random() * Math.PI * 2;
  		const u = Math.random() * 2 - 1;
  		const c = Math.sqrt( 1 - u * u );

  		this.x = c * Math.cos( theta );
  		this.y = u;
  		this.z = c * Math.sin( theta );

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;
  		yield this.z;

  	}

  }

  const _vector$c = /*@__PURE__*/ new Vector3();
  const _quaternion$4 = /*@__PURE__*/ new Quaternion();

  class Box3 {

  	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

  		this.isBox3 = true;

  		this.min = min;
  		this.max = max;

  	}

  	set( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	}

  	setFromArray( array ) {

  		this.makeEmpty();

  		for ( let i = 0, il = array.length; i < il; i += 3 ) {

  			this.expandByPoint( _vector$b.fromArray( array, i ) );

  		}

  		return this;

  	}

  	setFromBufferAttribute( attribute ) {

  		this.makeEmpty();

  		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

  			this.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );

  		}

  		return this;

  	}

  	setFromPoints( points ) {

  		this.makeEmpty();

  		for ( let i = 0, il = points.length; i < il; i ++ ) {

  			this.expandByPoint( points[ i ] );

  		}

  		return this;

  	}

  	setFromCenterAndSize( center, size ) {

  		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

  		this.min.copy( center ).sub( halfSize );
  		this.max.copy( center ).add( halfSize );

  		return this;

  	}

  	setFromObject( object, precise = false ) {

  		this.makeEmpty();

  		return this.expandByObject( object, precise );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	}

  	makeEmpty() {

  		this.min.x = this.min.y = this.min.z = + Infinity;
  		this.max.x = this.max.y = this.max.z = - Infinity;

  		return this;

  	}

  	isEmpty() {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  	}

  	getCenter( target ) {

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	}

  	getSize( target ) {

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

  	}

  	expandByPoint( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	}

  	expandByVector( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	}

  	expandByScalar( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	}

  	expandByObject( object, precise = false ) {

  		// Computes the world-axis-aligned bounding box of an object (including its children),
  		// accounting for both the object's, and children's, world transforms

  		object.updateWorldMatrix( false, false );

  		const geometry = object.geometry;

  		if ( geometry !== undefined ) {

  			const positionAttribute = geometry.getAttribute( 'position' );

  			// precise AABB computation based on vertex data requires at least a position attribute.
  			// instancing isn't supported so far and uses the normal (conservative) code path.

  			if ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {

  				for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

  					if ( object.isMesh === true ) {

  						object.getVertexPosition( i, _vector$b );

  					} else {

  						_vector$b.fromBufferAttribute( positionAttribute, i );

  					}

  					_vector$b.applyMatrix4( object.matrixWorld );
  					this.expandByPoint( _vector$b );

  				}

  			} else {

  				if ( object.boundingBox !== undefined ) {

  					// object-level bounding box

  					if ( object.boundingBox === null ) {

  						object.computeBoundingBox();

  					}

  					_box$4.copy( object.boundingBox );


  				} else {

  					// geometry-level bounding box

  					if ( geometry.boundingBox === null ) {

  						geometry.computeBoundingBox();

  					}

  					_box$4.copy( geometry.boundingBox );

  				}

  				_box$4.applyMatrix4( object.matrixWorld );

  				this.union( _box$4 );

  			}

  		}

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			this.expandByObject( children[ i ], precise );

  		}

  		return this;

  	}

  	containsPoint( point ) {

  		return point.x >= this.min.x && point.x <= this.max.x &&
  			point.y >= this.min.y && point.y <= this.max.y &&
  			point.z >= this.min.z && point.z <= this.max.z;

  	}

  	containsBox( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y &&
  			this.min.z <= box.min.z && box.max.z <= this.max.z;

  	}

  	getParameter( point, target ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		return target.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
  			( point.z - this.min.z ) / ( this.max.z - this.min.z )
  		);

  	}

  	intersectsBox( box ) {

  		// using 6 splitting planes to rule out intersections.
  		return box.max.x >= this.min.x && box.min.x <= this.max.x &&
  			box.max.y >= this.min.y && box.min.y <= this.max.y &&
  			box.max.z >= this.min.z && box.min.z <= this.max.z;

  	}

  	intersectsSphere( sphere ) {

  		// Find the point on the AABB closest to the sphere center.
  		this.clampPoint( sphere.center, _vector$b );

  		// If that point is inside the sphere, the AABB and sphere intersect.
  		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

  	}

  	intersectsPlane( plane ) {

  		// We compute the minimum and maximum dot product values. If those values
  		// are on the same side (back or front) of the plane, then there is no intersection.

  		let min, max;

  		if ( plane.normal.x > 0 ) {

  			min = plane.normal.x * this.min.x;
  			max = plane.normal.x * this.max.x;

  		} else {

  			min = plane.normal.x * this.max.x;
  			max = plane.normal.x * this.min.x;

  		}

  		if ( plane.normal.y > 0 ) {

  			min += plane.normal.y * this.min.y;
  			max += plane.normal.y * this.max.y;

  		} else {

  			min += plane.normal.y * this.max.y;
  			max += plane.normal.y * this.min.y;

  		}

  		if ( plane.normal.z > 0 ) {

  			min += plane.normal.z * this.min.z;
  			max += plane.normal.z * this.max.z;

  		} else {

  			min += plane.normal.z * this.max.z;
  			max += plane.normal.z * this.min.z;

  		}

  		return ( min <= - plane.constant && max >= - plane.constant );

  	}

  	intersectsTriangle( triangle ) {

  		if ( this.isEmpty() ) {

  			return false;

  		}

  		// compute box center and extents
  		this.getCenter( _center );
  		_extents.subVectors( this.max, _center );

  		// translate triangle to aabb origin
  		_v0$2.subVectors( triangle.a, _center );
  		_v1$7.subVectors( triangle.b, _center );
  		_v2$4.subVectors( triangle.c, _center );

  		// compute edge vectors for triangle
  		_f0.subVectors( _v1$7, _v0$2 );
  		_f1.subVectors( _v2$4, _v1$7 );
  		_f2.subVectors( _v0$2, _v2$4 );

  		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
  		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
  		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
  		let axes = [
  			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
  			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
  			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
  		];
  		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

  			return false;

  		}

  		// test 3 face normals from the aabb
  		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
  		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

  			return false;

  		}

  		// finally testing the face normal of the triangle
  		// use already existing triangle edge vectors here
  		_triangleNormal.crossVectors( _f0, _f1 );
  		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

  		return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

  	}

  	clampPoint( point, target ) {

  		return target.copy( point ).clamp( this.min, this.max );

  	}

  	distanceToPoint( point ) {

  		return this.clampPoint( point, _vector$b ).distanceTo( point );

  	}

  	getBoundingSphere( target ) {

  		if ( this.isEmpty() ) {

  			target.makeEmpty();

  		} else {

  			this.getCenter( target.center );

  			target.radius = this.getSize( _vector$b ).length() * 0.5;

  		}

  		return target;

  	}

  	intersect( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  		if ( this.isEmpty() ) this.makeEmpty();

  		return this;

  	}

  	union( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	}

  	applyMatrix4( matrix ) {

  		// transform of empty box is an empty box.
  		if ( this.isEmpty() ) return this;

  		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
  		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
  		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
  		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
  		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
  		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
  		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
  		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

  		this.setFromPoints( _points );

  		return this;

  	}

  	translate( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	}

  	equals( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  }

  const _points = [
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3()
  ];

  const _vector$b = /*@__PURE__*/ new Vector3();

  const _box$4 = /*@__PURE__*/ new Box3();

  // triangle centered vertices

  const _v0$2 = /*@__PURE__*/ new Vector3();
  const _v1$7 = /*@__PURE__*/ new Vector3();
  const _v2$4 = /*@__PURE__*/ new Vector3();

  // triangle edge vectors

  const _f0 = /*@__PURE__*/ new Vector3();
  const _f1 = /*@__PURE__*/ new Vector3();
  const _f2 = /*@__PURE__*/ new Vector3();

  const _center = /*@__PURE__*/ new Vector3();
  const _extents = /*@__PURE__*/ new Vector3();
  const _triangleNormal = /*@__PURE__*/ new Vector3();
  const _testAxis = /*@__PURE__*/ new Vector3();

  function satForAxes( axes, v0, v1, v2, extents ) {

  	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

  		_testAxis.fromArray( axes, i );
  		// project the aabb onto the separating axis
  		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
  		// project all 3 vertices of the triangle onto the separating axis
  		const p0 = v0.dot( _testAxis );
  		const p1 = v1.dot( _testAxis );
  		const p2 = v2.dot( _testAxis );
  		// actual test, basically see if either of the most extreme of the triangle points intersects r
  		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

  			// points of the projected triangle are outside the projected half-length of the aabb
  			// the axis is separating and we can exit
  			return false;

  		}

  	}

  	return true;

  }

  const _box$3 = /*@__PURE__*/ new Box3();
  const _v1$6 = /*@__PURE__*/ new Vector3();
  const _v2$3 = /*@__PURE__*/ new Vector3();

  class Sphere {

  	constructor( center = new Vector3(), radius = - 1 ) {

  		this.isSphere = true;

  		this.center = center;
  		this.radius = radius;

  	}

  	set( center, radius ) {

  		this.center.copy( center );
  		this.radius = radius;

  		return this;

  	}

  	setFromPoints( points, optionalCenter ) {

  		const center = this.center;

  		if ( optionalCenter !== undefined ) {

  			center.copy( optionalCenter );

  		} else {

  			_box$3.setFromPoints( points ).getCenter( center );

  		}

  		let maxRadiusSq = 0;

  		for ( let i = 0, il = points.length; i < il; i ++ ) {

  			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

  		}

  		this.radius = Math.sqrt( maxRadiusSq );

  		return this;

  	}

  	copy( sphere ) {

  		this.center.copy( sphere.center );
  		this.radius = sphere.radius;

  		return this;

  	}

  	isEmpty() {

  		return ( this.radius < 0 );

  	}

  	makeEmpty() {

  		this.center.set( 0, 0, 0 );
  		this.radius = - 1;

  		return this;

  	}

  	containsPoint( point ) {

  		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  	}

  	distanceToPoint( point ) {

  		return ( point.distanceTo( this.center ) - this.radius );

  	}

  	intersectsSphere( sphere ) {

  		const radiusSum = this.radius + sphere.radius;

  		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  	}

  	intersectsBox( box ) {

  		return box.intersectsSphere( this );

  	}

  	intersectsPlane( plane ) {

  		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

  	}

  	clampPoint( point, target ) {

  		const deltaLengthSq = this.center.distanceToSquared( point );

  		target.copy( point );

  		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

  			target.sub( this.center ).normalize();
  			target.multiplyScalar( this.radius ).add( this.center );

  		}

  		return target;

  	}

  	getBoundingBox( target ) {

  		if ( this.isEmpty() ) {

  			// Empty sphere produces empty bounding box
  			target.makeEmpty();
  			return target;

  		}

  		target.set( this.center, this.center );
  		target.expandByScalar( this.radius );

  		return target;

  	}

  	applyMatrix4( matrix ) {

  		this.center.applyMatrix4( matrix );
  		this.radius = this.radius * matrix.getMaxScaleOnAxis();

  		return this;

  	}

  	translate( offset ) {

  		this.center.add( offset );

  		return this;

  	}

  	expandByPoint( point ) {

  		if ( this.isEmpty() ) {

  			this.center.copy( point );

  			this.radius = 0;

  			return this;

  		}

  		_v1$6.subVectors( point, this.center );

  		const lengthSq = _v1$6.lengthSq();

  		if ( lengthSq > ( this.radius * this.radius ) ) {

  			// calculate the minimal sphere

  			const length = Math.sqrt( lengthSq );

  			const delta = ( length - this.radius ) * 0.5;

  			this.center.addScaledVector( _v1$6, delta / length );

  			this.radius += delta;

  		}

  		return this;

  	}

  	union( sphere ) {

  		if ( sphere.isEmpty() ) {

  			return this;

  		}

  		if ( this.isEmpty() ) {

  			this.copy( sphere );

  			return this;

  		}

  		if ( this.center.equals( sphere.center ) === true ) {

  			 this.radius = Math.max( this.radius, sphere.radius );

  		} else {

  			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

  			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

  			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

  		}

  		return this;

  	}

  	equals( sphere ) {

  		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _vector$a = /*@__PURE__*/ new Vector3();
  const _segCenter = /*@__PURE__*/ new Vector3();
  const _segDir = /*@__PURE__*/ new Vector3();
  const _diff = /*@__PURE__*/ new Vector3();

  const _edge1 = /*@__PURE__*/ new Vector3();
  const _edge2 = /*@__PURE__*/ new Vector3();
  const _normal$2 = /*@__PURE__*/ new Vector3();

  class Ray {

  	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

  		this.origin = origin;
  		this.direction = direction;

  	}

  	set( origin, direction ) {

  		this.origin.copy( origin );
  		this.direction.copy( direction );

  		return this;

  	}

  	copy( ray ) {

  		this.origin.copy( ray.origin );
  		this.direction.copy( ray.direction );

  		return this;

  	}

  	at( t, target ) {

  		return target.copy( this.origin ).addScaledVector( this.direction, t );

  	}

  	lookAt( v ) {

  		this.direction.copy( v ).sub( this.origin ).normalize();

  		return this;

  	}

  	recast( t ) {

  		this.origin.copy( this.at( t, _vector$a ) );

  		return this;

  	}

  	closestPointToPoint( point, target ) {

  		target.subVectors( point, this.origin );

  		const directionDistance = target.dot( this.direction );

  		if ( directionDistance < 0 ) {

  			return target.copy( this.origin );

  		}

  		return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

  	}

  	distanceToPoint( point ) {

  		return Math.sqrt( this.distanceSqToPoint( point ) );

  	}

  	distanceSqToPoint( point ) {

  		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

  		// point behind the ray

  		if ( directionDistance < 0 ) {

  			return this.origin.distanceToSquared( point );

  		}

  		_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );

  		return _vector$a.distanceToSquared( point );

  	}

  	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

  		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
  		// It returns the min distance between the ray and the segment
  		// defined by v0 and v1
  		// It can also set two optional targets :
  		// - The closest point on the ray
  		// - The closest point on the segment

  		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
  		_segDir.copy( v1 ).sub( v0 ).normalize();
  		_diff.copy( this.origin ).sub( _segCenter );

  		const segExtent = v0.distanceTo( v1 ) * 0.5;
  		const a01 = - this.direction.dot( _segDir );
  		const b0 = _diff.dot( this.direction );
  		const b1 = - _diff.dot( _segDir );
  		const c = _diff.lengthSq();
  		const det = Math.abs( 1 - a01 * a01 );
  		let s0, s1, sqrDist, extDet;

  		if ( det > 0 ) {

  			// The ray and segment are not parallel.

  			s0 = a01 * b1 - b0;
  			s1 = a01 * b0 - b1;
  			extDet = segExtent * det;

  			if ( s0 >= 0 ) {

  				if ( s1 >= - extDet ) {

  					if ( s1 <= extDet ) {

  						// region 0
  						// Minimum at interior points of ray and segment.

  						const invDet = 1 / det;
  						s0 *= invDet;
  						s1 *= invDet;
  						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

  					} else {

  						// region 1

  						s1 = segExtent;
  						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				} else {

  					// region 5

  					s1 = - segExtent;
  					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				}

  			} else {

  				if ( s1 <= - extDet ) {

  					// region 4

  					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
  					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				} else if ( s1 <= extDet ) {

  					// region 3

  					s0 = 0;
  					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

  				} else {

  					// region 2

  					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
  					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				}

  			}

  		} else {

  			// Ray and segment are parallel.

  			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
  			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  		}

  		if ( optionalPointOnRay ) {

  			optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

  		}

  		if ( optionalPointOnSegment ) {

  			optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

  		}

  		return sqrDist;

  	}

  	intersectSphere( sphere, target ) {

  		_vector$a.subVectors( sphere.center, this.origin );
  		const tca = _vector$a.dot( this.direction );
  		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
  		const radius2 = sphere.radius * sphere.radius;

  		if ( d2 > radius2 ) return null;

  		const thc = Math.sqrt( radius2 - d2 );

  		// t0 = first intersect point - entrance on front of sphere
  		const t0 = tca - thc;

  		// t1 = second intersect point - exit point on back of sphere
  		const t1 = tca + thc;

  		// test to see if t1 is behind the ray - if so, return null
  		if ( t1 < 0 ) return null;

  		// test to see if t0 is behind the ray:
  		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  		// in order to always return an intersect point that is in front of the ray.
  		if ( t0 < 0 ) return this.at( t1, target );

  		// else t0 is in front of the ray, so return the first collision point scaled by t0
  		return this.at( t0, target );

  	}

  	intersectsSphere( sphere ) {

  		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

  	}

  	distanceToPlane( plane ) {

  		const denominator = plane.normal.dot( this.direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( plane.distanceToPoint( this.origin ) === 0 ) {

  				return 0;

  			}

  			// Null is preferable to undefined since undefined means.... it is undefined

  			return null;

  		}

  		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

  		// Return if the ray never intersects the plane

  		return t >= 0 ? t : null;

  	}

  	intersectPlane( plane, target ) {

  		const t = this.distanceToPlane( plane );

  		if ( t === null ) {

  			return null;

  		}

  		return this.at( t, target );

  	}

  	intersectsPlane( plane ) {

  		// check if the ray lies on the plane first

  		const distToPoint = plane.distanceToPoint( this.origin );

  		if ( distToPoint === 0 ) {

  			return true;

  		}

  		const denominator = plane.normal.dot( this.direction );

  		if ( denominator * distToPoint < 0 ) {

  			return true;

  		}

  		// ray origin is behind the plane (and is pointing behind it)

  		return false;

  	}

  	intersectBox( box, target ) {

  		let tmin, tmax, tymin, tymax, tzmin, tzmax;

  		const invdirx = 1 / this.direction.x,
  			invdiry = 1 / this.direction.y,
  			invdirz = 1 / this.direction.z;

  		const origin = this.origin;

  		if ( invdirx >= 0 ) {

  			tmin = ( box.min.x - origin.x ) * invdirx;
  			tmax = ( box.max.x - origin.x ) * invdirx;

  		} else {

  			tmin = ( box.max.x - origin.x ) * invdirx;
  			tmax = ( box.min.x - origin.x ) * invdirx;

  		}

  		if ( invdiry >= 0 ) {

  			tymin = ( box.min.y - origin.y ) * invdiry;
  			tymax = ( box.max.y - origin.y ) * invdiry;

  		} else {

  			tymin = ( box.max.y - origin.y ) * invdiry;
  			tymax = ( box.min.y - origin.y ) * invdiry;

  		}

  		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

  		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

  		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

  		if ( invdirz >= 0 ) {

  			tzmin = ( box.min.z - origin.z ) * invdirz;
  			tzmax = ( box.max.z - origin.z ) * invdirz;

  		} else {

  			tzmin = ( box.max.z - origin.z ) * invdirz;
  			tzmax = ( box.min.z - origin.z ) * invdirz;

  		}

  		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

  		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

  		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

  		//return point closest to the ray (positive side)

  		if ( tmax < 0 ) return null;

  		return this.at( tmin >= 0 ? tmin : tmax, target );

  	}

  	intersectsBox( box ) {

  		return this.intersectBox( box, _vector$a ) !== null;

  	}

  	intersectTriangle( a, b, c, backfaceCulling, target ) {

  		// Compute the offset origin, edges, and normal.

  		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

  		_edge1.subVectors( b, a );
  		_edge2.subVectors( c, a );
  		_normal$2.crossVectors( _edge1, _edge2 );

  		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  		let DdN = this.direction.dot( _normal$2 );
  		let sign;

  		if ( DdN > 0 ) {

  			if ( backfaceCulling ) return null;
  			sign = 1;

  		} else if ( DdN < 0 ) {

  			sign = - 1;
  			DdN = - DdN;

  		} else {

  			return null;

  		}

  		_diff.subVectors( this.origin, a );
  		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

  		// b1 < 0, no intersection
  		if ( DdQxE2 < 0 ) {

  			return null;

  		}

  		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

  		// b2 < 0, no intersection
  		if ( DdE1xQ < 0 ) {

  			return null;

  		}

  		// b1+b2 > 1, no intersection
  		if ( DdQxE2 + DdE1xQ > DdN ) {

  			return null;

  		}

  		// Line intersects triangle, check if ray does.
  		const QdN = - sign * _diff.dot( _normal$2 );

  		// t < 0, no intersection
  		if ( QdN < 0 ) {

  			return null;

  		}

  		// Ray intersects triangle.
  		return this.at( QdN / DdN, target );

  	}

  	applyMatrix4( matrix4 ) {

  		this.origin.applyMatrix4( matrix4 );
  		this.direction.transformDirection( matrix4 );

  		return this;

  	}

  	equals( ray ) {

  		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  class Matrix4 {

  	constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		Matrix4.prototype.isMatrix4 = true;

  		this.elements = [

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		];

  		if ( n11 !== undefined ) {

  			this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

  		}

  	}

  	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		const te = this.elements;

  		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
  		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
  		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
  		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

  		return this;

  	}

  	identity() {

  		this.set(

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	clone() {

  		return new Matrix4().fromArray( this.elements );

  	}

  	copy( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
  		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
  		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
  		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

  		return this;

  	}

  	copyPosition( m ) {

  		const te = this.elements, me = m.elements;

  		te[ 12 ] = me[ 12 ];
  		te[ 13 ] = me[ 13 ];
  		te[ 14 ] = me[ 14 ];

  		return this;

  	}

  	setFromMatrix3( m ) {

  		const me = m.elements;

  		this.set(

  			me[ 0 ], me[ 3 ], me[ 6 ], 0,
  			me[ 1 ], me[ 4 ], me[ 7 ], 0,
  			me[ 2 ], me[ 5 ], me[ 8 ], 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	extractBasis( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrixColumn( this, 0 );
  		yAxis.setFromMatrixColumn( this, 1 );
  		zAxis.setFromMatrixColumn( this, 2 );

  		return this;

  	}

  	makeBasis( xAxis, yAxis, zAxis ) {

  		this.set(
  			xAxis.x, yAxis.x, zAxis.x, 0,
  			xAxis.y, yAxis.y, zAxis.y, 0,
  			xAxis.z, yAxis.z, zAxis.z, 0,
  			0, 0, 0, 1
  		);

  		return this;

  	}

  	extractRotation( m ) {

  		// this method does not support reflection matrices

  		const te = this.elements;
  		const me = m.elements;

  		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
  		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
  		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

  		te[ 0 ] = me[ 0 ] * scaleX;
  		te[ 1 ] = me[ 1 ] * scaleX;
  		te[ 2 ] = me[ 2 ] * scaleX;
  		te[ 3 ] = 0;

  		te[ 4 ] = me[ 4 ] * scaleY;
  		te[ 5 ] = me[ 5 ] * scaleY;
  		te[ 6 ] = me[ 6 ] * scaleY;
  		te[ 7 ] = 0;

  		te[ 8 ] = me[ 8 ] * scaleZ;
  		te[ 9 ] = me[ 9 ] * scaleZ;
  		te[ 10 ] = me[ 10 ] * scaleZ;
  		te[ 11 ] = 0;

  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	}

  	makeRotationFromEuler( euler ) {

  		const te = this.elements;

  		const x = euler.x, y = euler.y, z = euler.z;
  		const a = Math.cos( x ), b = Math.sin( x );
  		const c = Math.cos( y ), d = Math.sin( y );
  		const e = Math.cos( z ), f = Math.sin( z );

  		if ( euler.order === 'XYZ' ) {

  			const ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - c * f;
  			te[ 8 ] = d;

  			te[ 1 ] = af + be * d;
  			te[ 5 ] = ae - bf * d;
  			te[ 9 ] = - b * c;

  			te[ 2 ] = bf - ae * d;
  			te[ 6 ] = be + af * d;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YXZ' ) {

  			const ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce + df * b;
  			te[ 4 ] = de * b - cf;
  			te[ 8 ] = a * d;

  			te[ 1 ] = a * f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b;

  			te[ 2 ] = cf * b - de;
  			te[ 6 ] = df + ce * b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZXY' ) {

  			const ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce - df * b;
  			te[ 4 ] = - a * f;
  			te[ 8 ] = de + cf * b;

  			te[ 1 ] = cf + de * b;
  			te[ 5 ] = a * e;
  			te[ 9 ] = df - ce * b;

  			te[ 2 ] = - a * d;
  			te[ 6 ] = b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZYX' ) {

  			const ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = be * d - af;
  			te[ 8 ] = ae * d + bf;

  			te[ 1 ] = c * f;
  			te[ 5 ] = bf * d + ae;
  			te[ 9 ] = af * d - be;

  			te[ 2 ] = - d;
  			te[ 6 ] = b * c;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YZX' ) {

  			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = bd - ac * f;
  			te[ 8 ] = bc * f + ad;

  			te[ 1 ] = f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b * e;

  			te[ 2 ] = - d * e;
  			te[ 6 ] = ad * f + bc;
  			te[ 10 ] = ac - bd * f;

  		} else if ( euler.order === 'XZY' ) {

  			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - f;
  			te[ 8 ] = d * e;

  			te[ 1 ] = ac * f + bd;
  			te[ 5 ] = a * e;
  			te[ 9 ] = ad * f - bc;

  			te[ 2 ] = bc * f - ad;
  			te[ 6 ] = b * e;
  			te[ 10 ] = bd * f + ac;

  		}

  		// bottom row
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// last column
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	}

  	makeRotationFromQuaternion( q ) {

  		return this.compose( _zero, q, _one );

  	}

  	lookAt( eye, target, up ) {

  		const te = this.elements;

  		_z.subVectors( eye, target );

  		if ( _z.lengthSq() === 0 ) {

  			// eye and target are in the same position

  			_z.z = 1;

  		}

  		_z.normalize();
  		_x.crossVectors( up, _z );

  		if ( _x.lengthSq() === 0 ) {

  			// up and z are parallel

  			if ( Math.abs( up.z ) === 1 ) {

  				_z.x += 0.0001;

  			} else {

  				_z.z += 0.0001;

  			}

  			_z.normalize();
  			_x.crossVectors( up, _z );

  		}

  		_x.normalize();
  		_y.crossVectors( _z, _x );

  		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
  		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
  		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

  		return this;

  	}

  	multiply( m ) {

  		return this.multiplyMatrices( this, m );

  	}

  	premultiply( m ) {

  		return this.multiplyMatrices( m, this );

  	}

  	multiplyMatrices( a, b ) {

  		const ae = a.elements;
  		const be = b.elements;
  		const te = this.elements;

  		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
  		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
  		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
  		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

  		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
  		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
  		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
  		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

  		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

  		return this;

  	}

  	multiplyScalar( s ) {

  		const te = this.elements;

  		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
  		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
  		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
  		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

  		return this;

  	}

  	determinant() {

  		const te = this.elements;

  		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
  		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
  		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
  		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

  		//TODO: make this more efficient
  		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

  		return (
  			n41 * (
  				+ n14 * n23 * n32
  				 - n13 * n24 * n32
  				 - n14 * n22 * n33
  				 + n12 * n24 * n33
  				 + n13 * n22 * n34
  				 - n12 * n23 * n34
  			) +
  			n42 * (
  				+ n11 * n23 * n34
  				 - n11 * n24 * n33
  				 + n14 * n21 * n33
  				 - n13 * n21 * n34
  				 + n13 * n24 * n31
  				 - n14 * n23 * n31
  			) +
  			n43 * (
  				+ n11 * n24 * n32
  				 - n11 * n22 * n34
  				 - n14 * n21 * n32
  				 + n12 * n21 * n34
  				 + n14 * n22 * n31
  				 - n12 * n24 * n31
  			) +
  			n44 * (
  				- n13 * n22 * n31
  				 - n11 * n23 * n32
  				 + n11 * n22 * n33
  				 + n13 * n21 * n32
  				 - n12 * n21 * n33
  				 + n12 * n23 * n31
  			)

  		);

  	}

  	transpose() {

  		const te = this.elements;
  		let tmp;

  		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
  		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
  		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

  		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
  		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
  		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

  		return this;

  	}

  	setPosition( x, y, z ) {

  		const te = this.elements;

  		if ( x.isVector3 ) {

  			te[ 12 ] = x.x;
  			te[ 13 ] = x.y;
  			te[ 14 ] = x.z;

  		} else {

  			te[ 12 ] = x;
  			te[ 13 ] = y;
  			te[ 14 ] = z;

  		}

  		return this;

  	}

  	invert() {

  		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  		const te = this.elements,

  			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
  			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
  			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
  			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

  			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
  			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
  			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
  			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

  		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

  		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

  		const detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
  		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
  		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

  		te[ 4 ] = t12 * detInv;
  		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
  		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
  		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

  		te[ 8 ] = t13 * detInv;
  		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
  		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
  		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

  		te[ 12 ] = t14 * detInv;
  		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
  		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
  		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

  		return this;

  	}

  	scale( v ) {

  		const te = this.elements;
  		const x = v.x, y = v.y, z = v.z;

  		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
  		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
  		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
  		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

  		return this;

  	}

  	getMaxScaleOnAxis() {

  		const te = this.elements;

  		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
  		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
  		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

  		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

  	}

  	makeTranslation( x, y, z ) {

  		if ( x.isVector3 ) {

  			this.set(

  				1, 0, 0, x.x,
  				0, 1, 0, x.y,
  				0, 0, 1, x.z,
  				0, 0, 0, 1

  			);

  		} else {

  			this.set(

  				1, 0, 0, x,
  				0, 1, 0, y,
  				0, 0, 1, z,
  				0, 0, 0, 1

  			);

  		}

  		return this;

  	}

  	makeRotationX( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			1, 0, 0, 0,
  			0, c, - s, 0,
  			0, s, c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeRotationY( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			 c, 0, s, 0,
  			 0, 1, 0, 0,
  			- s, 0, c, 0,
  			 0, 0, 0, 1

  		);

  		return this;

  	}

  	makeRotationZ( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			c, - s, 0, 0,
  			s, c, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeRotationAxis( axis, angle ) {

  		// Based on http://www.gamedev.net/reference/articles/article1199.asp

  		const c = Math.cos( angle );
  		const s = Math.sin( angle );
  		const t = 1 - c;
  		const x = axis.x, y = axis.y, z = axis.z;
  		const tx = t * x, ty = t * y;

  		this.set(

  			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
  			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
  			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeScale( x, y, z ) {

  		this.set(

  			x, 0, 0, 0,
  			0, y, 0, 0,
  			0, 0, z, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	makeShear( xy, xz, yx, yz, zx, zy ) {

  		this.set(

  			1, yx, zx, 0,
  			xy, 1, zy, 0,
  			xz, yz, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	compose( position, quaternion, scale ) {

  		const te = this.elements;

  		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
  		const x2 = x + x,	y2 = y + y, z2 = z + z;
  		const xx = x * x2, xy = x * y2, xz = x * z2;
  		const yy = y * y2, yz = y * z2, zz = z * z2;
  		const wx = w * x2, wy = w * y2, wz = w * z2;

  		const sx = scale.x, sy = scale.y, sz = scale.z;

  		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
  		te[ 1 ] = ( xy + wz ) * sx;
  		te[ 2 ] = ( xz - wy ) * sx;
  		te[ 3 ] = 0;

  		te[ 4 ] = ( xy - wz ) * sy;
  		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
  		te[ 6 ] = ( yz + wx ) * sy;
  		te[ 7 ] = 0;

  		te[ 8 ] = ( xz + wy ) * sz;
  		te[ 9 ] = ( yz - wx ) * sz;
  		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
  		te[ 11 ] = 0;

  		te[ 12 ] = position.x;
  		te[ 13 ] = position.y;
  		te[ 14 ] = position.z;
  		te[ 15 ] = 1;

  		return this;

  	}

  	decompose( position, quaternion, scale ) {

  		const te = this.elements;

  		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
  		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
  		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

  		// if determine is negative, we need to invert one scale
  		const det = this.determinant();
  		if ( det < 0 ) sx = - sx;

  		position.x = te[ 12 ];
  		position.y = te[ 13 ];
  		position.z = te[ 14 ];

  		// scale the rotation part
  		_m1$2.copy( this );

  		const invSX = 1 / sx;
  		const invSY = 1 / sy;
  		const invSZ = 1 / sz;

  		_m1$2.elements[ 0 ] *= invSX;
  		_m1$2.elements[ 1 ] *= invSX;
  		_m1$2.elements[ 2 ] *= invSX;

  		_m1$2.elements[ 4 ] *= invSY;
  		_m1$2.elements[ 5 ] *= invSY;
  		_m1$2.elements[ 6 ] *= invSY;

  		_m1$2.elements[ 8 ] *= invSZ;
  		_m1$2.elements[ 9 ] *= invSZ;
  		_m1$2.elements[ 10 ] *= invSZ;

  		quaternion.setFromRotationMatrix( _m1$2 );

  		scale.x = sx;
  		scale.y = sy;
  		scale.z = sz;

  		return this;

  	}

  	makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

  		const te = this.elements;
  		const x = 2 * near / ( right - left );
  		const y = 2 * near / ( top - bottom );

  		const a = ( right + left ) / ( right - left );
  		const b = ( top + bottom ) / ( top - bottom );

  		let c, d;

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			c = - ( far + near ) / ( far - near );
  			d = ( - 2 * far * near ) / ( far - near );

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			c = - far / ( far - near );
  			d = ( - far * near ) / ( far - near );

  		} else {

  			throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
  		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

  		return this;

  	}

  	makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

  		const te = this.elements;
  		const w = 1.0 / ( right - left );
  		const h = 1.0 / ( top - bottom );
  		const p = 1.0 / ( far - near );

  		const x = ( right + left ) * w;
  		const y = ( top + bottom ) * h;

  		let z, zInv;

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			z = ( far + near ) * p;
  			zInv = - 2 * p;

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			z = near * p;
  			zInv = - 1 * p;

  		} else {

  			throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		te[ 0 ] = 2 * w;	te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = - x;
  		te[ 1 ] = 0; 		te[ 5 ] = 2 * h;	te[ 9 ] = 0; 		te[ 13 ] = - y;
  		te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = zInv;	te[ 14 ] = - z;
  		te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

  		return this;

  	}

  	equals( matrix ) {

  		const te = this.elements;
  		const me = matrix.elements;

  		for ( let i = 0; i < 16; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	}

  	fromArray( array, offset = 0 ) {

  		for ( let i = 0; i < 16; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		const te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];
  		array[ offset + 3 ] = te[ 3 ];

  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];
  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];

  		array[ offset + 8 ] = te[ 8 ];
  		array[ offset + 9 ] = te[ 9 ];
  		array[ offset + 10 ] = te[ 10 ];
  		array[ offset + 11 ] = te[ 11 ];

  		array[ offset + 12 ] = te[ 12 ];
  		array[ offset + 13 ] = te[ 13 ];
  		array[ offset + 14 ] = te[ 14 ];
  		array[ offset + 15 ] = te[ 15 ];

  		return array;

  	}

  }

  const _v1$5 = /*@__PURE__*/ new Vector3();
  const _m1$2 = /*@__PURE__*/ new Matrix4();
  const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
  const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
  const _x = /*@__PURE__*/ new Vector3();
  const _y = /*@__PURE__*/ new Vector3();
  const _z = /*@__PURE__*/ new Vector3();

  const _matrix$2 = /*@__PURE__*/ new Matrix4();
  const _quaternion$3 = /*@__PURE__*/ new Quaternion();

  class Euler {

  	constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

  		this.isEuler = true;

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order;

  	}

  	get x() {

  		return this._x;

  	}

  	set x( value ) {

  		this._x = value;
  		this._onChangeCallback();

  	}

  	get y() {

  		return this._y;

  	}

  	set y( value ) {

  		this._y = value;
  		this._onChangeCallback();

  	}

  	get z() {

  		return this._z;

  	}

  	set z( value ) {

  		this._z = value;
  		this._onChangeCallback();

  	}

  	get order() {

  		return this._order;

  	}

  	set order( value ) {

  		this._order = value;
  		this._onChangeCallback();

  	}

  	set( x, y, z, order = this._order ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order;

  		this._onChangeCallback();

  		return this;

  	}

  	clone() {

  		return new this.constructor( this._x, this._y, this._z, this._order );

  	}

  	copy( euler ) {

  		this._x = euler._x;
  		this._y = euler._y;
  		this._z = euler._z;
  		this._order = euler._order;

  		this._onChangeCallback();

  		return this;

  	}

  	setFromRotationMatrix( m, order = this._order, update = true ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		const te = m.elements;
  		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
  		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
  		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		switch ( order ) {

  			case 'XYZ':

  				this._y = Math.asin( clamp$1( m13, - 1, 1 ) );

  				if ( Math.abs( m13 ) < 0.9999999 ) {

  					this._x = Math.atan2( - m23, m33 );
  					this._z = Math.atan2( - m12, m11 );

  				} else {

  					this._x = Math.atan2( m32, m22 );
  					this._z = 0;

  				}

  				break;

  			case 'YXZ':

  				this._x = Math.asin( - clamp$1( m23, - 1, 1 ) );

  				if ( Math.abs( m23 ) < 0.9999999 ) {

  					this._y = Math.atan2( m13, m33 );
  					this._z = Math.atan2( m21, m22 );

  				} else {

  					this._y = Math.atan2( - m31, m11 );
  					this._z = 0;

  				}

  				break;

  			case 'ZXY':

  				this._x = Math.asin( clamp$1( m32, - 1, 1 ) );

  				if ( Math.abs( m32 ) < 0.9999999 ) {

  					this._y = Math.atan2( - m31, m33 );
  					this._z = Math.atan2( - m12, m22 );

  				} else {

  					this._y = 0;
  					this._z = Math.atan2( m21, m11 );

  				}

  				break;

  			case 'ZYX':

  				this._y = Math.asin( - clamp$1( m31, - 1, 1 ) );

  				if ( Math.abs( m31 ) < 0.9999999 ) {

  					this._x = Math.atan2( m32, m33 );
  					this._z = Math.atan2( m21, m11 );

  				} else {

  					this._x = 0;
  					this._z = Math.atan2( - m12, m22 );

  				}

  				break;

  			case 'YZX':

  				this._z = Math.asin( clamp$1( m21, - 1, 1 ) );

  				if ( Math.abs( m21 ) < 0.9999999 ) {

  					this._x = Math.atan2( - m23, m22 );
  					this._y = Math.atan2( - m31, m11 );

  				} else {

  					this._x = 0;
  					this._y = Math.atan2( m13, m33 );

  				}

  				break;

  			case 'XZY':

  				this._z = Math.asin( - clamp$1( m12, - 1, 1 ) );

  				if ( Math.abs( m12 ) < 0.9999999 ) {

  					this._x = Math.atan2( m32, m22 );
  					this._y = Math.atan2( m13, m11 );

  				} else {

  					this._x = Math.atan2( - m23, m33 );
  					this._y = 0;

  				}

  				break;

  			default:

  				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

  		}

  		this._order = order;

  		if ( update === true ) this._onChangeCallback();

  		return this;

  	}

  	setFromQuaternion( q, order, update ) {

  		_matrix$2.makeRotationFromQuaternion( q );

  		return this.setFromRotationMatrix( _matrix$2, order, update );

  	}

  	setFromVector3( v, order = this._order ) {

  		return this.set( v.x, v.y, v.z, order );

  	}

  	reorder( newOrder ) {

  		// WARNING: this discards revolution information -bhouston

  		_quaternion$3.setFromEuler( this );

  		return this.setFromQuaternion( _quaternion$3, newOrder );

  	}

  	equals( euler ) {

  		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  	}

  	fromArray( array ) {

  		this._x = array[ 0 ];
  		this._y = array[ 1 ];
  		this._z = array[ 2 ];
  		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

  		this._onChangeCallback();

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._order;

  		return array;

  	}

  	_onChange( callback ) {

  		this._onChangeCallback = callback;

  		return this;

  	}

  	_onChangeCallback() {}

  	*[ Symbol.iterator ]() {

  		yield this._x;
  		yield this._y;
  		yield this._z;
  		yield this._order;

  	}

  }

  Euler.DEFAULT_ORDER = 'XYZ';

  class Layers {

  	constructor() {

  		this.mask = 1 | 0;

  	}

  	set( channel ) {

  		this.mask = ( 1 << channel | 0 ) >>> 0;

  	}

  	enable( channel ) {

  		this.mask |= 1 << channel | 0;

  	}

  	enableAll() {

  		this.mask = 0xffffffff | 0;

  	}

  	toggle( channel ) {

  		this.mask ^= 1 << channel | 0;

  	}

  	disable( channel ) {

  		this.mask &= ~ ( 1 << channel | 0 );

  	}

  	disableAll() {

  		this.mask = 0;

  	}

  	test( layers ) {

  		return ( this.mask & layers.mask ) !== 0;

  	}

  	isEnabled( channel ) {

  		return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

  	}

  }

  let _object3DId = 0;

  const _v1$4 = /*@__PURE__*/ new Vector3();
  const _q1 = /*@__PURE__*/ new Quaternion();
  const _m1$1 = /*@__PURE__*/ new Matrix4();
  const _target$1 = /*@__PURE__*/ new Vector3();

  const _position$3 = /*@__PURE__*/ new Vector3();
  const _scale$2 = /*@__PURE__*/ new Vector3();
  const _quaternion$2 = /*@__PURE__*/ new Quaternion();

  const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
  const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
  const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

  const _addedEvent = { type: 'added' };
  const _removedEvent = { type: 'removed' };

  const _childaddedEvent = { type: 'childadded', child: null };
  const _childremovedEvent = { type: 'childremoved', child: null };

  class Object3D extends EventDispatcher {

  	constructor() {

  		super();

  		this.isObject3D = true;

  		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

  		this.uuid = generateUUID();

  		this.name = '';
  		this.type = 'Object3D';

  		this.parent = null;
  		this.children = [];

  		this.up = Object3D.DEFAULT_UP.clone();

  		const position = new Vector3();
  		const rotation = new Euler();
  		const quaternion = new Quaternion();
  		const scale = new Vector3( 1, 1, 1 );

  		function onRotationChange() {

  			quaternion.setFromEuler( rotation, false );

  		}

  		function onQuaternionChange() {

  			rotation.setFromQuaternion( quaternion, undefined, false );

  		}

  		rotation._onChange( onRotationChange );
  		quaternion._onChange( onQuaternionChange );

  		Object.defineProperties( this, {
  			position: {
  				configurable: true,
  				enumerable: true,
  				value: position
  			},
  			rotation: {
  				configurable: true,
  				enumerable: true,
  				value: rotation
  			},
  			quaternion: {
  				configurable: true,
  				enumerable: true,
  				value: quaternion
  			},
  			scale: {
  				configurable: true,
  				enumerable: true,
  				value: scale
  			},
  			modelViewMatrix: {
  				value: new Matrix4()
  			},
  			normalMatrix: {
  				value: new Matrix3()
  			}
  		} );

  		this.matrix = new Matrix4();
  		this.matrixWorld = new Matrix4();

  		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

  		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
  		this.matrixWorldNeedsUpdate = false;

  		this.layers = new Layers();
  		this.visible = true;

  		this.castShadow = false;
  		this.receiveShadow = false;

  		this.frustumCulled = true;
  		this.renderOrder = 0;

  		this.animations = [];

  		this.userData = {};

  	}

  	onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

  	onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

  	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

  	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

  	applyMatrix4( matrix ) {

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		this.matrix.premultiply( matrix );

  		this.matrix.decompose( this.position, this.quaternion, this.scale );

  	}

  	applyQuaternion( q ) {

  		this.quaternion.premultiply( q );

  		return this;

  	}

  	setRotationFromAxisAngle( axis, angle ) {

  		// assumes axis is normalized

  		this.quaternion.setFromAxisAngle( axis, angle );

  	}

  	setRotationFromEuler( euler ) {

  		this.quaternion.setFromEuler( euler, true );

  	}

  	setRotationFromMatrix( m ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		this.quaternion.setFromRotationMatrix( m );

  	}

  	setRotationFromQuaternion( q ) {

  		// assumes q is normalized

  		this.quaternion.copy( q );

  	}

  	rotateOnAxis( axis, angle ) {

  		// rotate object on axis in object space
  		// axis is assumed to be normalized

  		_q1.setFromAxisAngle( axis, angle );

  		this.quaternion.multiply( _q1 );

  		return this;

  	}

  	rotateOnWorldAxis( axis, angle ) {

  		// rotate object on axis in world space
  		// axis is assumed to be normalized
  		// method assumes no rotated parent

  		_q1.setFromAxisAngle( axis, angle );

  		this.quaternion.premultiply( _q1 );

  		return this;

  	}

  	rotateX( angle ) {

  		return this.rotateOnAxis( _xAxis, angle );

  	}

  	rotateY( angle ) {

  		return this.rotateOnAxis( _yAxis, angle );

  	}

  	rotateZ( angle ) {

  		return this.rotateOnAxis( _zAxis, angle );

  	}

  	translateOnAxis( axis, distance ) {

  		// translate object by distance along axis in object space
  		// axis is assumed to be normalized

  		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

  		this.position.add( _v1$4.multiplyScalar( distance ) );

  		return this;

  	}

  	translateX( distance ) {

  		return this.translateOnAxis( _xAxis, distance );

  	}

  	translateY( distance ) {

  		return this.translateOnAxis( _yAxis, distance );

  	}

  	translateZ( distance ) {

  		return this.translateOnAxis( _zAxis, distance );

  	}

  	localToWorld( vector ) {

  		this.updateWorldMatrix( true, false );

  		return vector.applyMatrix4( this.matrixWorld );

  	}

  	worldToLocal( vector ) {

  		this.updateWorldMatrix( true, false );

  		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

  	}

  	lookAt( x, y, z ) {

  		// This method does not support objects having non-uniformly-scaled parent(s)

  		if ( x.isVector3 ) {

  			_target$1.copy( x );

  		} else {

  			_target$1.set( x, y, z );

  		}

  		const parent = this.parent;

  		this.updateWorldMatrix( true, false );

  		_position$3.setFromMatrixPosition( this.matrixWorld );

  		if ( this.isCamera || this.isLight ) {

  			_m1$1.lookAt( _position$3, _target$1, this.up );

  		} else {

  			_m1$1.lookAt( _target$1, _position$3, this.up );

  		}

  		this.quaternion.setFromRotationMatrix( _m1$1 );

  		if ( parent ) {

  			_m1$1.extractRotation( parent.matrixWorld );
  			_q1.setFromRotationMatrix( _m1$1 );
  			this.quaternion.premultiply( _q1.invert() );

  		}

  	}

  	add( object ) {

  		if ( arguments.length > 1 ) {

  			for ( let i = 0; i < arguments.length; i ++ ) {

  				this.add( arguments[ i ] );

  			}

  			return this;

  		}

  		if ( object === this ) {

  			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
  			return this;

  		}

  		if ( object && object.isObject3D ) {

  			object.removeFromParent();
  			object.parent = this;
  			this.children.push( object );

  			object.dispatchEvent( _addedEvent );

  			_childaddedEvent.child = object;
  			this.dispatchEvent( _childaddedEvent );
  			_childaddedEvent.child = null;

  		} else {

  			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

  		}

  		return this;

  	}

  	remove( object ) {

  		if ( arguments.length > 1 ) {

  			for ( let i = 0; i < arguments.length; i ++ ) {

  				this.remove( arguments[ i ] );

  			}

  			return this;

  		}

  		const index = this.children.indexOf( object );

  		if ( index !== - 1 ) {

  			object.parent = null;
  			this.children.splice( index, 1 );

  			object.dispatchEvent( _removedEvent );

  			_childremovedEvent.child = object;
  			this.dispatchEvent( _childremovedEvent );
  			_childremovedEvent.child = null;

  		}

  		return this;

  	}

  	removeFromParent() {

  		const parent = this.parent;

  		if ( parent !== null ) {

  			parent.remove( this );

  		}

  		return this;

  	}

  	clear() {

  		return this.remove( ... this.children );

  	}

  	attach( object ) {

  		// adds object as a child of this, while maintaining the object's world transform

  		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

  		this.updateWorldMatrix( true, false );

  		_m1$1.copy( this.matrixWorld ).invert();

  		if ( object.parent !== null ) {

  			object.parent.updateWorldMatrix( true, false );

  			_m1$1.multiply( object.parent.matrixWorld );

  		}

  		object.applyMatrix4( _m1$1 );

  		object.removeFromParent();
  		object.parent = this;
  		this.children.push( object );

  		object.updateWorldMatrix( false, true );

  		object.dispatchEvent( _addedEvent );

  		_childaddedEvent.child = object;
  		this.dispatchEvent( _childaddedEvent );
  		_childaddedEvent.child = null;

  		return this;

  	}

  	getObjectById( id ) {

  		return this.getObjectByProperty( 'id', id );

  	}

  	getObjectByName( name ) {

  		return this.getObjectByProperty( 'name', name );

  	}

  	getObjectByProperty( name, value ) {

  		if ( this[ name ] === value ) return this;

  		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

  			const child = this.children[ i ];
  			const object = child.getObjectByProperty( name, value );

  			if ( object !== undefined ) {

  				return object;

  			}

  		}

  		return undefined;

  	}

  	getObjectsByProperty( name, value, result = [] ) {

  		if ( this[ name ] === value ) result.push( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].getObjectsByProperty( name, value, result );

  		}

  		return result;

  	}

  	getWorldPosition( target ) {

  		this.updateWorldMatrix( true, false );

  		return target.setFromMatrixPosition( this.matrixWorld );

  	}

  	getWorldQuaternion( target ) {

  		this.updateWorldMatrix( true, false );

  		this.matrixWorld.decompose( _position$3, target, _scale$2 );

  		return target;

  	}

  	getWorldScale( target ) {

  		this.updateWorldMatrix( true, false );

  		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

  		return target;

  	}

  	getWorldDirection( target ) {

  		this.updateWorldMatrix( true, false );

  		const e = this.matrixWorld.elements;

  		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

  	}

  	raycast( /* raycaster, intersects */ ) {}

  	traverse( callback ) {

  		callback( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverse( callback );

  		}

  	}

  	traverseVisible( callback ) {

  		if ( this.visible === false ) return;

  		callback( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverseVisible( callback );

  		}

  	}

  	traverseAncestors( callback ) {

  		const parent = this.parent;

  		if ( parent !== null ) {

  			callback( parent );

  			parent.traverseAncestors( callback );

  		}

  	}

  	updateMatrix() {

  		this.matrix.compose( this.position, this.quaternion, this.scale );

  		this.matrixWorldNeedsUpdate = true;

  	}

  	updateMatrixWorld( force ) {

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		if ( this.matrixWorldNeedsUpdate || force ) {

  			if ( this.matrixWorldAutoUpdate === true ) {

  				if ( this.parent === null ) {

  					this.matrixWorld.copy( this.matrix );

  				} else {

  					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  				}

  			}

  			this.matrixWorldNeedsUpdate = false;

  			force = true;

  		}

  		// make sure descendants are updated if required

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			const child = children[ i ];

  			child.updateMatrixWorld( force );

  		}

  	}

  	updateWorldMatrix( updateParents, updateChildren ) {

  		const parent = this.parent;

  		if ( updateParents === true && parent !== null ) {

  			parent.updateWorldMatrix( true, false );

  		}

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		if ( this.matrixWorldAutoUpdate === true ) {

  			if ( this.parent === null ) {

  				this.matrixWorld.copy( this.matrix );

  			} else {

  				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  			}

  		}

  		// make sure descendants are updated

  		if ( updateChildren === true ) {

  			const children = this.children;

  			for ( let i = 0, l = children.length; i < l; i ++ ) {

  				const child = children[ i ];

  				child.updateWorldMatrix( false, true );

  			}

  		}

  	}

  	toJSON( meta ) {

  		// meta is a string when called from JSON.stringify
  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		const output = {};

  		// meta is a hash used to collect geometries, materials.
  		// not providing it implies that this is the root object
  		// being serialized.
  		if ( isRootObject ) {

  			// initialize meta obj
  			meta = {
  				geometries: {},
  				materials: {},
  				textures: {},
  				images: {},
  				shapes: {},
  				skeletons: {},
  				animations: {},
  				nodes: {}
  			};

  			output.metadata = {
  				version: 4.6,
  				type: 'Object',
  				generator: 'Object3D.toJSON'
  			};

  		}

  		// standard Object3D serialization

  		const object = {};

  		object.uuid = this.uuid;
  		object.type = this.type;

  		if ( this.name !== '' ) object.name = this.name;
  		if ( this.castShadow === true ) object.castShadow = true;
  		if ( this.receiveShadow === true ) object.receiveShadow = true;
  		if ( this.visible === false ) object.visible = false;
  		if ( this.frustumCulled === false ) object.frustumCulled = false;
  		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
  		if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

  		object.layers = this.layers.mask;
  		object.matrix = this.matrix.toArray();
  		object.up = this.up.toArray();

  		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

  		// object specific properties

  		if ( this.isInstancedMesh ) {

  			object.type = 'InstancedMesh';
  			object.count = this.count;
  			object.instanceMatrix = this.instanceMatrix.toJSON();
  			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

  		}

  		if ( this.isBatchedMesh ) {

  			object.type = 'BatchedMesh';
  			object.perObjectFrustumCulled = this.perObjectFrustumCulled;
  			object.sortObjects = this.sortObjects;

  			object.drawRanges = this._drawRanges;
  			object.reservedRanges = this._reservedRanges;

  			object.visibility = this._visibility;
  			object.active = this._active;
  			object.bounds = this._bounds.map( bound => ( {
  				boxInitialized: bound.boxInitialized,
  				boxMin: bound.box.min.toArray(),
  				boxMax: bound.box.max.toArray(),

  				sphereInitialized: bound.sphereInitialized,
  				sphereRadius: bound.sphere.radius,
  				sphereCenter: bound.sphere.center.toArray()
  			} ) );

  			object.maxInstanceCount = this._maxInstanceCount;
  			object.maxVertexCount = this._maxVertexCount;
  			object.maxIndexCount = this._maxIndexCount;

  			object.geometryInitialized = this._geometryInitialized;
  			object.geometryCount = this._geometryCount;

  			object.matricesTexture = this._matricesTexture.toJSON( meta );

  			if ( this._colorsTexture !== null ) object.colorsTexture = this._colorsTexture.toJSON( meta );

  			if ( this.boundingSphere !== null ) {

  				object.boundingSphere = {
  					center: object.boundingSphere.center.toArray(),
  					radius: object.boundingSphere.radius
  				};

  			}

  			if ( this.boundingBox !== null ) {

  				object.boundingBox = {
  					min: object.boundingBox.min.toArray(),
  					max: object.boundingBox.max.toArray()
  				};

  			}

  		}

  		//

  		function serialize( library, element ) {

  			if ( library[ element.uuid ] === undefined ) {

  				library[ element.uuid ] = element.toJSON( meta );

  			}

  			return element.uuid;

  		}

  		if ( this.isScene ) {

  			if ( this.background ) {

  				if ( this.background.isColor ) {

  					object.background = this.background.toJSON();

  				} else if ( this.background.isTexture ) {

  					object.background = this.background.toJSON( meta ).uuid;

  				}

  			}

  			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

  				object.environment = this.environment.toJSON( meta ).uuid;

  			}

  		} else if ( this.isMesh || this.isLine || this.isPoints ) {

  			object.geometry = serialize( meta.geometries, this.geometry );

  			const parameters = this.geometry.parameters;

  			if ( parameters !== undefined && parameters.shapes !== undefined ) {

  				const shapes = parameters.shapes;

  				if ( Array.isArray( shapes ) ) {

  					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

  						const shape = shapes[ i ];

  						serialize( meta.shapes, shape );

  					}

  				} else {

  					serialize( meta.shapes, shapes );

  				}

  			}

  		}

  		if ( this.isSkinnedMesh ) {

  			object.bindMode = this.bindMode;
  			object.bindMatrix = this.bindMatrix.toArray();

  			if ( this.skeleton !== undefined ) {

  				serialize( meta.skeletons, this.skeleton );

  				object.skeleton = this.skeleton.uuid;

  			}

  		}

  		if ( this.material !== undefined ) {

  			if ( Array.isArray( this.material ) ) {

  				const uuids = [];

  				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

  					uuids.push( serialize( meta.materials, this.material[ i ] ) );

  				}

  				object.material = uuids;

  			} else {

  				object.material = serialize( meta.materials, this.material );

  			}

  		}

  		//

  		if ( this.children.length > 0 ) {

  			object.children = [];

  			for ( let i = 0; i < this.children.length; i ++ ) {

  				object.children.push( this.children[ i ].toJSON( meta ).object );

  			}

  		}

  		//

  		if ( this.animations.length > 0 ) {

  			object.animations = [];

  			for ( let i = 0; i < this.animations.length; i ++ ) {

  				const animation = this.animations[ i ];

  				object.animations.push( serialize( meta.animations, animation ) );

  			}

  		}

  		if ( isRootObject ) {

  			const geometries = extractFromCache( meta.geometries );
  			const materials = extractFromCache( meta.materials );
  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );
  			const shapes = extractFromCache( meta.shapes );
  			const skeletons = extractFromCache( meta.skeletons );
  			const animations = extractFromCache( meta.animations );
  			const nodes = extractFromCache( meta.nodes );

  			if ( geometries.length > 0 ) output.geometries = geometries;
  			if ( materials.length > 0 ) output.materials = materials;
  			if ( textures.length > 0 ) output.textures = textures;
  			if ( images.length > 0 ) output.images = images;
  			if ( shapes.length > 0 ) output.shapes = shapes;
  			if ( skeletons.length > 0 ) output.skeletons = skeletons;
  			if ( animations.length > 0 ) output.animations = animations;
  			if ( nodes.length > 0 ) output.nodes = nodes;

  		}

  		output.object = object;

  		return output;

  		// extract data from the cache hash
  		// remove metadata on each item
  		// and return as array
  		function extractFromCache( cache ) {

  			const values = [];
  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  	}

  	clone( recursive ) {

  		return new this.constructor().copy( this, recursive );

  	}

  	copy( source, recursive = true ) {

  		this.name = source.name;

  		this.up.copy( source.up );

  		this.position.copy( source.position );
  		this.rotation.order = source.rotation.order;
  		this.quaternion.copy( source.quaternion );
  		this.scale.copy( source.scale );

  		this.matrix.copy( source.matrix );
  		this.matrixWorld.copy( source.matrixWorld );

  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
  		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

  		this.layers.mask = source.layers.mask;
  		this.visible = source.visible;

  		this.castShadow = source.castShadow;
  		this.receiveShadow = source.receiveShadow;

  		this.frustumCulled = source.frustumCulled;
  		this.renderOrder = source.renderOrder;

  		this.animations = source.animations.slice();

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		if ( recursive === true ) {

  			for ( let i = 0; i < source.children.length; i ++ ) {

  				const child = source.children[ i ];
  				this.add( child.clone() );

  			}

  		}

  		return this;

  	}

  }

  Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );
  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

  const _v0$1 = /*@__PURE__*/ new Vector3();
  const _v1$3 = /*@__PURE__*/ new Vector3();
  const _v2$2 = /*@__PURE__*/ new Vector3();
  const _v3$2 = /*@__PURE__*/ new Vector3();

  const _vab = /*@__PURE__*/ new Vector3();
  const _vac = /*@__PURE__*/ new Vector3();
  const _vbc = /*@__PURE__*/ new Vector3();
  const _vap = /*@__PURE__*/ new Vector3();
  const _vbp = /*@__PURE__*/ new Vector3();
  const _vcp = /*@__PURE__*/ new Vector3();

  const _v40 = /*@__PURE__*/ new Vector4();
  const _v41 = /*@__PURE__*/ new Vector4();
  const _v42 = /*@__PURE__*/ new Vector4();

  class Triangle {

  	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

  		this.a = a;
  		this.b = b;
  		this.c = c;

  	}

  	static getNormal( a, b, c, target ) {

  		target.subVectors( c, b );
  		_v0$1.subVectors( a, b );
  		target.cross( _v0$1 );

  		const targetLengthSq = target.lengthSq();
  		if ( targetLengthSq > 0 ) {

  			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

  		}

  		return target.set( 0, 0, 0 );

  	}

  	// static/instance method to calculate barycentric coordinates
  	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  	static getBarycoord( point, a, b, c, target ) {

  		_v0$1.subVectors( c, a );
  		_v1$3.subVectors( b, a );
  		_v2$2.subVectors( point, a );

  		const dot00 = _v0$1.dot( _v0$1 );
  		const dot01 = _v0$1.dot( _v1$3 );
  		const dot02 = _v0$1.dot( _v2$2 );
  		const dot11 = _v1$3.dot( _v1$3 );
  		const dot12 = _v1$3.dot( _v2$2 );

  		const denom = ( dot00 * dot11 - dot01 * dot01 );

  		// collinear or singular triangle
  		if ( denom === 0 ) {

  			target.set( 0, 0, 0 );
  			return null;

  		}

  		const invDenom = 1 / denom;
  		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
  		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

  		// barycentric coordinates must always sum to 1
  		return target.set( 1 - u - v, v, u );

  	}

  	static containsPoint( point, a, b, c ) {

  		// if the triangle is degenerate then we can't contain a point
  		if ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {

  			return false;

  		}

  		return ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );

  	}

  	static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

  		if ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {

  			target.x = 0;
  			target.y = 0;
  			if ( 'z' in target ) target.z = 0;
  			if ( 'w' in target ) target.w = 0;
  			return null;

  		}

  		target.setScalar( 0 );
  		target.addScaledVector( v1, _v3$2.x );
  		target.addScaledVector( v2, _v3$2.y );
  		target.addScaledVector( v3, _v3$2.z );

  		return target;

  	}

  	static getInterpolatedAttribute( attr, i1, i2, i3, barycoord, target ) {

  		_v40.setScalar( 0 );
  		_v41.setScalar( 0 );
  		_v42.setScalar( 0 );

  		_v40.fromBufferAttribute( attr, i1 );
  		_v41.fromBufferAttribute( attr, i2 );
  		_v42.fromBufferAttribute( attr, i3 );

  		target.setScalar( 0 );
  		target.addScaledVector( _v40, barycoord.x );
  		target.addScaledVector( _v41, barycoord.y );
  		target.addScaledVector( _v42, barycoord.z );

  		return target;

  	}

  	static isFrontFacing( a, b, c, direction ) {

  		_v0$1.subVectors( c, b );
  		_v1$3.subVectors( a, b );

  		// strictly front facing
  		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

  	}

  	set( a, b, c ) {

  		this.a.copy( a );
  		this.b.copy( b );
  		this.c.copy( c );

  		return this;

  	}

  	setFromPointsAndIndices( points, i0, i1, i2 ) {

  		this.a.copy( points[ i0 ] );
  		this.b.copy( points[ i1 ] );
  		this.c.copy( points[ i2 ] );

  		return this;

  	}

  	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

  		this.a.fromBufferAttribute( attribute, i0 );
  		this.b.fromBufferAttribute( attribute, i1 );
  		this.c.fromBufferAttribute( attribute, i2 );

  		return this;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( triangle ) {

  		this.a.copy( triangle.a );
  		this.b.copy( triangle.b );
  		this.c.copy( triangle.c );

  		return this;

  	}

  	getArea() {

  		_v0$1.subVectors( this.c, this.b );
  		_v1$3.subVectors( this.a, this.b );

  		return _v0$1.cross( _v1$3 ).length() * 0.5;

  	}

  	getMidpoint( target ) {

  		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  	}

  	getNormal( target ) {

  		return Triangle.getNormal( this.a, this.b, this.c, target );

  	}

  	getPlane( target ) {

  		return target.setFromCoplanarPoints( this.a, this.b, this.c );

  	}

  	getBarycoord( point, target ) {

  		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

  	}

  	getInterpolation( point, v1, v2, v3, target ) {

  		return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

  	}

  	containsPoint( point ) {

  		return Triangle.containsPoint( point, this.a, this.b, this.c );

  	}

  	isFrontFacing( direction ) {

  		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

  	}

  	intersectsBox( box ) {

  		return box.intersectsTriangle( this );

  	}

  	closestPointToPoint( p, target ) {

  		const a = this.a, b = this.b, c = this.c;
  		let v, w;

  		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
  		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
  		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
  		// basically, we're distinguishing which of the voronoi regions of the triangle
  		// the point lies in with the minimum amount of redundant computation.

  		_vab.subVectors( b, a );
  		_vac.subVectors( c, a );
  		_vap.subVectors( p, a );
  		const d1 = _vab.dot( _vap );
  		const d2 = _vac.dot( _vap );
  		if ( d1 <= 0 && d2 <= 0 ) {

  			// vertex region of A; barycentric coords (1, 0, 0)
  			return target.copy( a );

  		}

  		_vbp.subVectors( p, b );
  		const d3 = _vab.dot( _vbp );
  		const d4 = _vac.dot( _vbp );
  		if ( d3 >= 0 && d4 <= d3 ) {

  			// vertex region of B; barycentric coords (0, 1, 0)
  			return target.copy( b );

  		}

  		const vc = d1 * d4 - d3 * d2;
  		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

  			v = d1 / ( d1 - d3 );
  			// edge region of AB; barycentric coords (1-v, v, 0)
  			return target.copy( a ).addScaledVector( _vab, v );

  		}

  		_vcp.subVectors( p, c );
  		const d5 = _vab.dot( _vcp );
  		const d6 = _vac.dot( _vcp );
  		if ( d6 >= 0 && d5 <= d6 ) {

  			// vertex region of C; barycentric coords (0, 0, 1)
  			return target.copy( c );

  		}

  		const vb = d5 * d2 - d1 * d6;
  		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

  			w = d2 / ( d2 - d6 );
  			// edge region of AC; barycentric coords (1-w, 0, w)
  			return target.copy( a ).addScaledVector( _vac, w );

  		}

  		const va = d3 * d6 - d5 * d4;
  		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

  			_vbc.subVectors( c, b );
  			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
  			// edge region of BC; barycentric coords (0, 1-w, w)
  			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

  		}

  		// face region
  		const denom = 1 / ( va + vb + vc );
  		// u = va * denom
  		v = vb * denom;
  		w = vc * denom;

  		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

  	}

  	equals( triangle ) {

  		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  	}

  }

  const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
  	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
  	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
  	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
  	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
  	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
  	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
  	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
  	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
  	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
  	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
  	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
  	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
  	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
  	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
  	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
  	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
  	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
  	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
  	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
  	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
  	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
  	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
  	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

  const _hslA = { h: 0, s: 0, l: 0 };
  const _hslB = { h: 0, s: 0, l: 0 };

  function hue2rgb( p, q, t ) {

  	if ( t < 0 ) t += 1;
  	if ( t > 1 ) t -= 1;
  	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
  	if ( t < 1 / 2 ) return q;
  	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
  	return p;

  }

  class Color {

  	constructor( r, g, b ) {

  		this.isColor = true;

  		this.r = 1;
  		this.g = 1;
  		this.b = 1;

  		return this.set( r, g, b );

  	}

  	set( r, g, b ) {

  		if ( g === undefined && b === undefined ) {

  			// r is THREE.Color, hex or string

  			const value = r;

  			if ( value && value.isColor ) {

  				this.copy( value );

  			} else if ( typeof value === 'number' ) {

  				this.setHex( value );

  			} else if ( typeof value === 'string' ) {

  				this.setStyle( value );

  			}

  		} else {

  			this.setRGB( r, g, b );

  		}

  		return this;

  	}

  	setScalar( scalar ) {

  		this.r = scalar;
  		this.g = scalar;
  		this.b = scalar;

  		return this;

  	}

  	setHex( hex, colorSpace = SRGBColorSpace ) {

  		hex = Math.floor( hex );

  		this.r = ( hex >> 16 & 255 ) / 255;
  		this.g = ( hex >> 8 & 255 ) / 255;
  		this.b = ( hex & 255 ) / 255;

  		ColorManagement.toWorkingColorSpace( this, colorSpace );

  		return this;

  	}

  	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

  		this.r = r;
  		this.g = g;
  		this.b = b;

  		ColorManagement.toWorkingColorSpace( this, colorSpace );

  		return this;

  	}

  	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

  		// h,s,l ranges are in 0.0 - 1.0
  		h = euclideanModulo( h, 1 );
  		s = clamp$1( s, 0, 1 );
  		l = clamp$1( l, 0, 1 );

  		if ( s === 0 ) {

  			this.r = this.g = this.b = l;

  		} else {

  			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
  			const q = ( 2 * l ) - p;

  			this.r = hue2rgb( q, p, h + 1 / 3 );
  			this.g = hue2rgb( q, p, h );
  			this.b = hue2rgb( q, p, h - 1 / 3 );

  		}

  		ColorManagement.toWorkingColorSpace( this, colorSpace );

  		return this;

  	}

  	setStyle( style, colorSpace = SRGBColorSpace ) {

  		function handleAlpha( string ) {

  			if ( string === undefined ) return;

  			if ( parseFloat( string ) < 1 ) {

  				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

  			}

  		}


  		let m;

  		if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

  			// rgb / hsl

  			let color;
  			const name = m[ 1 ];
  			const components = m[ 2 ];

  			switch ( name ) {

  				case 'rgb':
  				case 'rgba':

  					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// rgb(255,0,0) rgba(255,0,0,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setRGB(
  							Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
  							Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
  							Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
  							colorSpace
  						);

  					}

  					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setRGB(
  							Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
  							Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
  							Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
  							colorSpace
  						);

  					}

  					break;

  				case 'hsl':
  				case 'hsla':

  					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setHSL(
  							parseFloat( color[ 1 ] ) / 360,
  							parseFloat( color[ 2 ] ) / 100,
  							parseFloat( color[ 3 ] ) / 100,
  							colorSpace
  						);

  					}

  					break;

  				default:

  					console.warn( 'THREE.Color: Unknown color model ' + style );

  			}

  		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

  			// hex color

  			const hex = m[ 1 ];
  			const size = hex.length;

  			if ( size === 3 ) {

  				// #ff0
  				return this.setRGB(
  					parseInt( hex.charAt( 0 ), 16 ) / 15,
  					parseInt( hex.charAt( 1 ), 16 ) / 15,
  					parseInt( hex.charAt( 2 ), 16 ) / 15,
  					colorSpace
  				);

  			} else if ( size === 6 ) {

  				// #ff0000
  				return this.setHex( parseInt( hex, 16 ), colorSpace );

  			} else {

  				console.warn( 'THREE.Color: Invalid hex color ' + style );

  			}

  		} else if ( style && style.length > 0 ) {

  			return this.setColorName( style, colorSpace );

  		}

  		return this;

  	}

  	setColorName( style, colorSpace = SRGBColorSpace ) {

  		// color keywords
  		const hex = _colorKeywords[ style.toLowerCase() ];

  		if ( hex !== undefined ) {

  			// red
  			this.setHex( hex, colorSpace );

  		} else {

  			// unknown color
  			console.warn( 'THREE.Color: Unknown color ' + style );

  		}

  		return this;

  	}

  	clone() {

  		return new this.constructor( this.r, this.g, this.b );

  	}

  	copy( color ) {

  		this.r = color.r;
  		this.g = color.g;
  		this.b = color.b;

  		return this;

  	}

  	copySRGBToLinear( color ) {

  		this.r = SRGBToLinear( color.r );
  		this.g = SRGBToLinear( color.g );
  		this.b = SRGBToLinear( color.b );

  		return this;

  	}

  	copyLinearToSRGB( color ) {

  		this.r = LinearToSRGB( color.r );
  		this.g = LinearToSRGB( color.g );
  		this.b = LinearToSRGB( color.b );

  		return this;

  	}

  	convertSRGBToLinear() {

  		this.copySRGBToLinear( this );

  		return this;

  	}

  	convertLinearToSRGB() {

  		this.copyLinearToSRGB( this );

  		return this;

  	}

  	getHex( colorSpace = SRGBColorSpace ) {

  		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

  		return Math.round( clamp$1( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp$1( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp$1( _color.b * 255, 0, 255 ) );

  	}

  	getHexString( colorSpace = SRGBColorSpace ) {

  		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

  	}

  	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

  		// h,s,l ranges are in 0.0 - 1.0

  		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

  		const r = _color.r, g = _color.g, b = _color.b;

  		const max = Math.max( r, g, b );
  		const min = Math.min( r, g, b );

  		let hue, saturation;
  		const lightness = ( min + max ) / 2.0;

  		if ( min === max ) {

  			hue = 0;
  			saturation = 0;

  		} else {

  			const delta = max - min;

  			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

  			switch ( max ) {

  				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
  				case g: hue = ( b - r ) / delta + 2; break;
  				case b: hue = ( r - g ) / delta + 4; break;

  			}

  			hue /= 6;

  		}

  		target.h = hue;
  		target.s = saturation;
  		target.l = lightness;

  		return target;

  	}

  	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

  		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

  		target.r = _color.r;
  		target.g = _color.g;
  		target.b = _color.b;

  		return target;

  	}

  	getStyle( colorSpace = SRGBColorSpace ) {

  		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

  		const r = _color.r, g = _color.g, b = _color.b;

  		if ( colorSpace !== SRGBColorSpace ) {

  			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
  			return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

  		}

  		return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

  	}

  	offsetHSL( h, s, l ) {

  		this.getHSL( _hslA );

  		return this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );

  	}

  	add( color ) {

  		this.r += color.r;
  		this.g += color.g;
  		this.b += color.b;

  		return this;

  	}

  	addColors( color1, color2 ) {

  		this.r = color1.r + color2.r;
  		this.g = color1.g + color2.g;
  		this.b = color1.b + color2.b;

  		return this;

  	}

  	addScalar( s ) {

  		this.r += s;
  		this.g += s;
  		this.b += s;

  		return this;

  	}

  	sub( color ) {

  		this.r = Math.max( 0, this.r - color.r );
  		this.g = Math.max( 0, this.g - color.g );
  		this.b = Math.max( 0, this.b - color.b );

  		return this;

  	}

  	multiply( color ) {

  		this.r *= color.r;
  		this.g *= color.g;
  		this.b *= color.b;

  		return this;

  	}

  	multiplyScalar( s ) {

  		this.r *= s;
  		this.g *= s;
  		this.b *= s;

  		return this;

  	}

  	lerp( color, alpha ) {

  		this.r += ( color.r - this.r ) * alpha;
  		this.g += ( color.g - this.g ) * alpha;
  		this.b += ( color.b - this.b ) * alpha;

  		return this;

  	}

  	lerpColors( color1, color2, alpha ) {

  		this.r = color1.r + ( color2.r - color1.r ) * alpha;
  		this.g = color1.g + ( color2.g - color1.g ) * alpha;
  		this.b = color1.b + ( color2.b - color1.b ) * alpha;

  		return this;

  	}

  	lerpHSL( color, alpha ) {

  		this.getHSL( _hslA );
  		color.getHSL( _hslB );

  		const h = lerp( _hslA.h, _hslB.h, alpha );
  		const s = lerp( _hslA.s, _hslB.s, alpha );
  		const l = lerp( _hslA.l, _hslB.l, alpha );

  		this.setHSL( h, s, l );

  		return this;

  	}

  	setFromVector3( v ) {

  		this.r = v.x;
  		this.g = v.y;
  		this.b = v.z;

  		return this;

  	}

  	applyMatrix3( m ) {

  		const r = this.r, g = this.g, b = this.b;
  		const e = m.elements;

  		this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
  		this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
  		this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

  		return this;

  	}

  	equals( c ) {

  		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  	}

  	fromArray( array, offset = 0 ) {

  		this.r = array[ offset ];
  		this.g = array[ offset + 1 ];
  		this.b = array[ offset + 2 ];

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.r;
  		array[ offset + 1 ] = this.g;
  		array[ offset + 2 ] = this.b;

  		return array;

  	}

  	fromBufferAttribute( attribute, index ) {

  		this.r = attribute.getX( index );
  		this.g = attribute.getY( index );
  		this.b = attribute.getZ( index );

  		return this;

  	}

  	toJSON() {

  		return this.getHex();

  	}

  	*[ Symbol.iterator ]() {

  		yield this.r;
  		yield this.g;
  		yield this.b;

  	}

  }

  const _color = /*@__PURE__*/ new Color();

  Color.NAMES = _colorKeywords;

  let _materialId = 0;

  class Material extends EventDispatcher {

  	constructor() {

  		super();

  		this.isMaterial = true;

  		Object.defineProperty( this, 'id', { value: _materialId ++ } );

  		this.uuid = generateUUID();

  		this.name = '';
  		this.type = 'Material';

  		this.blending = NormalBlending;
  		this.side = FrontSide;
  		this.vertexColors = false;

  		this.opacity = 1;
  		this.transparent = false;
  		this.alphaHash = false;

  		this.blendSrc = SrcAlphaFactor;
  		this.blendDst = OneMinusSrcAlphaFactor;
  		this.blendEquation = AddEquation;
  		this.blendSrcAlpha = null;
  		this.blendDstAlpha = null;
  		this.blendEquationAlpha = null;
  		this.blendColor = new Color( 0, 0, 0 );
  		this.blendAlpha = 0;

  		this.depthFunc = LessEqualDepth;
  		this.depthTest = true;
  		this.depthWrite = true;

  		this.stencilWriteMask = 0xff;
  		this.stencilFunc = AlwaysStencilFunc;
  		this.stencilRef = 0;
  		this.stencilFuncMask = 0xff;
  		this.stencilFail = KeepStencilOp;
  		this.stencilZFail = KeepStencilOp;
  		this.stencilZPass = KeepStencilOp;
  		this.stencilWrite = false;

  		this.clippingPlanes = null;
  		this.clipIntersection = false;
  		this.clipShadows = false;

  		this.shadowSide = null;

  		this.colorWrite = true;

  		this.precision = null; // override the renderer's default precision for this material

  		this.polygonOffset = false;
  		this.polygonOffsetFactor = 0;
  		this.polygonOffsetUnits = 0;

  		this.dithering = false;

  		this.alphaToCoverage = false;
  		this.premultipliedAlpha = false;
  		this.forceSinglePass = false;

  		this.visible = true;

  		this.toneMapped = true;

  		this.userData = {};

  		this.version = 0;

  		this._alphaTest = 0;

  	}

  	get alphaTest() {

  		return this._alphaTest;

  	}

  	set alphaTest( value ) {

  		if ( this._alphaTest > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._alphaTest = value;

  	}

  	// onBeforeRender and onBeforeCompile only supported in WebGLRenderer

  	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

  	onBeforeCompile( /* shaderobject, renderer */ ) {}

  	customProgramCacheKey() {

  		return this.onBeforeCompile.toString();

  	}

  	setValues( values ) {

  		if ( values === undefined ) return;

  		for ( const key in values ) {

  			const newValue = values[ key ];

  			if ( newValue === undefined ) {

  				console.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );
  				continue;

  			}

  			const currentValue = this[ key ];

  			if ( currentValue === undefined ) {

  				console.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );
  				continue;

  			}

  			if ( currentValue && currentValue.isColor ) {

  				currentValue.set( newValue );

  			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

  				currentValue.copy( newValue );

  			} else {

  				this[ key ] = newValue;

  			}

  		}

  	}

  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( isRootObject ) {

  			meta = {
  				textures: {},
  				images: {}
  			};

  		}

  		const data = {
  			metadata: {
  				version: 4.6,
  				type: 'Material',
  				generator: 'Material.toJSON'
  			}
  		};

  		// standard Material serialization
  		data.uuid = this.uuid;
  		data.type = this.type;

  		if ( this.name !== '' ) data.name = this.name;

  		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

  		if ( this.roughness !== undefined ) data.roughness = this.roughness;
  		if ( this.metalness !== undefined ) data.metalness = this.metalness;

  		if ( this.sheen !== undefined ) data.sheen = this.sheen;
  		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
  		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
  		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
  		if ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

  		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
  		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
  		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
  		if ( this.shininess !== undefined ) data.shininess = this.shininess;
  		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
  		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

  		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

  			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

  		}

  		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

  			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

  		}

  		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

  			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
  			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

  		}

  		if ( this.dispersion !== undefined ) data.dispersion = this.dispersion;

  		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
  		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
  		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

  		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

  			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

  		}

  		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

  			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

  		}

  		if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
  		if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

  		if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

  			data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

  		}

  		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
  		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
  		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

  		if ( this.lightMap && this.lightMap.isTexture ) {

  			data.lightMap = this.lightMap.toJSON( meta ).uuid;
  			data.lightMapIntensity = this.lightMapIntensity;

  		}

  		if ( this.aoMap && this.aoMap.isTexture ) {

  			data.aoMap = this.aoMap.toJSON( meta ).uuid;
  			data.aoMapIntensity = this.aoMapIntensity;

  		}

  		if ( this.bumpMap && this.bumpMap.isTexture ) {

  			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
  			data.bumpScale = this.bumpScale;

  		}

  		if ( this.normalMap && this.normalMap.isTexture ) {

  			data.normalMap = this.normalMap.toJSON( meta ).uuid;
  			data.normalMapType = this.normalMapType;
  			data.normalScale = this.normalScale.toArray();

  		}

  		if ( this.displacementMap && this.displacementMap.isTexture ) {

  			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
  			data.displacementScale = this.displacementScale;
  			data.displacementBias = this.displacementBias;

  		}

  		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
  		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

  		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
  		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
  		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
  		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

  		if ( this.envMap && this.envMap.isTexture ) {

  			data.envMap = this.envMap.toJSON( meta ).uuid;

  			if ( this.combine !== undefined ) data.combine = this.combine;

  		}

  		if ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();
  		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
  		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
  		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

  		if ( this.gradientMap && this.gradientMap.isTexture ) {

  			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

  		}

  		if ( this.transmission !== undefined ) data.transmission = this.transmission;
  		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
  		if ( this.thickness !== undefined ) data.thickness = this.thickness;
  		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
  		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
  		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

  		if ( this.size !== undefined ) data.size = this.size;
  		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
  		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

  		if ( this.blending !== NormalBlending ) data.blending = this.blending;
  		if ( this.side !== FrontSide ) data.side = this.side;
  		if ( this.vertexColors === true ) data.vertexColors = true;

  		if ( this.opacity < 1 ) data.opacity = this.opacity;
  		if ( this.transparent === true ) data.transparent = true;

  		if ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;
  		if ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;
  		if ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;
  		if ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;
  		if ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;
  		if ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;
  		if ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();
  		if ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;

  		if ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;
  		if ( this.depthTest === false ) data.depthTest = this.depthTest;
  		if ( this.depthWrite === false ) data.depthWrite = this.depthWrite;
  		if ( this.colorWrite === false ) data.colorWrite = this.colorWrite;

  		if ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;
  		if ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;
  		if ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;
  		if ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;
  		if ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;
  		if ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;
  		if ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;
  		if ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;

  		// rotation (SpriteMaterial)
  		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

  		if ( this.polygonOffset === true ) data.polygonOffset = true;
  		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
  		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

  		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
  		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
  		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
  		if ( this.scale !== undefined ) data.scale = this.scale;

  		if ( this.dithering === true ) data.dithering = true;

  		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
  		if ( this.alphaHash === true ) data.alphaHash = true;
  		if ( this.alphaToCoverage === true ) data.alphaToCoverage = true;
  		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;
  		if ( this.forceSinglePass === true ) data.forceSinglePass = true;

  		if ( this.wireframe === true ) data.wireframe = true;
  		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
  		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
  		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

  		if ( this.flatShading === true ) data.flatShading = true;

  		if ( this.visible === false ) data.visible = false;

  		if ( this.toneMapped === false ) data.toneMapped = false;

  		if ( this.fog === false ) data.fog = false;

  		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			const values = [];

  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRootObject ) {

  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );

  			if ( textures.length > 0 ) data.textures = textures;
  			if ( images.length > 0 ) data.images = images;

  		}

  		return data;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		this.name = source.name;

  		this.blending = source.blending;
  		this.side = source.side;
  		this.vertexColors = source.vertexColors;

  		this.opacity = source.opacity;
  		this.transparent = source.transparent;

  		this.blendSrc = source.blendSrc;
  		this.blendDst = source.blendDst;
  		this.blendEquation = source.blendEquation;
  		this.blendSrcAlpha = source.blendSrcAlpha;
  		this.blendDstAlpha = source.blendDstAlpha;
  		this.blendEquationAlpha = source.blendEquationAlpha;
  		this.blendColor.copy( source.blendColor );
  		this.blendAlpha = source.blendAlpha;

  		this.depthFunc = source.depthFunc;
  		this.depthTest = source.depthTest;
  		this.depthWrite = source.depthWrite;

  		this.stencilWriteMask = source.stencilWriteMask;
  		this.stencilFunc = source.stencilFunc;
  		this.stencilRef = source.stencilRef;
  		this.stencilFuncMask = source.stencilFuncMask;
  		this.stencilFail = source.stencilFail;
  		this.stencilZFail = source.stencilZFail;
  		this.stencilZPass = source.stencilZPass;
  		this.stencilWrite = source.stencilWrite;

  		const srcPlanes = source.clippingPlanes;
  		let dstPlanes = null;

  		if ( srcPlanes !== null ) {

  			const n = srcPlanes.length;
  			dstPlanes = new Array( n );

  			for ( let i = 0; i !== n; ++ i ) {

  				dstPlanes[ i ] = srcPlanes[ i ].clone();

  			}

  		}

  		this.clippingPlanes = dstPlanes;
  		this.clipIntersection = source.clipIntersection;
  		this.clipShadows = source.clipShadows;

  		this.shadowSide = source.shadowSide;

  		this.colorWrite = source.colorWrite;

  		this.precision = source.precision;

  		this.polygonOffset = source.polygonOffset;
  		this.polygonOffsetFactor = source.polygonOffsetFactor;
  		this.polygonOffsetUnits = source.polygonOffsetUnits;

  		this.dithering = source.dithering;

  		this.alphaTest = source.alphaTest;
  		this.alphaHash = source.alphaHash;
  		this.alphaToCoverage = source.alphaToCoverage;
  		this.premultipliedAlpha = source.premultipliedAlpha;
  		this.forceSinglePass = source.forceSinglePass;

  		this.visible = source.visible;

  		this.toneMapped = source.toneMapped;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		return this;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	onBuild( /* shaderobject, renderer */ ) {

  		console.warn( 'Material: onBuild() has been removed.' ); // @deprecated, r166

  	}

  }

  class MeshBasicMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshBasicMaterial = true;

  		this.type = 'MeshBasicMaterial';

  		this.color = new Color( 0xffffff ); // emissive

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.envMapRotation = new Euler();
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.fog = source.fog;

  		return this;

  	}

  }

  // Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

  const _tables = /*@__PURE__*/ _generateTables();

  function _generateTables() {

  	// float32 to float16 helpers

  	const buffer = new ArrayBuffer( 4 );
  	const floatView = new Float32Array( buffer );
  	const uint32View = new Uint32Array( buffer );

  	const baseTable = new Uint32Array( 512 );
  	const shiftTable = new Uint32Array( 512 );

  	for ( let i = 0; i < 256; ++ i ) {

  		const e = i - 127;

  		// very small number (0, -0)

  		if ( e < - 27 ) {

  			baseTable[ i ] = 0x0000;
  			baseTable[ i | 0x100 ] = 0x8000;
  			shiftTable[ i ] = 24;
  			shiftTable[ i | 0x100 ] = 24;

  			// small number (denorm)

  		} else if ( e < - 14 ) {

  			baseTable[ i ] = 0x0400 >> ( - e - 14 );
  			baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
  			shiftTable[ i ] = - e - 1;
  			shiftTable[ i | 0x100 ] = - e - 1;

  			// normal number

  		} else if ( e <= 15 ) {

  			baseTable[ i ] = ( e + 15 ) << 10;
  			baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
  			shiftTable[ i ] = 13;
  			shiftTable[ i | 0x100 ] = 13;

  			// large number (Infinity, -Infinity)

  		} else if ( e < 128 ) {

  			baseTable[ i ] = 0x7c00;
  			baseTable[ i | 0x100 ] = 0xfc00;
  			shiftTable[ i ] = 24;
  			shiftTable[ i | 0x100 ] = 24;

  			// stay (NaN, Infinity, -Infinity)

  		} else {

  			baseTable[ i ] = 0x7c00;
  			baseTable[ i | 0x100 ] = 0xfc00;
  			shiftTable[ i ] = 13;
  			shiftTable[ i | 0x100 ] = 13;

  		}

  	}

  	// float16 to float32 helpers

  	const mantissaTable = new Uint32Array( 2048 );
  	const exponentTable = new Uint32Array( 64 );
  	const offsetTable = new Uint32Array( 64 );

  	for ( let i = 1; i < 1024; ++ i ) {

  		let m = i << 13; // zero pad mantissa bits
  		let e = 0; // zero exponent

  		// normalized
  		while ( ( m & 0x00800000 ) === 0 ) {

  			m <<= 1;
  			e -= 0x00800000; // decrement exponent

  		}

  		m &= ~ 0x00800000; // clear leading 1 bit
  		e += 0x38800000; // adjust bias

  		mantissaTable[ i ] = m | e;

  	}

  	for ( let i = 1024; i < 2048; ++ i ) {

  		mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

  	}

  	for ( let i = 1; i < 31; ++ i ) {

  		exponentTable[ i ] = i << 23;

  	}

  	exponentTable[ 31 ] = 0x47800000;
  	exponentTable[ 32 ] = 0x80000000;

  	for ( let i = 33; i < 63; ++ i ) {

  		exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

  	}

  	exponentTable[ 63 ] = 0xc7800000;

  	for ( let i = 1; i < 64; ++ i ) {

  		if ( i !== 32 ) {

  			offsetTable[ i ] = 1024;

  		}

  	}

  	return {
  		floatView: floatView,
  		uint32View: uint32View,
  		baseTable: baseTable,
  		shiftTable: shiftTable,
  		mantissaTable: mantissaTable,
  		exponentTable: exponentTable,
  		offsetTable: offsetTable
  	};

  }

  // float32 to float16

  function toHalfFloat( val ) {

  	if ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );

  	val = clamp$1( val, - 65504, 65504 );

  	_tables.floatView[ 0 ] = val;
  	const f = _tables.uint32View[ 0 ];
  	const e = ( f >> 23 ) & 0x1ff;
  	return _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );

  }

  // float16 to float32

  function fromHalfFloat( val ) {

  	const m = val >> 10;
  	_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];
  	return _tables.floatView[ 0 ];

  }

  const _vector$9 = /*@__PURE__*/ new Vector3();
  const _vector2$1 = /*@__PURE__*/ new Vector2();

  class BufferAttribute {

  	constructor( array, itemSize, normalized = false ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  		}

  		this.isBufferAttribute = true;

  		this.name = '';

  		this.array = array;
  		this.itemSize = itemSize;
  		this.count = array !== undefined ? array.length / itemSize : 0;
  		this.normalized = normalized;

  		this.usage = StaticDrawUsage;
  		this.updateRanges = [];
  		this.gpuType = FloatType;

  		this.version = 0;

  	}

  	onUploadCallback() {}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	setUsage( value ) {

  		this.usage = value;

  		return this;

  	}

  	addUpdateRange( start, count ) {

  		this.updateRanges.push( { start, count } );

  	}

  	clearUpdateRanges() {

  		this.updateRanges.length = 0;

  	}

  	copy( source ) {

  		this.name = source.name;
  		this.array = new source.array.constructor( source.array );
  		this.itemSize = source.itemSize;
  		this.count = source.count;
  		this.normalized = source.normalized;

  		this.usage = source.usage;
  		this.gpuType = source.gpuType;

  		return this;

  	}

  	copyAt( index1, attribute, index2 ) {

  		index1 *= this.itemSize;
  		index2 *= attribute.itemSize;

  		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

  			this.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	}

  	copyArray( array ) {

  		this.array.set( array );

  		return this;

  	}

  	applyMatrix3( m ) {

  		if ( this.itemSize === 2 ) {

  			for ( let i = 0, l = this.count; i < l; i ++ ) {

  				_vector2$1.fromBufferAttribute( this, i );
  				_vector2$1.applyMatrix3( m );

  				this.setXY( i, _vector2$1.x, _vector2$1.y );

  			}

  		} else if ( this.itemSize === 3 ) {

  			for ( let i = 0, l = this.count; i < l; i ++ ) {

  				_vector$9.fromBufferAttribute( this, i );
  				_vector$9.applyMatrix3( m );

  				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  			}

  		}

  		return this;

  	}

  	applyMatrix4( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.applyMatrix4( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	applyNormalMatrix( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.applyNormalMatrix( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	transformDirection( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.transformDirection( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	set( value, offset = 0 ) {

  		// Matching BufferAttribute constructor, do not normalize the array.
  		this.array.set( value, offset );

  		return this;

  	}

  	getComponent( index, component ) {

  		let value = this.array[ index * this.itemSize + component ];

  		if ( this.normalized ) value = denormalize( value, this.array );

  		return value;

  	}

  	setComponent( index, component, value ) {

  		if ( this.normalized ) value = normalize$1( value, this.array );

  		this.array[ index * this.itemSize + component ] = value;

  		return this;

  	}

  	getX( index ) {

  		let x = this.array[ index * this.itemSize ];

  		if ( this.normalized ) x = denormalize( x, this.array );

  		return x;

  	}

  	setX( index, x ) {

  		if ( this.normalized ) x = normalize$1( x, this.array );

  		this.array[ index * this.itemSize ] = x;

  		return this;

  	}

  	getY( index ) {

  		let y = this.array[ index * this.itemSize + 1 ];

  		if ( this.normalized ) y = denormalize( y, this.array );

  		return y;

  	}

  	setY( index, y ) {

  		if ( this.normalized ) y = normalize$1( y, this.array );

  		this.array[ index * this.itemSize + 1 ] = y;

  		return this;

  	}

  	getZ( index ) {

  		let z = this.array[ index * this.itemSize + 2 ];

  		if ( this.normalized ) z = denormalize( z, this.array );

  		return z;

  	}

  	setZ( index, z ) {

  		if ( this.normalized ) z = normalize$1( z, this.array );

  		this.array[ index * this.itemSize + 2 ] = z;

  		return this;

  	}

  	getW( index ) {

  		let w = this.array[ index * this.itemSize + 3 ];

  		if ( this.normalized ) w = denormalize( w, this.array );

  		return w;

  	}

  	setW( index, w ) {

  		if ( this.normalized ) w = normalize$1( w, this.array );

  		this.array[ index * this.itemSize + 3 ] = w;

  		return this;

  	}

  	setXY( index, x, y ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;

  		return this;

  	}

  	setXYZ( index, x, y, z ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;

  		return this;

  	}

  	setXYZW( index, x, y, z, w ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );
  			w = normalize$1( w, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;
  		this.array[ index + 3 ] = w;

  		return this;

  	}

  	onUpload( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  	clone() {

  		return new this.constructor( this.array, this.itemSize ).copy( this );

  	}

  	toJSON() {

  		const data = {
  			itemSize: this.itemSize,
  			type: this.array.constructor.name,
  			array: Array.from( this.array ),
  			normalized: this.normalized
  		};

  		if ( this.name !== '' ) data.name = this.name;
  		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;

  		return data;

  	}

  }

  class Uint16BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Uint16Array( array ), itemSize, normalized );

  	}

  }

  class Uint32BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Uint32Array( array ), itemSize, normalized );

  	}

  }

  class Float16BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Uint16Array( array ), itemSize, normalized );

  		this.isFloat16BufferAttribute = true;

  	}

  	getX( index ) {

  		let x = fromHalfFloat( this.array[ index * this.itemSize ] );

  		if ( this.normalized ) x = denormalize( x, this.array );

  		return x;

  	}

  	setX( index, x ) {

  		if ( this.normalized ) x = normalize$1( x, this.array );

  		this.array[ index * this.itemSize ] = toHalfFloat( x );

  		return this;

  	}

  	getY( index ) {

  		let y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );

  		if ( this.normalized ) y = denormalize( y, this.array );

  		return y;

  	}

  	setY( index, y ) {

  		if ( this.normalized ) y = normalize$1( y, this.array );

  		this.array[ index * this.itemSize + 1 ] = toHalfFloat( y );

  		return this;

  	}

  	getZ( index ) {

  		let z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );

  		if ( this.normalized ) z = denormalize( z, this.array );

  		return z;

  	}

  	setZ( index, z ) {

  		if ( this.normalized ) z = normalize$1( z, this.array );

  		this.array[ index * this.itemSize + 2 ] = toHalfFloat( z );

  		return this;

  	}

  	getW( index ) {

  		let w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );

  		if ( this.normalized ) w = denormalize( w, this.array );

  		return w;

  	}

  	setW( index, w ) {

  		if ( this.normalized ) w = normalize$1( w, this.array );

  		this.array[ index * this.itemSize + 3 ] = toHalfFloat( w );

  		return this;

  	}

  	setXY( index, x, y ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );

  		}

  		this.array[ index + 0 ] = toHalfFloat( x );
  		this.array[ index + 1 ] = toHalfFloat( y );

  		return this;

  	}

  	setXYZ( index, x, y, z ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );

  		}

  		this.array[ index + 0 ] = toHalfFloat( x );
  		this.array[ index + 1 ] = toHalfFloat( y );
  		this.array[ index + 2 ] = toHalfFloat( z );

  		return this;

  	}

  	setXYZW( index, x, y, z, w ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );
  			w = normalize$1( w, this.array );

  		}

  		this.array[ index + 0 ] = toHalfFloat( x );
  		this.array[ index + 1 ] = toHalfFloat( y );
  		this.array[ index + 2 ] = toHalfFloat( z );
  		this.array[ index + 3 ] = toHalfFloat( w );

  		return this;

  	}

  }


  class Float32BufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized ) {

  		super( new Float32Array( array ), itemSize, normalized );

  	}

  }

  let _id$9 = 0;

  const _m1 = /*@__PURE__*/ new Matrix4();
  const _obj = /*@__PURE__*/ new Object3D();
  const _offset = /*@__PURE__*/ new Vector3();
  const _box$2 = /*@__PURE__*/ new Box3();
  const _boxMorphTargets = /*@__PURE__*/ new Box3();
  const _vector$8 = /*@__PURE__*/ new Vector3();

  class BufferGeometry extends EventDispatcher {

  	constructor() {

  		super();

  		this.isBufferGeometry = true;

  		Object.defineProperty( this, 'id', { value: _id$9 ++ } );

  		this.uuid = generateUUID();

  		this.name = '';
  		this.type = 'BufferGeometry';

  		this.index = null;
  		this.attributes = {};

  		this.morphAttributes = {};
  		this.morphTargetsRelative = false;

  		this.groups = [];

  		this.boundingBox = null;
  		this.boundingSphere = null;

  		this.drawRange = { start: 0, count: Infinity };

  		this.userData = {};

  	}

  	getIndex() {

  		return this.index;

  	}

  	setIndex( index ) {

  		if ( Array.isArray( index ) ) {

  			this.index = new ( arrayNeedsUint32$1( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

  		} else {

  			this.index = index;

  		}

  		return this;

  	}

  	getAttribute( name ) {

  		return this.attributes[ name ];

  	}

  	setAttribute( name, attribute ) {

  		this.attributes[ name ] = attribute;

  		return this;

  	}

  	deleteAttribute( name ) {

  		delete this.attributes[ name ];

  		return this;

  	}

  	hasAttribute( name ) {

  		return this.attributes[ name ] !== undefined;

  	}

  	addGroup( start, count, materialIndex = 0 ) {

  		this.groups.push( {

  			start: start,
  			count: count,
  			materialIndex: materialIndex

  		} );

  	}

  	clearGroups() {

  		this.groups = [];

  	}

  	setDrawRange( start, count ) {

  		this.drawRange.start = start;
  		this.drawRange.count = count;

  	}

  	applyMatrix4( matrix ) {

  		const position = this.attributes.position;

  		if ( position !== undefined ) {

  			position.applyMatrix4( matrix );

  			position.needsUpdate = true;

  		}

  		const normal = this.attributes.normal;

  		if ( normal !== undefined ) {

  			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

  			normal.applyNormalMatrix( normalMatrix );

  			normal.needsUpdate = true;

  		}

  		const tangent = this.attributes.tangent;

  		if ( tangent !== undefined ) {

  			tangent.transformDirection( matrix );

  			tangent.needsUpdate = true;

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		return this;

  	}

  	applyQuaternion( q ) {

  		_m1.makeRotationFromQuaternion( q );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	rotateX( angle ) {

  		// rotate geometry around world x-axis

  		_m1.makeRotationX( angle );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	rotateY( angle ) {

  		// rotate geometry around world y-axis

  		_m1.makeRotationY( angle );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	rotateZ( angle ) {

  		// rotate geometry around world z-axis

  		_m1.makeRotationZ( angle );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	translate( x, y, z ) {

  		// translate geometry

  		_m1.makeTranslation( x, y, z );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	scale( x, y, z ) {

  		// scale geometry

  		_m1.makeScale( x, y, z );

  		this.applyMatrix4( _m1 );

  		return this;

  	}

  	lookAt( vector ) {

  		_obj.lookAt( vector );

  		_obj.updateMatrix();

  		this.applyMatrix4( _obj.matrix );

  		return this;

  	}

  	center() {

  		this.computeBoundingBox();

  		this.boundingBox.getCenter( _offset ).negate();

  		this.translate( _offset.x, _offset.y, _offset.z );

  		return this;

  	}

  	setFromPoints( points ) {

  		const position = [];

  		for ( let i = 0, l = points.length; i < l; i ++ ) {

  			const point = points[ i ];
  			position.push( point.x, point.y, point.z || 0 );

  		}

  		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

  		return this;

  	}

  	computeBoundingBox() {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		const position = this.attributes.position;
  		const morphAttributesPosition = this.morphAttributes.position;

  		if ( position && position.isGLBufferAttribute ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );

  			this.boundingBox.set(
  				new Vector3( - Infinity, - Infinity, - Infinity ),
  				new Vector3( + Infinity, + Infinity, + Infinity )
  			);

  			return;

  		}

  		if ( position !== undefined ) {

  			this.boundingBox.setFromBufferAttribute( position );

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					_box$2.setFromBufferAttribute( morphAttribute );

  					if ( this.morphTargetsRelative ) {

  						_vector$8.addVectors( this.boundingBox.min, _box$2.min );
  						this.boundingBox.expandByPoint( _vector$8 );

  						_vector$8.addVectors( this.boundingBox.max, _box$2.max );
  						this.boundingBox.expandByPoint( _vector$8 );

  					} else {

  						this.boundingBox.expandByPoint( _box$2.min );
  						this.boundingBox.expandByPoint( _box$2.max );

  					}

  				}

  			}

  		} else {

  			this.boundingBox.makeEmpty();

  		}

  		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

  		}

  	}

  	computeBoundingSphere() {

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere();

  		}

  		const position = this.attributes.position;
  		const morphAttributesPosition = this.morphAttributes.position;

  		if ( position && position.isGLBufferAttribute ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );

  			this.boundingSphere.set( new Vector3(), Infinity );

  			return;

  		}

  		if ( position ) {

  			// first, find the center of the bounding sphere

  			const center = this.boundingSphere.center;

  			_box$2.setFromBufferAttribute( position );

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

  					if ( this.morphTargetsRelative ) {

  						_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );
  						_box$2.expandByPoint( _vector$8 );

  						_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );
  						_box$2.expandByPoint( _vector$8 );

  					} else {

  						_box$2.expandByPoint( _boxMorphTargets.min );
  						_box$2.expandByPoint( _boxMorphTargets.max );

  					}

  				}

  			}

  			_box$2.getCenter( center );

  			// second, try to find a boundingSphere with a radius smaller than the
  			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

  			let maxRadiusSq = 0;

  			for ( let i = 0, il = position.count; i < il; i ++ ) {

  				_vector$8.fromBufferAttribute( position, i );

  				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

  			}

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					const morphTargetsRelative = this.morphTargetsRelative;

  					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

  						_vector$8.fromBufferAttribute( morphAttribute, j );

  						if ( morphTargetsRelative ) {

  							_offset.fromBufferAttribute( position, j );
  							_vector$8.add( _offset );

  						}

  						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

  					}

  				}

  			}

  			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

  			if ( isNaN( this.boundingSphere.radius ) ) {

  				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

  			}

  		}

  	}

  	computeTangents() {

  		const index = this.index;
  		const attributes = this.attributes;

  		// based on http://www.terathon.com/code/tangent.html
  		// (per vertex tangents)

  		if ( index === null ||
  			 attributes.position === undefined ||
  			 attributes.normal === undefined ||
  			 attributes.uv === undefined ) {

  			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
  			return;

  		}

  		const positionAttribute = attributes.position;
  		const normalAttribute = attributes.normal;
  		const uvAttribute = attributes.uv;

  		if ( this.hasAttribute( 'tangent' ) === false ) {

  			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );

  		}

  		const tangentAttribute = this.getAttribute( 'tangent' );

  		const tan1 = [], tan2 = [];

  		for ( let i = 0; i < positionAttribute.count; i ++ ) {

  			tan1[ i ] = new Vector3();
  			tan2[ i ] = new Vector3();

  		}

  		const vA = new Vector3(),
  			vB = new Vector3(),
  			vC = new Vector3(),

  			uvA = new Vector2(),
  			uvB = new Vector2(),
  			uvC = new Vector2(),

  			sdir = new Vector3(),
  			tdir = new Vector3();

  		function handleTriangle( a, b, c ) {

  			vA.fromBufferAttribute( positionAttribute, a );
  			vB.fromBufferAttribute( positionAttribute, b );
  			vC.fromBufferAttribute( positionAttribute, c );

  			uvA.fromBufferAttribute( uvAttribute, a );
  			uvB.fromBufferAttribute( uvAttribute, b );
  			uvC.fromBufferAttribute( uvAttribute, c );

  			vB.sub( vA );
  			vC.sub( vA );

  			uvB.sub( uvA );
  			uvC.sub( uvA );

  			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

  			// silently ignore degenerate uv triangles having coincident or colinear vertices

  			if ( ! isFinite( r ) ) return;

  			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
  			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

  			tan1[ a ].add( sdir );
  			tan1[ b ].add( sdir );
  			tan1[ c ].add( sdir );

  			tan2[ a ].add( tdir );
  			tan2[ b ].add( tdir );
  			tan2[ c ].add( tdir );

  		}

  		let groups = this.groups;

  		if ( groups.length === 0 ) {

  			groups = [ {
  				start: 0,
  				count: index.count
  			} ];

  		}

  		for ( let i = 0, il = groups.length; i < il; ++ i ) {

  			const group = groups[ i ];

  			const start = group.start;
  			const count = group.count;

  			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

  				handleTriangle(
  					index.getX( j + 0 ),
  					index.getX( j + 1 ),
  					index.getX( j + 2 )
  				);

  			}

  		}

  		const tmp = new Vector3(), tmp2 = new Vector3();
  		const n = new Vector3(), n2 = new Vector3();

  		function handleVertex( v ) {

  			n.fromBufferAttribute( normalAttribute, v );
  			n2.copy( n );

  			const t = tan1[ v ];

  			// Gram-Schmidt orthogonalize

  			tmp.copy( t );
  			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

  			// Calculate handedness

  			tmp2.crossVectors( n2, t );
  			const test = tmp2.dot( tan2[ v ] );
  			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

  			tangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );

  		}

  		for ( let i = 0, il = groups.length; i < il; ++ i ) {

  			const group = groups[ i ];

  			const start = group.start;
  			const count = group.count;

  			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

  				handleVertex( index.getX( j + 0 ) );
  				handleVertex( index.getX( j + 1 ) );
  				handleVertex( index.getX( j + 2 ) );

  			}

  		}

  	}

  	computeVertexNormals() {

  		const index = this.index;
  		const positionAttribute = this.getAttribute( 'position' );

  		if ( positionAttribute !== undefined ) {

  			let normalAttribute = this.getAttribute( 'normal' );

  			if ( normalAttribute === undefined ) {

  				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
  				this.setAttribute( 'normal', normalAttribute );

  			} else {

  				// reset existing normals to zero

  				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

  					normalAttribute.setXYZ( i, 0, 0, 0 );

  				}

  			}

  			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
  			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
  			const cb = new Vector3(), ab = new Vector3();

  			// indexed elements

  			if ( index ) {

  				for ( let i = 0, il = index.count; i < il; i += 3 ) {

  					const vA = index.getX( i + 0 );
  					const vB = index.getX( i + 1 );
  					const vC = index.getX( i + 2 );

  					pA.fromBufferAttribute( positionAttribute, vA );
  					pB.fromBufferAttribute( positionAttribute, vB );
  					pC.fromBufferAttribute( positionAttribute, vC );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					nA.fromBufferAttribute( normalAttribute, vA );
  					nB.fromBufferAttribute( normalAttribute, vB );
  					nC.fromBufferAttribute( normalAttribute, vC );

  					nA.add( cb );
  					nB.add( cb );
  					nC.add( cb );

  					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
  					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
  					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

  				}

  			} else {

  				// non-indexed elements (unconnected triangle soup)

  				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

  					pA.fromBufferAttribute( positionAttribute, i + 0 );
  					pB.fromBufferAttribute( positionAttribute, i + 1 );
  					pC.fromBufferAttribute( positionAttribute, i + 2 );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
  					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
  					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

  				}

  			}

  			this.normalizeNormals();

  			normalAttribute.needsUpdate = true;

  		}

  	}

  	normalizeNormals() {

  		const normals = this.attributes.normal;

  		for ( let i = 0, il = normals.count; i < il; i ++ ) {

  			_vector$8.fromBufferAttribute( normals, i );

  			_vector$8.normalize();

  			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

  		}

  	}

  	toNonIndexed() {

  		function convertBufferAttribute( attribute, indices ) {

  			const array = attribute.array;
  			const itemSize = attribute.itemSize;
  			const normalized = attribute.normalized;

  			const array2 = new array.constructor( indices.length * itemSize );

  			let index = 0, index2 = 0;

  			for ( let i = 0, l = indices.length; i < l; i ++ ) {

  				if ( attribute.isInterleavedBufferAttribute ) {

  					index = indices[ i ] * attribute.data.stride + attribute.offset;

  				} else {

  					index = indices[ i ] * itemSize;

  				}

  				for ( let j = 0; j < itemSize; j ++ ) {

  					array2[ index2 ++ ] = array[ index ++ ];

  				}

  			}

  			return new BufferAttribute( array2, itemSize, normalized );

  		}

  		//

  		if ( this.index === null ) {

  			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
  			return this;

  		}

  		const geometry2 = new BufferGeometry();

  		const indices = this.index.array;
  		const attributes = this.attributes;

  		// attributes

  		for ( const name in attributes ) {

  			const attribute = attributes[ name ];

  			const newAttribute = convertBufferAttribute( attribute, indices );

  			geometry2.setAttribute( name, newAttribute );

  		}

  		// morph attributes

  		const morphAttributes = this.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const morphArray = [];
  			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

  				const attribute = morphAttribute[ i ];

  				const newAttribute = convertBufferAttribute( attribute, indices );

  				morphArray.push( newAttribute );

  			}

  			geometry2.morphAttributes[ name ] = morphArray;

  		}

  		geometry2.morphTargetsRelative = this.morphTargetsRelative;

  		// groups

  		const groups = this.groups;

  		for ( let i = 0, l = groups.length; i < l; i ++ ) {

  			const group = groups[ i ];
  			geometry2.addGroup( group.start, group.count, group.materialIndex );

  		}

  		return geometry2;

  	}

  	toJSON() {

  		const data = {
  			metadata: {
  				version: 4.6,
  				type: 'BufferGeometry',
  				generator: 'BufferGeometry.toJSON'
  			}
  		};

  		// standard BufferGeometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) data.name = this.name;
  		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

  		if ( this.parameters !== undefined ) {

  			const parameters = this.parameters;

  			for ( const key in parameters ) {

  				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

  			}

  			return data;

  		}

  		// for simplicity the code assumes attributes are not shared across geometries, see #15811

  		data.data = { attributes: {} };

  		const index = this.index;

  		if ( index !== null ) {

  			data.data.index = {
  				type: index.array.constructor.name,
  				array: Array.prototype.slice.call( index.array )
  			};

  		}

  		const attributes = this.attributes;

  		for ( const key in attributes ) {

  			const attribute = attributes[ key ];

  			data.data.attributes[ key ] = attribute.toJSON( data.data );

  		}

  		const morphAttributes = {};
  		let hasMorphAttributes = false;

  		for ( const key in this.morphAttributes ) {

  			const attributeArray = this.morphAttributes[ key ];

  			const array = [];

  			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

  				const attribute = attributeArray[ i ];

  				array.push( attribute.toJSON( data.data ) );

  			}

  			if ( array.length > 0 ) {

  				morphAttributes[ key ] = array;

  				hasMorphAttributes = true;

  			}

  		}

  		if ( hasMorphAttributes ) {

  			data.data.morphAttributes = morphAttributes;
  			data.data.morphTargetsRelative = this.morphTargetsRelative;

  		}

  		const groups = this.groups;

  		if ( groups.length > 0 ) {

  			data.data.groups = JSON.parse( JSON.stringify( groups ) );

  		}

  		const boundingSphere = this.boundingSphere;

  		if ( boundingSphere !== null ) {

  			data.data.boundingSphere = {
  				center: boundingSphere.center.toArray(),
  				radius: boundingSphere.radius
  			};

  		}

  		return data;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	copy( source ) {

  		// reset

  		this.index = null;
  		this.attributes = {};
  		this.morphAttributes = {};
  		this.groups = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// used for storing cloned, shared data

  		const data = {};

  		// name

  		this.name = source.name;

  		// index

  		const index = source.index;

  		if ( index !== null ) {

  			this.setIndex( index.clone( data ) );

  		}

  		// attributes

  		const attributes = source.attributes;

  		for ( const name in attributes ) {

  			const attribute = attributes[ name ];
  			this.setAttribute( name, attribute.clone( data ) );

  		}

  		// morph attributes

  		const morphAttributes = source.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const array = [];
  			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

  				array.push( morphAttribute[ i ].clone( data ) );

  			}

  			this.morphAttributes[ name ] = array;

  		}

  		this.morphTargetsRelative = source.morphTargetsRelative;

  		// groups

  		const groups = source.groups;

  		for ( let i = 0, l = groups.length; i < l; i ++ ) {

  			const group = groups[ i ];
  			this.addGroup( group.start, group.count, group.materialIndex );

  		}

  		// bounding box

  		const boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		const boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// draw range

  		this.drawRange.start = source.drawRange.start;
  		this.drawRange.count = source.drawRange.count;

  		// user data

  		this.userData = source.userData;

  		return this;

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  }

  const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();
  const _ray$3 = /*@__PURE__*/ new Ray();
  const _sphere$6 = /*@__PURE__*/ new Sphere();
  const _sphereHitAt = /*@__PURE__*/ new Vector3();

  const _vA$1 = /*@__PURE__*/ new Vector3();
  const _vB$1 = /*@__PURE__*/ new Vector3();
  const _vC$1 = /*@__PURE__*/ new Vector3();

  const _tempA = /*@__PURE__*/ new Vector3();
  const _morphA = /*@__PURE__*/ new Vector3();

  const _intersectionPoint = /*@__PURE__*/ new Vector3();
  const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

  class Mesh extends Object3D {

  	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

  		super();

  		this.isMesh = true;

  		this.type = 'Mesh';

  		this.geometry = geometry;
  		this.material = material;

  		this.updateMorphTargets();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		if ( source.morphTargetInfluences !== undefined ) {

  			this.morphTargetInfluences = source.morphTargetInfluences.slice();

  		}

  		if ( source.morphTargetDictionary !== undefined ) {

  			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

  		}

  		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
  		this.geometry = source.geometry;

  		return this;

  	}

  	updateMorphTargets() {

  		const geometry = this.geometry;

  		const morphAttributes = geometry.morphAttributes;
  		const keys = Object.keys( morphAttributes );

  		if ( keys.length > 0 ) {

  			const morphAttribute = morphAttributes[ keys[ 0 ] ];

  			if ( morphAttribute !== undefined ) {

  				this.morphTargetInfluences = [];
  				this.morphTargetDictionary = {};

  				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  					const name = morphAttribute[ m ].name || String( m );

  					this.morphTargetInfluences.push( 0 );
  					this.morphTargetDictionary[ name ] = m;

  				}

  			}

  		}

  	}

  	getVertexPosition( index, target ) {

  		const geometry = this.geometry;
  		const position = geometry.attributes.position;
  		const morphPosition = geometry.morphAttributes.position;
  		const morphTargetsRelative = geometry.morphTargetsRelative;

  		target.fromBufferAttribute( position, index );

  		const morphInfluences = this.morphTargetInfluences;

  		if ( morphPosition && morphInfluences ) {

  			_morphA.set( 0, 0, 0 );

  			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

  				const influence = morphInfluences[ i ];
  				const morphAttribute = morphPosition[ i ];

  				if ( influence === 0 ) continue;

  				_tempA.fromBufferAttribute( morphAttribute, index );

  				if ( morphTargetsRelative ) {

  					_morphA.addScaledVector( _tempA, influence );

  				} else {

  					_morphA.addScaledVector( _tempA.sub( target ), influence );

  				}

  			}

  			target.add( _morphA );

  		}

  		return target;

  	}

  	raycast( raycaster, intersects ) {

  		const geometry = this.geometry;
  		const material = this.material;
  		const matrixWorld = this.matrixWorld;

  		if ( material === undefined ) return;

  		// test with bounding sphere in world space

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere$6.copy( geometry.boundingSphere );
  		_sphere$6.applyMatrix4( matrixWorld );

  		// check distance from ray origin to bounding sphere

  		_ray$3.copy( raycaster.ray ).recast( raycaster.near );

  		if ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {

  			if ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;

  			if ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

  		}

  		// convert ray to local space of mesh

  		_inverseMatrix$3.copy( matrixWorld ).invert();
  		_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );

  		// test with bounding box in local space

  		if ( geometry.boundingBox !== null ) {

  			if ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;

  		}

  		// test for intersections with geometry

  		this._computeIntersections( raycaster, intersects, _ray$3 );

  	}

  	_computeIntersections( raycaster, intersects, rayLocalSpace ) {

  		let intersection;

  		const geometry = this.geometry;
  		const material = this.material;

  		const index = geometry.index;
  		const position = geometry.attributes.position;
  		const uv = geometry.attributes.uv;
  		const uv1 = geometry.attributes.uv1;
  		const normal = geometry.attributes.normal;
  		const groups = geometry.groups;
  		const drawRange = geometry.drawRange;

  		if ( index !== null ) {

  			// indexed buffer geometry

  			if ( Array.isArray( material ) ) {

  				for ( let i = 0, il = groups.length; i < il; i ++ ) {

  					const group = groups[ i ];
  					const groupMaterial = material[ group.materialIndex ];

  					const start = Math.max( group.start, drawRange.start );
  					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

  					for ( let j = start, jl = end; j < jl; j += 3 ) {

  						const a = index.getX( j );
  						const b = index.getX( j + 1 );
  						const c = index.getX( j + 2 );

  						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
  							intersection.face.materialIndex = group.materialIndex;
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, il = end; i < il; i += 3 ) {

  					const a = index.getX( i );
  					const b = index.getX( i + 1 );
  					const c = index.getX( i + 2 );

  					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  					if ( intersection ) {

  						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
  						intersects.push( intersection );

  					}

  				}

  			}

  		} else if ( position !== undefined ) {

  			// non-indexed buffer geometry

  			if ( Array.isArray( material ) ) {

  				for ( let i = 0, il = groups.length; i < il; i ++ ) {

  					const group = groups[ i ];
  					const groupMaterial = material[ group.materialIndex ];

  					const start = Math.max( group.start, drawRange.start );
  					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

  					for ( let j = start, jl = end; j < jl; j += 3 ) {

  						const a = j;
  						const b = j + 1;
  						const c = j + 2;

  						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
  							intersection.face.materialIndex = group.materialIndex;
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, il = end; i < il; i += 3 ) {

  					const a = i;
  					const b = i + 1;
  					const c = i + 2;

  					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  					if ( intersection ) {

  						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
  						intersects.push( intersection );

  					}

  				}

  			}

  		}

  	}

  }

  function checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {

  	let intersect;

  	if ( material.side === BackSide ) {

  		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

  	} else {

  		intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

  	}

  	if ( intersect === null ) return null;

  	_intersectionPointWorld.copy( point );
  	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

  	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

  	if ( distance < raycaster.near || distance > raycaster.far ) return null;

  	return {
  		distance: distance,
  		point: _intersectionPointWorld.clone(),
  		object: object
  	};

  }

  function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

  	object.getVertexPosition( a, _vA$1 );
  	object.getVertexPosition( b, _vB$1 );
  	object.getVertexPosition( c, _vC$1 );

  	const intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

  	if ( intersection ) {

  		const barycoord = new Vector3();
  		Triangle.getBarycoord( _intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord );

  		if ( uv ) {

  			intersection.uv = Triangle.getInterpolatedAttribute( uv, a, b, c, barycoord, new Vector2() );

  		}

  		if ( uv1 ) {

  			intersection.uv1 = Triangle.getInterpolatedAttribute( uv1, a, b, c, barycoord, new Vector2() );

  		}

  		if ( normal ) {

  			intersection.normal = Triangle.getInterpolatedAttribute( normal, a, b, c, barycoord, new Vector3() );

  			if ( intersection.normal.dot( ray.direction ) > 0 ) {

  				intersection.normal.multiplyScalar( - 1 );

  			}

  		}

  		const face = {
  			a: a,
  			b: b,
  			c: c,
  			normal: new Vector3(),
  			materialIndex: 0
  		};

  		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

  		intersection.face = face;
  		intersection.barycoord = barycoord;

  	}

  	return intersection;

  }

  class BoxGeometry extends BufferGeometry {

  	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

  		super();

  		this.type = 'BoxGeometry';

  		this.parameters = {
  			width: width,
  			height: height,
  			depth: depth,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			depthSegments: depthSegments
  		};

  		const scope = this;

  		// segments

  		widthSegments = Math.floor( widthSegments );
  		heightSegments = Math.floor( heightSegments );
  		depthSegments = Math.floor( depthSegments );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// helper variables

  		let numberOfVertices = 0;
  		let groupStart = 0;

  		// build each side of the box geometry

  		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
  		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
  		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
  		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
  		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
  		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

  			const segmentWidth = width / gridX;
  			const segmentHeight = height / gridY;

  			const widthHalf = width / 2;
  			const heightHalf = height / 2;
  			const depthHalf = depth / 2;

  			const gridX1 = gridX + 1;
  			const gridY1 = gridY + 1;

  			let vertexCounter = 0;
  			let groupCount = 0;

  			const vector = new Vector3();

  			// generate vertices, normals and uvs

  			for ( let iy = 0; iy < gridY1; iy ++ ) {

  				const y = iy * segmentHeight - heightHalf;

  				for ( let ix = 0; ix < gridX1; ix ++ ) {

  					const x = ix * segmentWidth - widthHalf;

  					// set values to correct vector component

  					vector[ u ] = x * udir;
  					vector[ v ] = y * vdir;
  					vector[ w ] = depthHalf;

  					// now apply vector to vertex buffer

  					vertices.push( vector.x, vector.y, vector.z );

  					// set values to correct vector component

  					vector[ u ] = 0;
  					vector[ v ] = 0;
  					vector[ w ] = depth > 0 ? 1 : - 1;

  					// now apply vector to normal buffer

  					normals.push( vector.x, vector.y, vector.z );

  					// uvs

  					uvs.push( ix / gridX );
  					uvs.push( 1 - ( iy / gridY ) );

  					// counters

  					vertexCounter += 1;

  				}

  			}

  			// indices

  			// 1. you need three indices to draw a single face
  			// 2. a single segment consists of two faces
  			// 3. so we need to generate six (2*3) indices per segment

  			for ( let iy = 0; iy < gridY; iy ++ ) {

  				for ( let ix = 0; ix < gridX; ix ++ ) {

  					const a = numberOfVertices + ix + gridX1 * iy;
  					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
  					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
  					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

  					// faces

  					indices.push( a, b, d );
  					indices.push( b, c, d );

  					// increase counter

  					groupCount += 6;

  				}

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, materialIndex );

  			// calculate new start value for groups

  			groupStart += groupCount;

  			// update total number of vertices

  			numberOfVertices += vertexCounter;

  		}

  	}

  	copy( source ) {

  		super.copy( source );

  		this.parameters = Object.assign( {}, source.parameters );

  		return this;

  	}

  	static fromJSON( data ) {

  		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

  	}

  }

  /**
   * Uniform Utilities
   */

  function cloneUniforms( src ) {

  	const dst = {};

  	for ( const u in src ) {

  		dst[ u ] = {};

  		for ( const p in src[ u ] ) {

  			const property = src[ u ][ p ];

  			if ( property && ( property.isColor ||
  				property.isMatrix3 || property.isMatrix4 ||
  				property.isVector2 || property.isVector3 || property.isVector4 ||
  				property.isTexture || property.isQuaternion ) ) {

  				if ( property.isRenderTargetTexture ) {

  					console.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );
  					dst[ u ][ p ] = null;

  				} else {

  					dst[ u ][ p ] = property.clone();

  				}

  			} else if ( Array.isArray( property ) ) {

  				dst[ u ][ p ] = property.slice();

  			} else {

  				dst[ u ][ p ] = property;

  			}

  		}

  	}

  	return dst;

  }

  function cloneUniformsGroups( src ) {

  	const dst = [];

  	for ( let u = 0; u < src.length; u ++ ) {

  		dst.push( src[ u ].clone() );

  	}

  	return dst;

  }

  var default_vertex = /* glsl */`
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`;

  var default_fragment = /* glsl */`
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`;

  class ShaderMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isShaderMaterial = true;

  		this.type = 'ShaderMaterial';

  		this.defines = {};
  		this.uniforms = {};
  		this.uniformsGroups = [];

  		this.vertexShader = default_vertex;
  		this.fragmentShader = default_fragment;

  		this.linewidth = 1;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;

  		this.fog = false; // set to use scene fog
  		this.lights = false; // set to use scene lights
  		this.clipping = false; // set to use user-defined clipping planes

  		this.forceSinglePass = true;

  		this.extensions = {
  			clipCullDistance: false, // set to use vertex shader clipping
  			multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
  		};

  		// When rendered geometry doesn't include these attributes but the material does,
  		// use these default values in WebGL. This avoids errors when buffer data is missing.
  		this.defaultAttributeValues = {
  			'color': [ 1, 1, 1 ],
  			'uv': [ 0, 0 ],
  			'uv1': [ 0, 0 ]
  		};

  		this.index0AttributeName = undefined;
  		this.uniformsNeedUpdate = false;

  		this.glslVersion = null;

  		if ( parameters !== undefined ) {

  			this.setValues( parameters );

  		}

  	}

  	copy( source ) {

  		super.copy( source );

  		this.fragmentShader = source.fragmentShader;
  		this.vertexShader = source.vertexShader;

  		this.uniforms = cloneUniforms( source.uniforms );
  		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

  		this.defines = Object.assign( {}, source.defines );

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		this.fog = source.fog;
  		this.lights = source.lights;
  		this.clipping = source.clipping;

  		this.extensions = Object.assign( {}, source.extensions );

  		this.glslVersion = source.glslVersion;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.glslVersion = this.glslVersion;
  		data.uniforms = {};

  		for ( const name in this.uniforms ) {

  			const uniform = this.uniforms[ name ];
  			const value = uniform.value;

  			if ( value && value.isTexture ) {

  				data.uniforms[ name ] = {
  					type: 't',
  					value: value.toJSON( meta ).uuid
  				};

  			} else if ( value && value.isColor ) {

  				data.uniforms[ name ] = {
  					type: 'c',
  					value: value.getHex()
  				};

  			} else if ( value && value.isVector2 ) {

  				data.uniforms[ name ] = {
  					type: 'v2',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector3 ) {

  				data.uniforms[ name ] = {
  					type: 'v3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector4 ) {

  				data.uniforms[ name ] = {
  					type: 'v4',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix3 ) {

  				data.uniforms[ name ] = {
  					type: 'm3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix4 ) {

  				data.uniforms[ name ] = {
  					type: 'm4',
  					value: value.toArray()
  				};

  			} else {

  				data.uniforms[ name ] = {
  					value: value
  				};

  				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

  			}

  		}

  		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

  		data.vertexShader = this.vertexShader;
  		data.fragmentShader = this.fragmentShader;

  		data.lights = this.lights;
  		data.clipping = this.clipping;

  		const extensions = {};

  		for ( const key in this.extensions ) {

  			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

  		}

  		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

  		return data;

  	}

  }

  class Camera extends Object3D {

  	constructor() {

  		super();

  		this.isCamera = true;

  		this.type = 'Camera';

  		this.matrixWorldInverse = new Matrix4();

  		this.projectionMatrix = new Matrix4();
  		this.projectionMatrixInverse = new Matrix4();

  		this.coordinateSystem = WebGLCoordinateSystem;

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.matrixWorldInverse.copy( source.matrixWorldInverse );

  		this.projectionMatrix.copy( source.projectionMatrix );
  		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

  		this.coordinateSystem = source.coordinateSystem;

  		return this;

  	}

  	getWorldDirection( target ) {

  		return super.getWorldDirection( target ).negate();

  	}

  	updateMatrixWorld( force ) {

  		super.updateMatrixWorld( force );

  		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

  	}

  	updateWorldMatrix( updateParents, updateChildren ) {

  		super.updateWorldMatrix( updateParents, updateChildren );

  		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _v3$1 = /*@__PURE__*/ new Vector3();
  const _minTarget = /*@__PURE__*/ new Vector2();
  const _maxTarget = /*@__PURE__*/ new Vector2();


  class PerspectiveCamera extends Camera {

  	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

  		super();

  		this.isPerspectiveCamera = true;

  		this.type = 'PerspectiveCamera';

  		this.fov = fov;
  		this.zoom = 1;

  		this.near = near;
  		this.far = far;
  		this.focus = 10;

  		this.aspect = aspect;
  		this.view = null;

  		this.filmGauge = 35;	// width of the film (default in millimeters)
  		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

  		this.updateProjectionMatrix();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.fov = source.fov;
  		this.zoom = source.zoom;

  		this.near = source.near;
  		this.far = source.far;
  		this.focus = source.focus;

  		this.aspect = source.aspect;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		this.filmGauge = source.filmGauge;
  		this.filmOffset = source.filmOffset;

  		return this;

  	}

  	/**
  	 * Sets the FOV by focal length in respect to the current .filmGauge.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * Values for focal length and film gauge must have the same unit.
  	 */
  	setFocalLength( focalLength ) {

  		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
  		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

  		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Calculates the focal length from the current .fov and .filmGauge.
  	 */
  	getFocalLength() {

  		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

  		return 0.5 * this.getFilmHeight() / vExtentSlope;

  	}

  	getEffectiveFOV() {

  		return RAD2DEG * 2 * Math.atan(
  			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

  	}

  	getFilmWidth() {

  		// film not completely covered in portrait format (aspect < 1)
  		return this.filmGauge * Math.min( this.aspect, 1 );

  	}

  	getFilmHeight() {

  		// film not completely covered in landscape format (aspect > 1)
  		return this.filmGauge / Math.max( this.aspect, 1 );

  	}

  	/**
  	 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
  	 * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
  	 */
  	getViewBounds( distance, minTarget, maxTarget ) {

  		_v3$1.set( - 1, - 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

  		minTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

  		_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

  		maxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

  	}

  	/**
  	 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
  	 * Copies the result into the target Vector2, where x is width and y is height.
  	 */
  	getViewSize( distance, target ) {

  		this.getViewBounds( distance, _minTarget, _maxTarget );

  		return target.subVectors( _maxTarget, _minTarget );

  	}

  	/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *
  	 * then for each monitor you would call it like this
  	 *
  	 *   const w = 1920;
  	 *   const h = 1080;
  	 *   const fullWidth = w * 3;
  	 *   const fullHeight = h * 2;
  	 *
  	 *   --A--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 *   --B--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 *   --C--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 *   --D--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 *   --E--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 *   --F--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 *
  	 *   Note there is no reason monitors have to be the same size or in a grid.
  	 */
  	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

  		this.aspect = fullWidth / fullHeight;

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	}

  	clearViewOffset() {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	}

  	updateProjectionMatrix() {

  		const near = this.near;
  		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
  		let height = 2 * top;
  		let width = this.aspect * height;
  		let left = - 0.5 * width;
  		const view = this.view;

  		if ( this.view !== null && this.view.enabled ) {

  			const fullWidth = view.fullWidth,
  				fullHeight = view.fullHeight;

  			left += view.offsetX * width / fullWidth;
  			top -= view.offsetY * height / fullHeight;
  			width *= view.width / fullWidth;
  			height *= view.height / fullHeight;

  		}

  		const skew = this.filmOffset;
  		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

  		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );

  		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.fov = this.fov;
  		data.object.zoom = this.zoom;

  		data.object.near = this.near;
  		data.object.far = this.far;
  		data.object.focus = this.focus;

  		data.object.aspect = this.aspect;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		data.object.filmGauge = this.filmGauge;
  		data.object.filmOffset = this.filmOffset;

  		return data;

  	}

  }

  const fov = - 90; // negative fov is not an error
  const aspect = 1;

  class CubeCamera extends Object3D {

  	constructor( near, far, renderTarget ) {

  		super();

  		this.type = 'CubeCamera';

  		this.renderTarget = renderTarget;
  		this.coordinateSystem = null;
  		this.activeMipmapLevel = 0;

  		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPX.layers = this.layers;
  		this.add( cameraPX );

  		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNX.layers = this.layers;
  		this.add( cameraNX );

  		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPY.layers = this.layers;
  		this.add( cameraPY );

  		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNY.layers = this.layers;
  		this.add( cameraNY );

  		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPZ.layers = this.layers;
  		this.add( cameraPZ );

  		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNZ.layers = this.layers;
  		this.add( cameraNZ );

  	}

  	updateCoordinateSystem() {

  		const coordinateSystem = this.coordinateSystem;

  		const cameras = this.children.concat();

  		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

  		for ( const camera of cameras ) this.remove( camera );

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			cameraPX.up.set( 0, 1, 0 );
  			cameraPX.lookAt( 1, 0, 0 );

  			cameraNX.up.set( 0, 1, 0 );
  			cameraNX.lookAt( - 1, 0, 0 );

  			cameraPY.up.set( 0, 0, - 1 );
  			cameraPY.lookAt( 0, 1, 0 );

  			cameraNY.up.set( 0, 0, 1 );
  			cameraNY.lookAt( 0, - 1, 0 );

  			cameraPZ.up.set( 0, 1, 0 );
  			cameraPZ.lookAt( 0, 0, 1 );

  			cameraNZ.up.set( 0, 1, 0 );
  			cameraNZ.lookAt( 0, 0, - 1 );

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			cameraPX.up.set( 0, - 1, 0 );
  			cameraPX.lookAt( - 1, 0, 0 );

  			cameraNX.up.set( 0, - 1, 0 );
  			cameraNX.lookAt( 1, 0, 0 );

  			cameraPY.up.set( 0, 0, 1 );
  			cameraPY.lookAt( 0, 1, 0 );

  			cameraNY.up.set( 0, 0, - 1 );
  			cameraNY.lookAt( 0, - 1, 0 );

  			cameraPZ.up.set( 0, - 1, 0 );
  			cameraPZ.lookAt( 0, 0, 1 );

  			cameraNZ.up.set( 0, - 1, 0 );
  			cameraNZ.lookAt( 0, 0, - 1 );

  		} else {

  			throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		for ( const camera of cameras ) {

  			this.add( camera );

  			camera.updateMatrixWorld();

  		}

  	}

  	update( renderer, scene ) {

  		if ( this.parent === null ) this.updateMatrixWorld();

  		const { renderTarget, activeMipmapLevel } = this;

  		if ( this.coordinateSystem !== renderer.coordinateSystem ) {

  			this.coordinateSystem = renderer.coordinateSystem;

  			this.updateCoordinateSystem();

  		}

  		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

  		const currentRenderTarget = renderer.getRenderTarget();
  		const currentActiveCubeFace = renderer.getActiveCubeFace();
  		const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();

  		const currentXrEnabled = renderer.xr.enabled;

  		renderer.xr.enabled = false;

  		const generateMipmaps = renderTarget.texture.generateMipmaps;

  		renderTarget.texture.generateMipmaps = false;

  		renderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );
  		renderer.render( scene, cameraPX );

  		renderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );
  		renderer.render( scene, cameraNX );

  		renderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );
  		renderer.render( scene, cameraPY );

  		renderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );
  		renderer.render( scene, cameraNY );

  		renderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );
  		renderer.render( scene, cameraPZ );

  		// mipmaps are generated during the last call of render()
  		// at this point, all sides of the cube render target are defined

  		renderTarget.texture.generateMipmaps = generateMipmaps;

  		renderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );
  		renderer.render( scene, cameraNZ );

  		renderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

  		renderer.xr.enabled = currentXrEnabled;

  		renderTarget.texture.needsPMREMUpdate = true;

  	}

  }

  class CubeTexture extends Texture {

  	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

  		images = images !== undefined ? images : [];
  		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

  		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

  		this.isCubeTexture = true;

  		this.flipY = false;

  	}

  	get images() {

  		return this.image;

  	}

  	set images( value ) {

  		this.image = value;

  	}

  }

  class WebGLCubeRenderTarget extends WebGLRenderTarget {

  	constructor( size = 1, options = {} ) {

  		super( size, size, options );

  		this.isWebGLCubeRenderTarget = true;

  		const image = { width: size, height: size, depth: 1 };
  		const images = [ image, image, image, image, image, image ];

  		this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

  		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
  		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
  		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

  		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
  		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
  		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

  		this.texture.isRenderTargetTexture = true;

  		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
  		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

  	}

  	fromEquirectangularTexture( renderer, texture ) {

  		this.texture.type = texture.type;
  		this.texture.colorSpace = texture.colorSpace;

  		this.texture.generateMipmaps = texture.generateMipmaps;
  		this.texture.minFilter = texture.minFilter;
  		this.texture.magFilter = texture.magFilter;

  		const shader = {

  			uniforms: {
  				tEquirect: { value: null },
  			},

  			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

  			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
  		};

  		const geometry = new BoxGeometry( 5, 5, 5 );

  		const material = new ShaderMaterial( {

  			name: 'CubemapFromEquirect',

  			uniforms: cloneUniforms( shader.uniforms ),
  			vertexShader: shader.vertexShader,
  			fragmentShader: shader.fragmentShader,
  			side: BackSide,
  			blending: NoBlending

  		} );

  		material.uniforms.tEquirect.value = texture;

  		const mesh = new Mesh( geometry, material );

  		const currentMinFilter = texture.minFilter;

  		// Avoid blurred poles
  		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

  		const camera = new CubeCamera( 1, 10, this );
  		camera.update( renderer, mesh );

  		texture.minFilter = currentMinFilter;

  		mesh.geometry.dispose();
  		mesh.material.dispose();

  		return this;

  	}

  	clear( renderer, color, depth, stencil ) {

  		const currentRenderTarget = renderer.getRenderTarget();

  		for ( let i = 0; i < 6; i ++ ) {

  			renderer.setRenderTarget( this, i );

  			renderer.clear( color, depth, stencil );

  		}

  		renderer.setRenderTarget( currentRenderTarget );

  	}

  }

  class Scene extends Object3D {

  	constructor() {

  		super();

  		this.isScene = true;

  		this.type = 'Scene';

  		this.background = null;
  		this.environment = null;
  		this.fog = null;

  		this.backgroundBlurriness = 0;
  		this.backgroundIntensity = 1;
  		this.backgroundRotation = new Euler();

  		this.environmentIntensity = 1;
  		this.environmentRotation = new Euler();

  		this.overrideMaterial = null;

  		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

  		}

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		if ( source.background !== null ) this.background = source.background.clone();
  		if ( source.environment !== null ) this.environment = source.environment.clone();
  		if ( source.fog !== null ) this.fog = source.fog.clone();

  		this.backgroundBlurriness = source.backgroundBlurriness;
  		this.backgroundIntensity = source.backgroundIntensity;
  		this.backgroundRotation.copy( source.backgroundRotation );

  		this.environmentIntensity = source.environmentIntensity;
  		this.environmentRotation.copy( source.environmentRotation );

  		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

  		if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
  		if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;
  		data.object.backgroundRotation = this.backgroundRotation.toArray();

  		if ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;
  		data.object.environmentRotation = this.environmentRotation.toArray();

  		return data;

  	}

  }

  class InterleavedBuffer {

  	constructor( array, stride ) {

  		this.isInterleavedBuffer = true;

  		this.array = array;
  		this.stride = stride;
  		this.count = array !== undefined ? array.length / stride : 0;

  		this.usage = StaticDrawUsage;
  		this.updateRanges = [];

  		this.version = 0;

  		this.uuid = generateUUID();

  	}

  	onUploadCallback() {}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	setUsage( value ) {

  		this.usage = value;

  		return this;

  	}

  	addUpdateRange( start, count ) {

  		this.updateRanges.push( { start, count } );

  	}

  	clearUpdateRanges() {

  		this.updateRanges.length = 0;

  	}

  	copy( source ) {

  		this.array = new source.array.constructor( source.array );
  		this.count = source.count;
  		this.stride = source.stride;
  		this.usage = source.usage;

  		return this;

  	}

  	copyAt( index1, attribute, index2 ) {

  		index1 *= this.stride;
  		index2 *= attribute.stride;

  		for ( let i = 0, l = this.stride; i < l; i ++ ) {

  			this.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	}

  	set( value, offset = 0 ) {

  		this.array.set( value, offset );

  		return this;

  	}

  	clone( data ) {

  		if ( data.arrayBuffers === undefined ) {

  			data.arrayBuffers = {};

  		}

  		if ( this.array.buffer._uuid === undefined ) {

  			this.array.buffer._uuid = generateUUID();

  		}

  		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

  			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

  		}

  		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

  		const ib = new this.constructor( array, this.stride );
  		ib.setUsage( this.usage );

  		return ib;

  	}

  	onUpload( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  	toJSON( data ) {

  		if ( data.arrayBuffers === undefined ) {

  			data.arrayBuffers = {};

  		}

  		// generate UUID for array buffer if necessary

  		if ( this.array.buffer._uuid === undefined ) {

  			this.array.buffer._uuid = generateUUID();

  		}

  		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

  			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

  		}

  		//

  		return {
  			uuid: this.uuid,
  			buffer: this.array.buffer._uuid,
  			type: this.array.constructor.name,
  			stride: this.stride
  		};

  	}

  }

  const _vector$7 = /*@__PURE__*/ new Vector3();

  class InterleavedBufferAttribute {

  	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

  		this.isInterleavedBufferAttribute = true;

  		this.name = '';

  		this.data = interleavedBuffer;
  		this.itemSize = itemSize;
  		this.offset = offset;

  		this.normalized = normalized;

  	}

  	get count() {

  		return this.data.count;

  	}

  	get array() {

  		return this.data.array;

  	}

  	set needsUpdate( value ) {

  		this.data.needsUpdate = value;

  	}

  	applyMatrix4( m ) {

  		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

  			_vector$7.fromBufferAttribute( this, i );

  			_vector$7.applyMatrix4( m );

  			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

  		}

  		return this;

  	}

  	applyNormalMatrix( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$7.fromBufferAttribute( this, i );

  			_vector$7.applyNormalMatrix( m );

  			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

  		}

  		return this;

  	}

  	transformDirection( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$7.fromBufferAttribute( this, i );

  			_vector$7.transformDirection( m );

  			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

  		}

  		return this;

  	}

  	getComponent( index, component ) {

  		let value = this.array[ index * this.data.stride + this.offset + component ];

  		if ( this.normalized ) value = denormalize( value, this.array );

  		return value;

  	}

  	setComponent( index, component, value ) {

  		if ( this.normalized ) value = normalize$1( value, this.array );

  		this.data.array[ index * this.data.stride + this.offset + component ] = value;

  		return this;

  	}

  	setX( index, x ) {

  		if ( this.normalized ) x = normalize$1( x, this.array );

  		this.data.array[ index * this.data.stride + this.offset ] = x;

  		return this;

  	}

  	setY( index, y ) {

  		if ( this.normalized ) y = normalize$1( y, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

  		return this;

  	}

  	setZ( index, z ) {

  		if ( this.normalized ) z = normalize$1( z, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

  		return this;

  	}

  	setW( index, w ) {

  		if ( this.normalized ) w = normalize$1( w, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

  		return this;

  	}

  	getX( index ) {

  		let x = this.data.array[ index * this.data.stride + this.offset ];

  		if ( this.normalized ) x = denormalize( x, this.array );

  		return x;

  	}

  	getY( index ) {

  		let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

  		if ( this.normalized ) y = denormalize( y, this.array );

  		return y;

  	}

  	getZ( index ) {

  		let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

  		if ( this.normalized ) z = denormalize( z, this.array );

  		return z;

  	}

  	getW( index ) {

  		let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

  		if ( this.normalized ) w = denormalize( w, this.array );

  		return w;

  	}

  	setXY( index, x, y ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;

  		return this;

  	}

  	setXYZ( index, x, y, z ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;

  		return this;

  	}

  	setXYZW( index, x, y, z, w ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize$1( x, this.array );
  			y = normalize$1( y, this.array );
  			z = normalize$1( z, this.array );
  			w = normalize$1( w, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;
  		this.data.array[ index + 3 ] = w;

  		return this;

  	}

  	clone( data ) {

  		if ( data === undefined ) {

  			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

  			const array = [];

  			for ( let i = 0; i < this.count; i ++ ) {

  				const index = i * this.data.stride + this.offset;

  				for ( let j = 0; j < this.itemSize; j ++ ) {

  					array.push( this.data.array[ index + j ] );

  				}

  			}

  			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

  		} else {

  			if ( data.interleavedBuffers === undefined ) {

  				data.interleavedBuffers = {};

  			}

  			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

  				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

  			}

  			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

  		}

  	}

  	toJSON( data ) {

  		if ( data === undefined ) {

  			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

  			const array = [];

  			for ( let i = 0; i < this.count; i ++ ) {

  				const index = i * this.data.stride + this.offset;

  				for ( let j = 0; j < this.itemSize; j ++ ) {

  					array.push( this.data.array[ index + j ] );

  				}

  			}

  			// de-interleave data and save it as an ordinary buffer attribute for now

  			return {
  				itemSize: this.itemSize,
  				type: this.array.constructor.name,
  				array: array,
  				normalized: this.normalized
  			};

  		} else {

  			// save as true interleaved attribute

  			if ( data.interleavedBuffers === undefined ) {

  				data.interleavedBuffers = {};

  			}

  			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

  				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

  			}

  			return {
  				isInterleavedBufferAttribute: true,
  				itemSize: this.itemSize,
  				data: this.data.uuid,
  				offset: this.offset,
  				normalized: this.normalized
  			};

  		}

  	}

  }

  class SpriteMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isSpriteMaterial = true;

  		this.type = 'SpriteMaterial';

  		this.color = new Color( 0xffffff );

  		this.map = null;

  		this.alphaMap = null;

  		this.rotation = 0;

  		this.sizeAttenuation = true;

  		this.transparent = true;

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.rotation = source.rotation;

  		this.sizeAttenuation = source.sizeAttenuation;

  		this.fog = source.fog;

  		return this;

  	}

  }

  class DataTexture extends Texture {

  	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {

  		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

  		this.isDataTexture = true;

  		this.image = { data: data, width: width, height: height };

  		this.generateMipmaps = false;
  		this.flipY = false;
  		this.unpackAlignment = 1;

  	}

  }

  class InstancedBufferAttribute extends BufferAttribute {

  	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

  		super( array, itemSize, normalized );

  		this.isInstancedBufferAttribute = true;

  		this.meshPerAttribute = meshPerAttribute;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.meshPerAttribute = this.meshPerAttribute;

  		data.isInstancedBufferAttribute = true;

  		return data;

  	}

  }

  const _vector1 = /*@__PURE__*/ new Vector3();
  const _vector2 = /*@__PURE__*/ new Vector3();
  const _normalMatrix = /*@__PURE__*/ new Matrix3();

  class Plane {

  	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

  		this.isPlane = true;

  		// normal is assumed to be normalized

  		this.normal = normal;
  		this.constant = constant;

  	}

  	set( normal, constant ) {

  		this.normal.copy( normal );
  		this.constant = constant;

  		return this;

  	}

  	setComponents( x, y, z, w ) {

  		this.normal.set( x, y, z );
  		this.constant = w;

  		return this;

  	}

  	setFromNormalAndCoplanarPoint( normal, point ) {

  		this.normal.copy( normal );
  		this.constant = - point.dot( this.normal );

  		return this;

  	}

  	setFromCoplanarPoints( a, b, c ) {

  		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

  		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

  		this.setFromNormalAndCoplanarPoint( normal, a );

  		return this;

  	}

  	copy( plane ) {

  		this.normal.copy( plane.normal );
  		this.constant = plane.constant;

  		return this;

  	}

  	normalize() {

  		// Note: will lead to a divide by zero if the plane is invalid.

  		const inverseNormalLength = 1.0 / this.normal.length();
  		this.normal.multiplyScalar( inverseNormalLength );
  		this.constant *= inverseNormalLength;

  		return this;

  	}

  	negate() {

  		this.constant *= - 1;
  		this.normal.negate();

  		return this;

  	}

  	distanceToPoint( point ) {

  		return this.normal.dot( point ) + this.constant;

  	}

  	distanceToSphere( sphere ) {

  		return this.distanceToPoint( sphere.center ) - sphere.radius;

  	}

  	projectPoint( point, target ) {

  		return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

  	}

  	intersectLine( line, target ) {

  		const direction = line.delta( _vector1 );

  		const denominator = this.normal.dot( direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( this.distanceToPoint( line.start ) === 0 ) {

  				return target.copy( line.start );

  			}

  			// Unsure if this is the correct method to handle this case.
  			return null;

  		}

  		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

  		if ( t < 0 || t > 1 ) {

  			return null;

  		}

  		return target.copy( line.start ).addScaledVector( direction, t );

  	}

  	intersectsLine( line ) {

  		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

  		const startSign = this.distanceToPoint( line.start );
  		const endSign = this.distanceToPoint( line.end );

  		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  	}

  	intersectsBox( box ) {

  		return box.intersectsPlane( this );

  	}

  	intersectsSphere( sphere ) {

  		return sphere.intersectsPlane( this );

  	}

  	coplanarPoint( target ) {

  		return target.copy( this.normal ).multiplyScalar( - this.constant );

  	}

  	applyMatrix4( matrix, optionalNormalMatrix ) {

  		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

  		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

  		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

  		this.constant = - referencePoint.dot( normal );

  		return this;

  	}

  	translate( offset ) {

  		this.constant -= offset.dot( this.normal );

  		return this;

  	}

  	equals( plane ) {

  		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _sphere$3 = /*@__PURE__*/ new Sphere();
  const _vector$6 = /*@__PURE__*/ new Vector3();

  class Frustum {

  	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

  		this.planes = [ p0, p1, p2, p3, p4, p5 ];

  	}

  	set( p0, p1, p2, p3, p4, p5 ) {

  		const planes = this.planes;

  		planes[ 0 ].copy( p0 );
  		planes[ 1 ].copy( p1 );
  		planes[ 2 ].copy( p2 );
  		planes[ 3 ].copy( p3 );
  		planes[ 4 ].copy( p4 );
  		planes[ 5 ].copy( p5 );

  		return this;

  	}

  	copy( frustum ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			planes[ i ].copy( frustum.planes[ i ] );

  		}

  		return this;

  	}

  	setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {

  		const planes = this.planes;
  		const me = m.elements;
  		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
  		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
  		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
  		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

  		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
  		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
  		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
  		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
  		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();

  		} else {

  			throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		return this;

  	}

  	intersectsObject( object ) {

  		if ( object.boundingSphere !== undefined ) {

  			if ( object.boundingSphere === null ) object.computeBoundingSphere();

  			_sphere$3.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

  		} else {

  			const geometry = object.geometry;

  			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  			_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

  		}

  		return this.intersectsSphere( _sphere$3 );

  	}

  	intersectsSprite( sprite ) {

  		_sphere$3.center.set( 0, 0, 0 );
  		_sphere$3.radius = 0.7071067811865476;
  		_sphere$3.applyMatrix4( sprite.matrixWorld );

  		return this.intersectsSphere( _sphere$3 );

  	}

  	intersectsSphere( sphere ) {

  		const planes = this.planes;
  		const center = sphere.center;
  		const negRadius = - sphere.radius;

  		for ( let i = 0; i < 6; i ++ ) {

  			const distance = planes[ i ].distanceToPoint( center );

  			if ( distance < negRadius ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	intersectsBox( box ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			const plane = planes[ i ];

  			// corner at max distance

  			_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
  			_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
  			_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;

  			if ( plane.distanceToPoint( _vector$6 ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	containsPoint( point ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  class LineBasicMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isLineBasicMaterial = true;

  		this.type = 'LineBasicMaterial';

  		this.color = new Color( 0xffffff );

  		this.map = null;

  		this.linewidth = 1;
  		this.linecap = 'round';
  		this.linejoin = 'round';

  		this.fog = true;

  		this.setValues( parameters );

  	}


  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.linewidth = source.linewidth;
  		this.linecap = source.linecap;
  		this.linejoin = source.linejoin;

  		this.fog = source.fog;

  		return this;

  	}

  }

  class PointsMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isPointsMaterial = true;

  		this.type = 'PointsMaterial';

  		this.color = new Color( 0xffffff );

  		this.map = null;

  		this.alphaMap = null;

  		this.size = 1;
  		this.sizeAttenuation = true;

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.size = source.size;
  		this.sizeAttenuation = source.sizeAttenuation;

  		this.fog = source.fog;

  		return this;

  	}

  }

  class FramebufferTexture extends Texture {

  	constructor( width, height ) {

  		super( { width, height } );

  		this.isFramebufferTexture = true;

  		this.magFilter = NearestFilter;
  		this.minFilter = NearestFilter;

  		this.generateMipmaps = false;

  		this.needsUpdate = true;

  	}

  }

  class DepthTexture extends Texture {

  	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat ) {

  		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

  			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

  		}

  		if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
  		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

  		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  		this.isDepthTexture = true;

  		this.image = { width: width, height: height };

  		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

  		this.flipY = false;
  		this.generateMipmaps = false;

  		this.compareFunction = null;

  	}


  	copy( source ) {

  		super.copy( source );

  		this.compareFunction = source.compareFunction;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

  		return data;

  	}

  }

  class SphereGeometry extends BufferGeometry {

  	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

  		super();

  		this.type = 'SphereGeometry';

  		this.parameters = {
  			radius: radius,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			phiStart: phiStart,
  			phiLength: phiLength,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
  		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

  		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

  		let index = 0;
  		const grid = [];

  		const vertex = new Vector3();
  		const normal = new Vector3();

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// generate vertices, normals and uvs

  		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

  			const verticesRow = [];

  			const v = iy / heightSegments;

  			// special case for the poles

  			let uOffset = 0;

  			if ( iy === 0 && thetaStart === 0 ) {

  				uOffset = 0.5 / widthSegments;

  			} else if ( iy === heightSegments && thetaEnd === Math.PI ) {

  				uOffset = - 0.5 / widthSegments;

  			}

  			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

  				const u = ix / widthSegments;

  				// vertex

  				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
  				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
  				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normal.copy( vertex ).normalize();
  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( u + uOffset, 1 - v );

  				verticesRow.push( index ++ );

  			}

  			grid.push( verticesRow );

  		}

  		// indices

  		for ( let iy = 0; iy < heightSegments; iy ++ ) {

  			for ( let ix = 0; ix < widthSegments; ix ++ ) {

  				const a = grid[ iy ][ ix + 1 ];
  				const b = grid[ iy ][ ix ];
  				const c = grid[ iy + 1 ][ ix ];
  				const d = grid[ iy + 1 ][ ix + 1 ];

  				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
  				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.parameters = Object.assign( {}, source.parameters );

  		return this;

  	}

  	static fromJSON( data ) {

  		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

  	}

  }

  class ShadowMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isShadowMaterial = true;

  		this.type = 'ShadowMaterial';

  		this.color = new Color( 0x000000 );
  		this.transparent = true;

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.fog = source.fog;

  		return this;

  	}

  }

  class MeshStandardMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshStandardMaterial = true;

  		this.defines = { 'STANDARD': '' };

  		this.type = 'MeshStandardMaterial';

  		this.color = new Color( 0xffffff ); // diffuse
  		this.roughness = 1.0;
  		this.metalness = 0.0;

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.roughnessMap = null;

  		this.metalnessMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.envMapRotation = new Euler();
  		this.envMapIntensity = 1.0;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.flatShading = false;

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.defines = { 'STANDARD': '' };

  		this.color.copy( source.color );
  		this.roughness = source.roughness;
  		this.metalness = source.metalness;

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.roughnessMap = source.roughnessMap;

  		this.metalnessMap = source.metalnessMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.envMapIntensity = source.envMapIntensity;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  class MeshPhysicalMaterial extends MeshStandardMaterial {

  	constructor( parameters ) {

  		super();

  		this.isMeshPhysicalMaterial = true;

  		this.defines = {

  			'STANDARD': '',
  			'PHYSICAL': ''

  		};

  		this.type = 'MeshPhysicalMaterial';

  		this.anisotropyRotation = 0;
  		this.anisotropyMap = null;

  		this.clearcoatMap = null;
  		this.clearcoatRoughness = 0.0;
  		this.clearcoatRoughnessMap = null;
  		this.clearcoatNormalScale = new Vector2( 1, 1 );
  		this.clearcoatNormalMap = null;

  		this.ior = 1.5;

  		Object.defineProperty( this, 'reflectivity', {
  			get: function () {

  				return ( clamp$1( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

  			},
  			set: function ( reflectivity ) {

  				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

  			}
  		} );

  		this.iridescenceMap = null;
  		this.iridescenceIOR = 1.3;
  		this.iridescenceThicknessRange = [ 100, 400 ];
  		this.iridescenceThicknessMap = null;

  		this.sheenColor = new Color( 0x000000 );
  		this.sheenColorMap = null;
  		this.sheenRoughness = 1.0;
  		this.sheenRoughnessMap = null;

  		this.transmissionMap = null;

  		this.thickness = 0;
  		this.thicknessMap = null;
  		this.attenuationDistance = Infinity;
  		this.attenuationColor = new Color( 1, 1, 1 );

  		this.specularIntensity = 1.0;
  		this.specularIntensityMap = null;
  		this.specularColor = new Color( 1, 1, 1 );
  		this.specularColorMap = null;

  		this._anisotropy = 0;
  		this._clearcoat = 0;
  		this._dispersion = 0;
  		this._iridescence = 0;
  		this._sheen = 0.0;
  		this._transmission = 0;

  		this.setValues( parameters );

  	}

  	get anisotropy() {

  		return this._anisotropy;

  	}

  	set anisotropy( value ) {

  		if ( this._anisotropy > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._anisotropy = value;

  	}

  	get clearcoat() {

  		return this._clearcoat;

  	}

  	set clearcoat( value ) {

  		if ( this._clearcoat > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._clearcoat = value;

  	}

  	get iridescence() {

  		return this._iridescence;

  	}

  	set iridescence( value ) {

  		if ( this._iridescence > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._iridescence = value;

  	}

  	get dispersion() {

  		return this._dispersion;

  	}

  	set dispersion( value ) {

  		if ( this._dispersion > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._dispersion = value;

  	}

  	get sheen() {

  		return this._sheen;

  	}

  	set sheen( value ) {

  		if ( this._sheen > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._sheen = value;

  	}

  	get transmission() {

  		return this._transmission;

  	}

  	set transmission( value ) {

  		if ( this._transmission > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._transmission = value;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.defines = {

  			'STANDARD': '',
  			'PHYSICAL': ''

  		};

  		this.anisotropy = source.anisotropy;
  		this.anisotropyRotation = source.anisotropyRotation;
  		this.anisotropyMap = source.anisotropyMap;

  		this.clearcoat = source.clearcoat;
  		this.clearcoatMap = source.clearcoatMap;
  		this.clearcoatRoughness = source.clearcoatRoughness;
  		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  		this.clearcoatNormalMap = source.clearcoatNormalMap;
  		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

  		this.dispersion = source.dispersion;
  		this.ior = source.ior;

  		this.iridescence = source.iridescence;
  		this.iridescenceMap = source.iridescenceMap;
  		this.iridescenceIOR = source.iridescenceIOR;
  		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
  		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

  		this.sheen = source.sheen;
  		this.sheenColor.copy( source.sheenColor );
  		this.sheenColorMap = source.sheenColorMap;
  		this.sheenRoughness = source.sheenRoughness;
  		this.sheenRoughnessMap = source.sheenRoughnessMap;

  		this.transmission = source.transmission;
  		this.transmissionMap = source.transmissionMap;

  		this.thickness = source.thickness;
  		this.thicknessMap = source.thicknessMap;
  		this.attenuationDistance = source.attenuationDistance;
  		this.attenuationColor.copy( source.attenuationColor );

  		this.specularIntensity = source.specularIntensity;
  		this.specularIntensityMap = source.specularIntensityMap;
  		this.specularColor.copy( source.specularColor );
  		this.specularColorMap = source.specularColorMap;

  		return this;

  	}

  }

  class MeshPhongMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshPhongMaterial = true;

  		this.type = 'MeshPhongMaterial';

  		this.color = new Color( 0xffffff ); // diffuse
  		this.specular = new Color( 0x111111 );
  		this.shininess = 30;

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.envMapRotation = new Euler();
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.flatShading = false;

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );
  		this.specular.copy( source.specular );
  		this.shininess = source.shininess;

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  class MeshToonMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshToonMaterial = true;

  		this.defines = { 'TOON': '' };

  		this.type = 'MeshToonMaterial';

  		this.color = new Color( 0xffffff );

  		this.map = null;
  		this.gradientMap = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.alphaMap = null;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;
  		this.gradientMap = source.gradientMap;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.alphaMap = source.alphaMap;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.fog = source.fog;

  		return this;

  	}

  }

  class MeshNormalMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshNormalMaterial = true;

  		this.type = 'MeshNormalMaterial';

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;

  		this.flatShading = false;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		this.flatShading = source.flatShading;

  		return this;

  	}

  }

  class MeshLambertMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshLambertMaterial = true;

  		this.type = 'MeshLambertMaterial';

  		this.color = new Color( 0xffffff ); // diffuse

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.envMapRotation = new Euler();
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.flatShading = false;

  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  class MeshMatcapMaterial extends Material {

  	constructor( parameters ) {

  		super();

  		this.isMeshMatcapMaterial = true;

  		this.defines = { 'MATCAP': '' };

  		this.type = 'MeshMatcapMaterial';

  		this.color = new Color( 0xffffff ); // diffuse

  		this.matcap = null;

  		this.map = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.alphaMap = null;

  		this.flatShading = false;

  		this.fog = true;

  		this.setValues( parameters );

  	}


  	copy( source ) {

  		super.copy( source );

  		this.defines = { 'MATCAP': '' };

  		this.color.copy( source.color );

  		this.matcap = source.matcap;

  		this.map = source.map;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.alphaMap = source.alphaMap;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  class LineDashedMaterial extends LineBasicMaterial {

  	constructor( parameters ) {

  		super();

  		this.isLineDashedMaterial = true;

  		this.type = 'LineDashedMaterial';

  		this.scale = 1;
  		this.dashSize = 3;
  		this.gapSize = 1;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.scale = source.scale;
  		this.dashSize = source.dashSize;
  		this.gapSize = source.gapSize;

  		return this;

  	}

  }

  class Light extends Object3D {

  	constructor( color, intensity = 1 ) {

  		super();

  		this.isLight = true;

  		this.type = 'Light';

  		this.color = new Color( color );
  		this.intensity = intensity;

  	}

  	dispose() {

  		// Empty here in base class; some subclasses override.

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.color.copy( source.color );
  		this.intensity = source.intensity;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.color = this.color.getHex();
  		data.object.intensity = this.intensity;

  		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

  		if ( this.distance !== undefined ) data.object.distance = this.distance;
  		if ( this.angle !== undefined ) data.object.angle = this.angle;
  		if ( this.decay !== undefined ) data.object.decay = this.decay;
  		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

  		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
  		if ( this.target !== undefined ) data.object.target = this.target.uuid;

  		return data;

  	}

  }

  class HemisphereLight extends Light {

  	constructor( skyColor, groundColor, intensity ) {

  		super( skyColor, intensity );

  		this.isHemisphereLight = true;

  		this.type = 'HemisphereLight';

  		this.position.copy( Object3D.DEFAULT_UP );
  		this.updateMatrix();

  		this.groundColor = new Color( groundColor );

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.groundColor.copy( source.groundColor );

  		return this;

  	}

  }

  const _projScreenMatrix$2 = /*@__PURE__*/ new Matrix4();
  const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
  const _lookTarget$1 = /*@__PURE__*/ new Vector3();

  class LightShadow {

  	constructor( camera ) {

  		this.camera = camera;

  		this.intensity = 1;

  		this.bias = 0;
  		this.normalBias = 0;
  		this.radius = 1;
  		this.blurSamples = 8;

  		this.mapSize = new Vector2( 512, 512 );

  		this.map = null;
  		this.mapPass = null;
  		this.matrix = new Matrix4();

  		this.autoUpdate = true;
  		this.needsUpdate = false;

  		this._frustum = new Frustum();
  		this._frameExtents = new Vector2( 1, 1 );

  		this._viewportCount = 1;

  		this._viewports = [

  			new Vector4( 0, 0, 1, 1 )

  		];

  	}

  	getViewportCount() {

  		return this._viewportCount;

  	}

  	getFrustum() {

  		return this._frustum;

  	}

  	updateMatrices( light ) {

  		const shadowCamera = this.camera;
  		const shadowMatrix = this.matrix;

  		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
  		shadowCamera.position.copy( _lightPositionWorld$1 );

  		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
  		shadowCamera.lookAt( _lookTarget$1 );
  		shadowCamera.updateMatrixWorld();

  		_projScreenMatrix$2.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
  		this._frustum.setFromProjectionMatrix( _projScreenMatrix$2 );

  		shadowMatrix.set(
  			0.5, 0.0, 0.0, 0.5,
  			0.0, 0.5, 0.0, 0.5,
  			0.0, 0.0, 0.5, 0.5,
  			0.0, 0.0, 0.0, 1.0
  		);

  		shadowMatrix.multiply( _projScreenMatrix$2 );

  	}

  	getViewport( viewportIndex ) {

  		return this._viewports[ viewportIndex ];

  	}

  	getFrameExtents() {

  		return this._frameExtents;

  	}

  	dispose() {

  		if ( this.map ) {

  			this.map.dispose();

  		}

  		if ( this.mapPass ) {

  			this.mapPass.dispose();

  		}

  	}

  	copy( source ) {

  		this.camera = source.camera.clone();

  		this.intensity = source.intensity;

  		this.bias = source.bias;
  		this.radius = source.radius;

  		this.mapSize.copy( source.mapSize );

  		return this;

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	toJSON() {

  		const object = {};

  		if ( this.intensity !== 1 ) object.intensity = this.intensity;
  		if ( this.bias !== 0 ) object.bias = this.bias;
  		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
  		if ( this.radius !== 1 ) object.radius = this.radius;
  		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

  		object.camera = this.camera.toJSON( false ).object;
  		delete object.camera.matrix;

  		return object;

  	}

  }

  class SpotLightShadow extends LightShadow {

  	constructor() {

  		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

  		this.isSpotLightShadow = true;

  		this.focus = 1;

  	}

  	updateMatrices( light ) {

  		const camera = this.camera;

  		const fov = RAD2DEG * 2 * light.angle * this.focus;
  		const aspect = this.mapSize.width / this.mapSize.height;
  		const far = light.distance || camera.far;

  		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

  			camera.fov = fov;
  			camera.aspect = aspect;
  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  		super.updateMatrices( light );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.focus = source.focus;

  		return this;

  	}

  }

  class SpotLight extends Light {

  	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {

  		super( color, intensity );

  		this.isSpotLight = true;

  		this.type = 'SpotLight';

  		this.position.copy( Object3D.DEFAULT_UP );
  		this.updateMatrix();

  		this.target = new Object3D();

  		this.distance = distance;
  		this.angle = angle;
  		this.penumbra = penumbra;
  		this.decay = decay;

  		this.map = null;

  		this.shadow = new SpotLightShadow();

  	}

  	get power() {

  		// compute the light's luminous power (in lumens) from its intensity (in candela)
  		// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
  		return this.intensity * Math.PI;

  	}

  	set power( power ) {

  		// set the light's intensity (in candela) from the desired luminous power (in lumens)
  		this.intensity = power / Math.PI;

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.distance = source.distance;
  		this.angle = source.angle;
  		this.penumbra = source.penumbra;
  		this.decay = source.decay;

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
  const _lightPositionWorld = /*@__PURE__*/ new Vector3();
  const _lookTarget = /*@__PURE__*/ new Vector3();

  class PointLightShadow extends LightShadow {

  	constructor() {

  		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

  		this.isPointLightShadow = true;

  		this._frameExtents = new Vector2( 4, 2 );

  		this._viewportCount = 6;

  		this._viewports = [
  			// These viewports map a cube-map onto a 2D texture with the
  			// following orientation:
  			//
  			//  xzXZ
  			//   y Y
  			//
  			// X - Positive x direction
  			// x - Negative x direction
  			// Y - Positive y direction
  			// y - Negative y direction
  			// Z - Positive z direction
  			// z - Negative z direction

  			// positive X
  			new Vector4( 2, 1, 1, 1 ),
  			// negative X
  			new Vector4( 0, 1, 1, 1 ),
  			// positive Z
  			new Vector4( 3, 1, 1, 1 ),
  			// negative Z
  			new Vector4( 1, 1, 1, 1 ),
  			// positive Y
  			new Vector4( 3, 0, 1, 1 ),
  			// negative Y
  			new Vector4( 1, 0, 1, 1 )
  		];

  		this._cubeDirections = [
  			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
  			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
  		];

  		this._cubeUps = [
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
  		];

  	}

  	updateMatrices( light, viewportIndex = 0 ) {

  		const camera = this.camera;
  		const shadowMatrix = this.matrix;

  		const far = light.distance || camera.far;

  		if ( far !== camera.far ) {

  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
  		camera.position.copy( _lightPositionWorld );

  		_lookTarget.copy( camera.position );
  		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
  		camera.up.copy( this._cubeUps[ viewportIndex ] );
  		camera.lookAt( _lookTarget );
  		camera.updateMatrixWorld();

  		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

  		_projScreenMatrix$1.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

  	}

  }

  class PointLight extends Light {

  	constructor( color, intensity, distance = 0, decay = 2 ) {

  		super( color, intensity );

  		this.isPointLight = true;

  		this.type = 'PointLight';

  		this.distance = distance;
  		this.decay = decay;

  		this.shadow = new PointLightShadow();

  	}

  	get power() {

  		// compute the light's luminous power (in lumens) from its intensity (in candela)
  		// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
  		return this.intensity * 4 * Math.PI;

  	}

  	set power( power ) {

  		// set the light's intensity (in candela) from the desired luminous power (in lumens)
  		this.intensity = power / ( 4 * Math.PI );

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.distance = source.distance;
  		this.decay = source.decay;

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  class OrthographicCamera extends Camera {

  	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

  		super();

  		this.isOrthographicCamera = true;

  		this.type = 'OrthographicCamera';

  		this.zoom = 1;
  		this.view = null;

  		this.left = left;
  		this.right = right;
  		this.top = top;
  		this.bottom = bottom;

  		this.near = near;
  		this.far = far;

  		this.updateProjectionMatrix();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.left = source.left;
  		this.right = source.right;
  		this.top = source.top;
  		this.bottom = source.bottom;
  		this.near = source.near;
  		this.far = source.far;

  		this.zoom = source.zoom;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		return this;

  	}

  	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	}

  	clearViewOffset() {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	}

  	updateProjectionMatrix() {

  		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
  		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  		const cx = ( this.right + this.left ) / 2;
  		const cy = ( this.top + this.bottom ) / 2;

  		let left = cx - dx;
  		let right = cx + dx;
  		let top = cy + dy;
  		let bottom = cy - dy;

  		if ( this.view !== null && this.view.enabled ) {

  			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
  			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

  			left += scaleW * this.view.offsetX;
  			right = left + scaleW * this.view.width;
  			top -= scaleH * this.view.offsetY;
  			bottom = top - scaleH * this.view.height;

  		}

  		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );

  		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.zoom = this.zoom;
  		data.object.left = this.left;
  		data.object.right = this.right;
  		data.object.top = this.top;
  		data.object.bottom = this.bottom;
  		data.object.near = this.near;
  		data.object.far = this.far;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		return data;

  	}

  }

  class DirectionalLightShadow extends LightShadow {

  	constructor() {

  		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

  		this.isDirectionalLightShadow = true;

  	}

  }

  class DirectionalLight extends Light {

  	constructor( color, intensity ) {

  		super( color, intensity );

  		this.isDirectionalLight = true;

  		this.type = 'DirectionalLight';

  		this.position.copy( Object3D.DEFAULT_UP );
  		this.updateMatrix();

  		this.target = new Object3D();

  		this.shadow = new DirectionalLightShadow();

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source ) {

  		super.copy( source );

  		this.target = source.target.clone();
  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  class AmbientLight extends Light {

  	constructor( color, intensity ) {

  		super( color, intensity );

  		this.isAmbientLight = true;

  		this.type = 'AmbientLight';

  	}

  }

  class RectAreaLight extends Light {

  	constructor( color, intensity, width = 10, height = 10 ) {

  		super( color, intensity );

  		this.isRectAreaLight = true;

  		this.type = 'RectAreaLight';

  		this.width = width;
  		this.height = height;

  	}

  	get power() {

  		// compute the light's luminous power (in lumens) from its intensity (in nits)
  		return this.intensity * this.width * this.height * Math.PI;

  	}

  	set power( power ) {

  		// set the light's intensity (in nits) from the desired luminous power (in lumens)
  		this.intensity = power / ( this.width * this.height * Math.PI );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.width = source.width;
  		this.height = source.height;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.width = this.width;
  		data.object.height = this.height;

  		return data;

  	}

  }

  /**
   * Primary reference:
   *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
   *
   * Secondary reference:
   *   https://www.ppsloan.org/publications/StupidSH36.pdf
   */

  // 3-band SH defined by 9 coefficients

  class SphericalHarmonics3 {

  	constructor() {

  		this.isSphericalHarmonics3 = true;

  		this.coefficients = [];

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients.push( new Vector3() );

  		}

  	}

  	set( coefficients ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].copy( coefficients[ i ] );

  		}

  		return this;

  	}

  	zero() {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].set( 0, 0, 0 );

  		}

  		return this;

  	}

  	// get the radiance in the direction of the normal
  	// target is a Vector3
  	getAt( normal, target ) {

  		// normal is assumed to be unit length

  		const x = normal.x, y = normal.y, z = normal.z;

  		const coeff = this.coefficients;

  		// band 0
  		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

  		// band 1
  		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
  		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
  		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

  		// band 2
  		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
  		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
  		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
  		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
  		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

  		return target;

  	}

  	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  	// target is a Vector3
  	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
  	getIrradianceAt( normal, target ) {

  		// normal is assumed to be unit length

  		const x = normal.x, y = normal.y, z = normal.z;

  		const coeff = this.coefficients;

  		// band 0
  		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

  		// band 1
  		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
  		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
  		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

  		// band 2
  		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
  		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
  		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
  		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
  		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

  		return target;

  	}

  	add( sh ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].add( sh.coefficients[ i ] );

  		}

  		return this;

  	}

  	addScaledSH( sh, s ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

  		}

  		return this;

  	}

  	scale( s ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].multiplyScalar( s );

  		}

  		return this;

  	}

  	lerp( sh, alpha ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

  		}

  		return this;

  	}

  	equals( sh ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	copy( sh ) {

  		return this.set( sh.coefficients );

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  	fromArray( array, offset = 0 ) {

  		const coefficients = this.coefficients;

  		for ( let i = 0; i < 9; i ++ ) {

  			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

  		}

  		return this;

  	}

  	toArray( array = [], offset = 0 ) {

  		const coefficients = this.coefficients;

  		for ( let i = 0; i < 9; i ++ ) {

  			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

  		}

  		return array;

  	}

  	// evaluate the basis functions
  	// shBasis is an Array[ 9 ]
  	static getBasisAt( normal, shBasis ) {

  		// normal is assumed to be unit length

  		const x = normal.x, y = normal.y, z = normal.z;

  		// band 0
  		shBasis[ 0 ] = 0.282095;

  		// band 1
  		shBasis[ 1 ] = 0.488603 * y;
  		shBasis[ 2 ] = 0.488603 * z;
  		shBasis[ 3 ] = 0.488603 * x;

  		// band 2
  		shBasis[ 4 ] = 1.092548 * x * y;
  		shBasis[ 5 ] = 1.092548 * y * z;
  		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
  		shBasis[ 7 ] = 1.092548 * x * z;
  		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

  	}

  }

  class LightProbe extends Light {

  	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

  		super( undefined, intensity );

  		this.isLightProbe = true;

  		this.sh = sh;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.sh.copy( source.sh );

  		return this;

  	}

  	fromJSON( json ) {

  		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
  		this.sh.fromArray( json.sh );

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.sh = this.sh.toArray();

  		return data;

  	}

  }

  class InstancedInterleavedBuffer extends InterleavedBuffer {

  	constructor( array, stride, meshPerAttribute = 1 ) {

  		super( array, stride );

  		this.isInstancedInterleavedBuffer = true;

  		this.meshPerAttribute = meshPerAttribute;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  	clone( data ) {

  		const ib = super.clone( data );

  		ib.meshPerAttribute = this.meshPerAttribute;

  		return ib;

  	}

  	toJSON( data ) {

  		const json = super.toJSON( data );

  		json.isInstancedInterleavedBuffer = true;
  		json.meshPerAttribute = this.meshPerAttribute;

  		return json;

  	}

  }

  const refreshUniforms = [
  	'alphaMap',
  	'alphaTest',
  	'anisotropy',
  	'anisotropyMap',
  	'anisotropyRotation',
  	'aoMap',
  	'attenuationColor',
  	'attenuationDistance',
  	'bumpMap',
  	'clearcoat',
  	'clearcoatMap',
  	'clearcoatNormalMap',
  	'clearcoatNormalScale',
  	'clearcoatRoughness',
  	'color',
  	'dispersion',
  	'displacementMap',
  	'emissive',
  	'emissiveMap',
  	'envMap',
  	'gradientMap',
  	'ior',
  	'iridescence',
  	'iridescenceIOR',
  	'iridescenceMap',
  	'iridescenceThicknessMap',
  	'lightMap',
  	'map',
  	'matcap',
  	'metalness',
  	'metalnessMap',
  	'normalMap',
  	'normalScale',
  	'opacity',
  	'roughness',
  	'roughnessMap',
  	'sheen',
  	'sheenColor',
  	'sheenColorMap',
  	'sheenRoughnessMap',
  	'shininess',
  	'specular',
  	'specularColor',
  	'specularColorMap',
  	'specularIntensity',
  	'specularIntensityMap',
  	'specularMap',
  	'thickness',
  	'transmission',
  	'transmissionMap'
  ];

  class NodeMaterialObserver {

  	constructor( builder ) {

  		this.renderObjects = new WeakMap();
  		this.hasNode = this.containsNode( builder );
  		this.hasAnimation = builder.object.isSkinnedMesh === true;
  		this.refreshUniforms = refreshUniforms;
  		this.renderId = 0;

  	}

  	firstInitialization( renderObject ) {

  		const hasInitialized = this.renderObjects.has( renderObject );

  		if ( hasInitialized === false ) {

  			this.getRenderObjectData( renderObject );

  			return true;

  		}

  		return false;

  	}

  	getRenderObjectData( renderObject ) {

  		let data = this.renderObjects.get( renderObject );

  		if ( data === undefined ) {

  			data = {
  				material: this.getMaterialData( renderObject.material ),
  				worldMatrix: renderObject.object.matrixWorld.clone()
  			};

  			if ( renderObject.object.center ) {

  				data.center = renderObject.object.center.clone();

  			}

  			if ( renderObject.object.morphTargetInfluences ) {

  				data.morphTargetInfluences = renderObject.object.morphTargetInfluences.slice();

  			}

  			if ( renderObject.bundle !== null ) {

  				data.version = renderObject.bundle.version;

  			}

  			this.renderObjects.set( renderObject, data );

  		}

  		return data;

  	}

  	containsNode( builder ) {

  		const material = builder.material;

  		for ( const property in material ) {

  			if ( material[ property ] && material[ property ].isNode )
  				return true;

  		}

  		if ( builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null )
  			return true;

  		return false;

  	}

  	getMaterialData( material ) {

  		const data = {};

  		for ( const property of this.refreshUniforms ) {

  			const value = material[ property ];

  			if ( value === null || value === undefined ) continue;

  			if ( typeof value === 'object' && value.clone !== undefined ) {

  				if ( value.isTexture === true ) {

  					data[ property ] = { id: value.id, version: value.version };

  				} else {

  					data[ property ] = value.clone();

  				}

  			} else {

  				data[ property ] = value;

  			}

  		}

  		return data;

  	}

  	equals( renderObject ) {

  		const { object, material } = renderObject;

  		const renderObjectData = this.getRenderObjectData( renderObject );

  		// world matrix

  		if ( renderObjectData.worldMatrix.equals( object.matrixWorld ) !== true ) {

  			renderObjectData.worldMatrix.copy( object.matrixWorld );

  			return false;

  		}

  		// material

  		const materialData = renderObjectData.material;

  		for ( const property in materialData ) {

  			const value = materialData[ property ];
  			const mtlValue = material[ property ];

  			if ( value.equals !== undefined ) {

  				if ( value.equals( mtlValue ) === false ) {

  					value.copy( mtlValue );

  					return false;

  				}

  			} else if ( mtlValue.isTexture === true ) {

  				if ( value.id !== mtlValue.id || value.version !== mtlValue.version ) {

  					value.id = mtlValue.id;
  					value.version = mtlValue.version;

  					return false;

  				}

  			} else if ( value !== mtlValue ) {

  				materialData[ property ] = mtlValue;

  				return false;

  			}

  		}

  		// morph targets

  		if ( renderObjectData.morphTargetInfluences ) {

  			let morphChanged = false;

  			for ( let i = 0; i < renderObjectData.morphTargetInfluences.length; i ++ ) {

  				if ( renderObjectData.morphTargetInfluences[ i ] !== object.morphTargetInfluences[ i ] ) {

  					morphChanged = true;

  				}

  			}

  			if ( morphChanged ) return true;

  		}

  		// center

  		if ( renderObjectData.center ) {

  			if ( renderObjectData.center.equals( object.center ) === false ) {

  				renderObjectData.center.copy( object.center );

  				return true;

  			}

  		}

  		// bundle

  		if ( renderObject.bundle !== null ) {

  			renderObjectData.version = renderObject.bundle.version;

  		}

  		return true;

  	}

  	needsRefresh( renderObject, nodeFrame ) {

  		if ( this.hasNode || this.hasAnimation || this.firstInitialization( renderObject ) )
  			return true;

  		const { renderId } = nodeFrame;

  		if ( this.renderId !== renderId ) {

  			this.renderId = renderId;

  			return true;

  		}

  		const isStatic = renderObject.object.static === true;
  		const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData( renderObject ).version === renderObject.bundle.version;

  		if ( isStatic || isBundle )
  			return false;

  		const notEqual = this.equals( renderObject ) !== true;

  		return notEqual;

  	}

  }

  // cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.
  // A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.
  // Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
  // See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480
  // https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
  function cyrb53( value, seed = 0 ) {

  	let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;

  	if ( value instanceof Array ) {

  		for ( let i = 0, val; i < value.length; i ++ ) {

  			val = value[ i ];
  			h1 = Math.imul( h1 ^ val, 2654435761 );
  			h2 = Math.imul( h2 ^ val, 1597334677 );

  		}

  	} else {

  		for ( let i = 0, ch; i < value.length; i ++ ) {

  			ch = value.charCodeAt( i );
  			h1 = Math.imul( h1 ^ ch, 2654435761 );
  			h2 = Math.imul( h2 ^ ch, 1597334677 );

  		}

  	}

  	h1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 );
  	h1 ^= Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );
  	h2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 );
  	h2 ^= Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );

  	return 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );

  }

  const hashString = ( str ) => cyrb53( str );
  const hashArray = ( array ) => cyrb53( array );
  const hash$1 = ( ...params ) => cyrb53( params );

  function getCacheKey$1( object, force = false ) {

  	const values = [];

  	if ( object.isNode === true ) {

  		values.push( object.id );
  		object = object.getSelf();

  	}

  	for ( const { property, childNode } of getNodeChildren( object ) ) {

  		values.push( values, cyrb53( property.slice( 0, - 4 ) ), childNode.getCacheKey( force ) );

  	}

  	return cyrb53( values );

  }

  function* getNodeChildren( node, toJSON = false ) {

  	for ( const property in node ) {

  		// Ignore private properties.
  		if ( property.startsWith( '_' ) === true ) continue;

  		const object = node[ property ];

  		if ( Array.isArray( object ) === true ) {

  			for ( let i = 0; i < object.length; i ++ ) {

  				const child = object[ i ];

  				if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

  					yield { property, index: i, childNode: child };

  				}

  			}

  		} else if ( object && object.isNode === true ) {

  			yield { property, childNode: object };

  		} else if ( typeof object === 'object' ) {

  			for ( const subProperty in object ) {

  				const child = object[ subProperty ];

  				if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

  					yield { property, index: subProperty, childNode: child };

  				}

  			}

  		}

  	}

  }

  function getValueType( value ) {

  	if ( value === undefined || value === null ) return null;

  	const typeOf = typeof value;

  	if ( value.isNode === true ) {

  		return 'node';

  	} else if ( typeOf === 'number' ) {

  		return 'float';

  	} else if ( typeOf === 'boolean' ) {

  		return 'bool';

  	} else if ( typeOf === 'string' ) {

  		return 'string';

  	} else if ( typeOf === 'function' ) {

  		return 'shader';

  	} else if ( value.isVector2 === true ) {

  		return 'vec2';

  	} else if ( value.isVector3 === true ) {

  		return 'vec3';

  	} else if ( value.isVector4 === true ) {

  		return 'vec4';

  	} else if ( value.isMatrix3 === true ) {

  		return 'mat3';

  	} else if ( value.isMatrix4 === true ) {

  		return 'mat4';

  	} else if ( value.isColor === true ) {

  		return 'color';

  	} else if ( value instanceof ArrayBuffer ) {

  		return 'ArrayBuffer';

  	}

  	return null;

  }

  function getValueFromType( type, ...params ) {

  	const last4 = type ? type.slice( - 4 ) : undefined;

  	if ( params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()

  		if ( last4 === 'vec2' ) params = [ params[ 0 ], params[ 0 ] ];
  		else if ( last4 === 'vec3' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ] ];
  		else if ( last4 === 'vec4' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ], params[ 0 ] ];

  	}

  	if ( type === 'color' ) {

  		return new Color( ...params );

  	} else if ( last4 === 'vec2' ) {

  		return new Vector2( ...params );

  	} else if ( last4 === 'vec3' ) {

  		return new Vector3( ...params );

  	} else if ( last4 === 'vec4' ) {

  		return new Vector4( ...params );

  	} else if ( last4 === 'mat3' ) {

  		return new Matrix3( ...params );

  	} else if ( last4 === 'mat4' ) {

  		return new Matrix4( ...params );

  	} else if ( type === 'bool' ) {

  		return params[ 0 ] || false;

  	} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {

  		return params[ 0 ] || 0;

  	} else if ( type === 'string' ) {

  		return params[ 0 ] || '';

  	} else if ( type === 'ArrayBuffer' ) {

  		return base64ToArrayBuffer( params[ 0 ] );

  	}

  	return null;

  }

  function arrayBufferToBase64( arrayBuffer ) {

  	let chars = '';

  	const array = new Uint8Array( arrayBuffer );

  	for ( let i = 0; i < array.length; i ++ ) {

  		chars += String.fromCharCode( array[ i ] );

  	}

  	return btoa( chars );

  }

  function base64ToArrayBuffer( base64 ) {

  	return Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;

  }

  const NodeShaderStage = {
  	VERTEX: 'vertex',
  	FRAGMENT: 'fragment'
  };

  const NodeUpdateType = {
  	NONE: 'none',
  	FRAME: 'frame',
  	RENDER: 'render',
  	OBJECT: 'object'
  };

  const defaultShaderStages = [ 'fragment', 'vertex' ];
  const defaultBuildStages = [ 'setup', 'analyze', 'generate' ];
  const shaderStages = [ ...defaultShaderStages, 'compute' ];
  const vectorComponents = [ 'x', 'y', 'z', 'w' ];

  let _nodeId = 0;

  class Node extends EventDispatcher {

  	static get type() {

  		return 'Node';

  	}

  	constructor( nodeType = null ) {

  		super();

  		this.nodeType = nodeType;

  		this.updateType = NodeUpdateType.NONE;
  		this.updateBeforeType = NodeUpdateType.NONE;
  		this.updateAfterType = NodeUpdateType.NONE;

  		this.uuid = MathUtils.generateUUID();

  		this.version = 0;

  		this._cacheKey = null;
  		this._cacheKeyVersion = 0;

  		this.global = false;

  		this.isNode = true;

  		Object.defineProperty( this, 'id', { value: _nodeId ++ } );

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) {

  			this.version ++;

  		}

  	}

  	get type() {

  		return this.constructor.type;

  	}

  	onUpdate( callback, updateType ) {

  		this.updateType = updateType;
  		this.update = callback.bind( this.getSelf() );

  		return this;

  	}

  	onFrameUpdate( callback ) {

  		return this.onUpdate( callback, NodeUpdateType.FRAME );

  	}

  	onRenderUpdate( callback ) {

  		return this.onUpdate( callback, NodeUpdateType.RENDER );

  	}

  	onObjectUpdate( callback ) {

  		return this.onUpdate( callback, NodeUpdateType.OBJECT );

  	}

  	onReference( callback ) {

  		this.updateReference = callback.bind( this.getSelf() );

  		return this;

  	}

  	getSelf() {

  		// Returns non-node object.

  		return this.self || this;

  	}

  	updateReference( /*state*/ ) {

  		return this;

  	}

  	isGlobal( /*builder*/ ) {

  		return this.global;

  	}

  	* getChildren() {

  		for ( const { childNode } of getNodeChildren( this ) ) {

  			yield childNode;

  		}

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	traverse( callback ) {

  		callback( this );

  		for ( const childNode of this.getChildren() ) {

  			childNode.traverse( callback );

  		}

  	}

  	getCacheKey( force = false ) {

  		force = force || this.version !== this._cacheKeyVersion;

  		if ( force === true || this._cacheKey === null ) {

  			this._cacheKey = getCacheKey$1( this, force );
  			this._cacheKeyVersion = this.version;

  		}

  		return this._cacheKey;

  	}

  	getScope() {

  		return this;

  	}

  	getHash( /*builder*/ ) {

  		return this.uuid;

  	}

  	getUpdateType() {

  		return this.updateType;

  	}

  	getUpdateBeforeType() {

  		return this.updateBeforeType;

  	}

  	getUpdateAfterType() {

  		return this.updateAfterType;

  	}

  	getElementType( builder ) {

  		const type = this.getNodeType( builder );
  		const elementType = builder.getElementType( type );

  		return elementType;

  	}

  	getNodeType( builder ) {

  		const nodeProperties = builder.getNodeProperties( this );

  		if ( nodeProperties.outputNode ) {

  			return nodeProperties.outputNode.getNodeType( builder );

  		}

  		return this.nodeType;

  	}

  	getShared( builder ) {

  		const hash = this.getHash( builder );
  		const nodeFromHash = builder.getNodeFromHash( hash );

  		return nodeFromHash || this;

  	}

  	setup( builder ) {

  		const nodeProperties = builder.getNodeProperties( this );

  		let index = 0;

  		for ( const childNode of this.getChildren() ) {

  			nodeProperties[ 'node' + index ++ ] = childNode;

  		}

  		// return a outputNode if exists
  		return null;

  	}

  	analyze( builder ) {

  		const usageCount = builder.increaseUsage( this );

  		if ( usageCount === 1 ) {

  			// node flow children

  			const nodeProperties = builder.getNodeProperties( this );

  			for ( const childNode of Object.values( nodeProperties ) ) {

  				if ( childNode && childNode.isNode === true ) {

  					childNode.build( builder );

  				}

  			}

  		}

  	}

  	generate( builder, output ) {

  		const { outputNode } = builder.getNodeProperties( this );

  		if ( outputNode && outputNode.isNode === true ) {

  			return outputNode.build( builder, output );

  		}

  	}

  	updateBefore( /*frame*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	updateAfter( /*frame*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	update( /*frame*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	build( builder, output = null ) {

  		const refNode = this.getShared( builder );

  		if ( this !== refNode ) {

  			return refNode.build( builder, output );

  		}

  		builder.addNode( this );
  		builder.addChain( this );

  		/* Build stages expected results:
  			- "setup"		-> Node
  			- "analyze"		-> null
  			- "generate"	-> String
  		*/
  		let result = null;

  		const buildStage = builder.getBuildStage();

  		if ( buildStage === 'setup' ) {

  			this.updateReference( builder );

  			const properties = builder.getNodeProperties( this );

  			if ( properties.initialized !== true ) {

  				const stackNodesBeforeSetup = builder.stack.nodes.length;

  				properties.initialized = true;
  				properties.outputNode = this.setup( builder );

  				if ( properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup ) ;

  				for ( const childNode of Object.values( properties ) ) {

  					if ( childNode && childNode.isNode === true ) {

  						childNode.build( builder );

  					}

  				}

  			}

  		} else if ( buildStage === 'analyze' ) {

  			this.analyze( builder );

  		} else if ( buildStage === 'generate' ) {

  			const isGenerateOnce = this.generate.length === 1;

  			if ( isGenerateOnce ) {

  				const type = this.getNodeType( builder );
  				const nodeData = builder.getDataFromNode( this );

  				result = nodeData.snippet;

  				if ( result === undefined ) {

  					result = this.generate( builder ) || '';

  					nodeData.snippet = result;

  				} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {

  					builder.addFlowCodeHierarchy( this, builder.context.nodeBlock );

  				}

  				result = builder.format( result, type, output );

  			} else {

  				result = this.generate( builder, output ) || '';

  			}

  		}

  		builder.removeChain( this );

  		return result;

  	}

  	getSerializeChildren() {

  		return getNodeChildren( this );

  	}

  	serialize( json ) {

  		const nodeChildren = this.getSerializeChildren();

  		const inputNodes = {};

  		for ( const { property, index, childNode } of nodeChildren ) {

  			if ( index !== undefined ) {

  				if ( inputNodes[ property ] === undefined ) {

  					inputNodes[ property ] = Number.isInteger( index ) ? [] : {};

  				}

  				inputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;

  			} else {

  				inputNodes[ property ] = childNode.toJSON( json.meta ).uuid;

  			}

  		}

  		if ( Object.keys( inputNodes ).length > 0 ) {

  			json.inputNodes = inputNodes;

  		}

  	}

  	deserialize( json ) {

  		if ( json.inputNodes !== undefined ) {

  			const nodes = json.meta.nodes;

  			for ( const property in json.inputNodes ) {

  				if ( Array.isArray( json.inputNodes[ property ] ) ) {

  					const inputArray = [];

  					for ( const uuid of json.inputNodes[ property ] ) {

  						inputArray.push( nodes[ uuid ] );

  					}

  					this[ property ] = inputArray;

  				} else if ( typeof json.inputNodes[ property ] === 'object' ) {

  					const inputObject = {};

  					for ( const subProperty in json.inputNodes[ property ] ) {

  						const uuid = json.inputNodes[ property ][ subProperty ];

  						inputObject[ subProperty ] = nodes[ uuid ];

  					}

  					this[ property ] = inputObject;

  				} else {

  					const uuid = json.inputNodes[ property ];

  					this[ property ] = nodes[ uuid ];

  				}

  			}

  		}

  	}

  	toJSON( meta ) {

  		const { uuid, type } = this;
  		const isRoot = ( meta === undefined || typeof meta === 'string' );

  		if ( isRoot ) {

  			meta = {
  				textures: {},
  				images: {},
  				nodes: {}
  			};

  		}

  		// serialize

  		let data = meta.nodes[ uuid ];

  		if ( data === undefined ) {

  			data = {
  				uuid,
  				type,
  				meta,
  				metadata: {
  					version: 4.6,
  					type: 'Node',
  					generator: 'Node.toJSON'
  				}
  			};

  			if ( isRoot !== true ) meta.nodes[ data.uuid ] = data;

  			this.serialize( data );

  			delete data.meta;

  		}

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			const values = [];

  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRoot ) {

  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );
  			const nodes = extractFromCache( meta.nodes );

  			if ( textures.length > 0 ) data.textures = textures;
  			if ( images.length > 0 ) data.images = images;
  			if ( nodes.length > 0 ) data.nodes = nodes;

  		}

  		return data;

  	}

  }

  class ArrayElementNode extends Node {

  	static get type() {

  		return 'ArrayElementNode';

  	} // @TODO: If extending from TempNode it breaks webgpu_compute

  	constructor( node, indexNode ) {

  		super();

  		this.node = node;
  		this.indexNode = indexNode;

  		this.isArrayElementNode = true;

  	}

  	getNodeType( builder ) {

  		return this.node.getElementType( builder );

  	}

  	generate( builder ) {

  		const nodeSnippet = this.node.build( builder );
  		const indexSnippet = this.indexNode.build( builder, 'uint' );

  		return `${nodeSnippet}[ ${indexSnippet} ]`;

  	}

  }

  class ConvertNode extends Node {

  	static get type() {

  		return 'ConvertNode';

  	}

  	constructor( node, convertTo ) {

  		super();

  		this.node = node;
  		this.convertTo = convertTo;

  	}

  	getNodeType( builder ) {

  		const requestType = this.node.getNodeType( builder );

  		let convertTo = null;

  		for ( const overloadingType of this.convertTo.split( '|' ) ) {

  			if ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {

  				convertTo = overloadingType;

  			}

  		}

  		return convertTo;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.convertTo = this.convertTo;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.convertTo = data.convertTo;

  	}

  	generate( builder, output ) {

  		const node = this.node;
  		const type = this.getNodeType( builder );

  		const snippet = node.build( builder, type );

  		return builder.format( snippet, type, output );

  	}

  }

  class TempNode extends Node {

  	static get type() {

  		return 'TempNode';

  	}

  	constructor( type ) {

  		super( type );

  		this.isTempNode = true;

  	}

  	hasDependencies( builder ) {

  		return builder.getDataFromNode( this ).usageCount > 1;

  	}

  	build( builder, output ) {

  		const buildStage = builder.getBuildStage();

  		if ( buildStage === 'generate' ) {

  			const type = builder.getVectorType( this.getNodeType( builder, output ) );
  			const nodeData = builder.getDataFromNode( this );

  			if ( nodeData.propertyName !== undefined ) {

  				return builder.format( nodeData.propertyName, type, output );

  			} else if ( type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {

  				const snippet = super.build( builder, type );

  				const nodeVar = builder.getVarFromNode( this, null, type );
  				const propertyName = builder.getPropertyName( nodeVar );

  				builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

  				nodeData.snippet = snippet;
  				nodeData.propertyName = propertyName;

  				return builder.format( nodeData.propertyName, type, output );

  			}

  		}

  		return super.build( builder, output );

  	}

  }

  class JoinNode extends TempNode {

  	static get type() {

  		return 'JoinNode';

  	}

  	constructor( nodes = [], nodeType = null ) {

  		super( nodeType );

  		this.nodes = nodes;

  	}

  	getNodeType( builder ) {

  		if ( this.nodeType !== null ) {

  			return builder.getVectorType( this.nodeType );

  		}

  		return builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );

  	}

  	generate( builder, output ) {

  		const type = this.getNodeType( builder );
  		const nodes = this.nodes;

  		const primitiveType = builder.getComponentType( type );

  		const snippetValues = [];

  		for ( const input of nodes ) {

  			let inputSnippet = input.build( builder );

  			const inputPrimitiveType = builder.getComponentType( input.getNodeType( builder ) );

  			if ( inputPrimitiveType !== primitiveType ) {

  				inputSnippet = builder.format( inputSnippet, inputPrimitiveType, primitiveType );

  			}

  			snippetValues.push( inputSnippet );

  		}

  		const snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;

  		return builder.format( snippet, type, output );

  	}

  }

  const stringVectorComponents = vectorComponents.join( '' );

  class SplitNode extends Node {

  	static get type() {

  		return 'SplitNode';

  	}

  	constructor( node, components = 'x' ) {

  		super();

  		this.node = node;
  		this.components = components;

  		this.isSplitNode = true;

  	}

  	getVectorLength() {

  		let vectorLength = this.components.length;

  		for ( const c of this.components ) {

  			vectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );

  		}

  		return vectorLength;

  	}

  	getComponentType( builder ) {

  		return builder.getComponentType( this.node.getNodeType( builder ) );

  	}

  	getNodeType( builder ) {

  		return builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );

  	}

  	generate( builder, output ) {

  		const node = this.node;
  		const nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );

  		let snippet = null;

  		if ( nodeTypeLength > 1 ) {

  			let type = null;

  			const componentsLength = this.getVectorLength();

  			if ( componentsLength >= nodeTypeLength ) {

  				// needed expand the input node

  				type = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );

  			}

  			const nodeSnippet = node.build( builder, type );

  			if ( this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice( 0, this.components.length ) ) {

  				// unnecessary swizzle

  				snippet = builder.format( nodeSnippet, type, output );

  			} else {

  				snippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );

  			}

  		} else {

  			// ignore .components if .node returns float/integer

  			snippet = node.build( builder, output );

  		}

  		return snippet;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.components = this.components;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.components = data.components;

  	}

  }

  class SetNode extends TempNode {

  	static get type() {

  		return 'SetNode';

  	}

  	constructor( sourceNode, components, targetNode ) {

  		super();

  		this.sourceNode = sourceNode;
  		this.components = components;
  		this.targetNode = targetNode;

  	}

  	getNodeType( builder ) {

  		return this.sourceNode.getNodeType( builder );

  	}

  	generate( builder ) {

  		const { sourceNode, components, targetNode } = this;

  		const sourceType = this.getNodeType( builder );
  		const targetType = builder.getTypeFromLength( components.length, targetNode.getNodeType( builder ) );

  		const targetSnippet = targetNode.build( builder, targetType );
  		const sourceSnippet = sourceNode.build( builder, sourceType );

  		const length = builder.getTypeLength( sourceType );
  		const snippetValues = [];

  		for ( let i = 0; i < length; i ++ ) {

  			const component = vectorComponents[ i ];

  			if ( component === components[ 0 ] ) {

  				snippetValues.push( targetSnippet );

  				i += components.length - 1;

  			} else {

  				snippetValues.push( sourceSnippet + '.' + component );

  			}

  		}

  		return `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;

  	}

  }

  class FlipNode extends TempNode {

  	static get type() {

  		return 'FlipNode';

  	}

  	constructor( sourceNode, components ) {

  		super();

  		this.sourceNode = sourceNode;
  		this.components = components;

  	}

  	getNodeType( builder ) {

  		return this.sourceNode.getNodeType( builder );

  	}

  	generate( builder ) {

  		const { components, sourceNode } = this;

  		const sourceType = this.getNodeType( builder );
  		const sourceSnippet = sourceNode.build( builder );

  		const sourceCache = builder.getVarFromNode( this );
  		const sourceProperty = builder.getPropertyName( sourceCache );

  		builder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );

  		const length = builder.getTypeLength( sourceType );
  		const snippetValues = [];

  		let componentIndex = 0;

  		for ( let i = 0; i < length; i ++ ) {

  			const component = vectorComponents[ i ];

  			if ( component === components[ componentIndex ] ) {

  				snippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );

  				componentIndex ++;

  			} else {

  				snippetValues.push( sourceProperty + '.' + component );

  			}

  		}

  		return `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;

  	}

  }

  class InputNode extends Node {

  	static get type() {

  		return 'InputNode';

  	}

  	constructor( value, nodeType = null ) {

  		super( nodeType );

  		this.isInputNode = true;

  		this.value = value;
  		this.precision = null;

  	}

  	getNodeType( /*builder*/ ) {

  		if ( this.nodeType === null ) {

  			return getValueType( this.value );

  		}

  		return this.nodeType;

  	}

  	getInputType( builder ) {

  		return this.getNodeType( builder );

  	}

  	setPrecision( precision ) {

  		this.precision = precision;

  		return this;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.value = this.value;

  		if ( this.value && this.value.toArray ) data.value = this.value.toArray();

  		data.valueType = getValueType( this.value );
  		data.nodeType = this.nodeType;

  		if ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );

  		data.precision = this.precision;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.nodeType = data.nodeType;
  		this.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;

  		this.precision = data.precision || null;

  		if ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );

  	}

  	generate( /*builder, output*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  }

  class ConstNode extends InputNode {

  	static get type() {

  		return 'ConstNode';

  	}

  	constructor( value, nodeType = null ) {

  		super( value, nodeType );

  		this.isConstNode = true;

  	}

  	generateConst( builder ) {

  		return builder.generateConst( this.getNodeType( builder ), this.value );

  	}

  	generate( builder, output ) {

  		const type = this.getNodeType( builder );

  		return builder.format( this.generateConst( builder ), type, output );

  	}

  }

  //

  let currentStack = null;

  const NodeElements = new Map();

  function addMethodChaining( name, nodeElement ) {

  	if ( NodeElements.has( name ) ) {

  		console.warn( `Redefinition of method chaining ${ name }` );
  		return;

  	}

  	if ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );

  	NodeElements.set( name, nodeElement );

  }

  const parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );
  const parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );

  const shaderNodeHandler = {

  	setup( NodeClosure, params ) {

  		const inputs = params.shift();

  		return NodeClosure( nodeObjects( inputs ), ...params );

  	},

  	get( node, prop, nodeObj ) {

  		if ( typeof prop === 'string' && node[ prop ] === undefined ) {

  			if ( node.isStackNode !== true && prop === 'assign' ) {

  				return ( ...params ) => {

  					currentStack.assign( nodeObj, ...params );

  					return nodeObj;

  				};

  			} else if ( NodeElements.has( prop ) ) {

  				const nodeElement = NodeElements.get( prop );

  				return node.isStackNode ? ( ...params ) => nodeObj.add( nodeElement( ...params ) ) : ( ...params ) => nodeElement( nodeObj, ...params );

  			} else if ( prop === 'self' ) {

  				return node;

  			} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {

  				const nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );

  				return node.isStackNode ? ( ...params ) => nodeObj.assign( params[ 0 ], nodeElement( ...params ) ) : ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );

  			} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {

  				// accessing properties ( swizzle )

  				prop = parseSwizzle( prop );

  				return nodeObject( new SplitNode( nodeObj, prop ) );

  			} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {

  				// set properties ( swizzle ) and sort to xyzw sequence

  				prop = parseSwizzleAndSort( prop.slice( 3 ).toLowerCase() );

  				return ( value ) => nodeObject( new SetNode( node, prop, value ) );

  			} else if ( /^flip[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {

  				// set properties ( swizzle ) and sort to xyzw sequence

  				prop = parseSwizzleAndSort( prop.slice( 4 ).toLowerCase() );

  				return () => nodeObject( new FlipNode( nodeObject( node ), prop ) );

  			} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {

  				// accessing property

  				if ( prop === 'width' ) prop = 'x';
  				else if ( prop === 'height' ) prop = 'y';
  				else if ( prop === 'depth' ) prop = 'z';

  				return nodeObject( new SplitNode( node, prop ) );

  			} else if ( /^\d+$/.test( prop ) === true ) {

  				// accessing array

  				return nodeObject( new ArrayElementNode( nodeObj, new ConstNode( Number( prop ), 'uint' ) ) );

  			}

  		}

  		return Reflect.get( node, prop, nodeObj );

  	},

  	set( node, prop, value, nodeObj ) {

  		if ( typeof prop === 'string' && node[ prop ] === undefined ) {

  			// setting properties

  			if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\d+$/.test( prop ) === true ) {

  				nodeObj[ prop ].assign( value );

  				return true;

  			}

  		}

  		return Reflect.set( node, prop, value, nodeObj );

  	}

  };

  const nodeObjectsCacheMap = new WeakMap();
  const nodeBuilderFunctionsCacheMap = new WeakMap();

  const ShaderNodeObject = function ( obj, altType = null ) {

  	const type = getValueType( obj );

  	if ( type === 'node' ) {

  		let nodeObject = nodeObjectsCacheMap.get( obj );

  		if ( nodeObject === undefined ) {

  			nodeObject = new Proxy( obj, shaderNodeHandler );

  			nodeObjectsCacheMap.set( obj, nodeObject );
  			nodeObjectsCacheMap.set( nodeObject, nodeObject );

  		}

  		return nodeObject;

  	} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {

  		return nodeObject( getConstNode( obj, altType ) );

  	} else if ( type === 'shader' ) {

  		return Fn( obj );

  	}

  	return obj;

  };

  const ShaderNodeObjects = function ( objects, altType = null ) {

  	for ( const name in objects ) {

  		objects[ name ] = nodeObject( objects[ name ], altType );

  	}

  	return objects;

  };

  const ShaderNodeArray = function ( array, altType = null ) {

  	const len = array.length;

  	for ( let i = 0; i < len; i ++ ) {

  		array[ i ] = nodeObject( array[ i ], altType );

  	}

  	return array;

  };

  const ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {

  	const assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );

  	if ( scope === null ) {

  		return ( ...params ) => {

  			return assignNode( new NodeClass( ...nodeArray( params ) ) );

  		};

  	} else if ( factor !== null ) {

  		factor = nodeObject( factor );

  		return ( ...params ) => {

  			return assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );

  		};

  	} else {

  		return ( ...params ) => {

  			return assignNode( new NodeClass( scope, ...nodeArray( params ) ) );

  		};

  	}

  };

  const ShaderNodeImmutable = function ( NodeClass, ...params ) {

  	return nodeObject( new NodeClass( ...nodeArray( params ) ) );

  };

  class ShaderCallNodeInternal extends Node {

  	constructor( shaderNode, inputNodes ) {

  		super();

  		this.shaderNode = shaderNode;
  		this.inputNodes = inputNodes;

  	}

  	getNodeType( builder ) {

  		return this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );

  	}

  	call( builder ) {

  		const { shaderNode, inputNodes } = this;

  		const properties = builder.getNodeProperties( shaderNode );
  		if ( properties.onceOutput ) return properties.onceOutput;

  		//

  		let result = null;

  		if ( shaderNode.layout ) {

  			let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );

  			if ( functionNodesCacheMap === undefined ) {

  				functionNodesCacheMap = new WeakMap();

  				nodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );

  			}

  			let functionNode = functionNodesCacheMap.get( shaderNode );

  			if ( functionNode === undefined ) {

  				functionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );

  				functionNodesCacheMap.set( shaderNode, functionNode );

  			}

  			if ( builder.currentFunctionNode !== null ) {

  				builder.currentFunctionNode.includes.push( functionNode );

  			}

  			result = nodeObject( functionNode.call( inputNodes ) );

  		} else {

  			const jsFunc = shaderNode.jsFunc;
  			const outputNode = inputNodes !== null ? jsFunc( inputNodes, builder ) : jsFunc( builder );

  			result = nodeObject( outputNode );

  		}

  		if ( shaderNode.once ) {

  			properties.onceOutput = result;

  		}

  		return result;

  	}

  	getOutputNode( builder ) {

  		const properties = builder.getNodeProperties( this );

  		if ( properties.outputNode === null ) {

  			properties.outputNode = this.setupOutput( builder );

  		}

  		return properties.outputNode;

  	}

  	setup( builder ) {

  		return this.getOutputNode( builder );

  	}

  	setupOutput( builder ) {

  		builder.addStack();

  		builder.stack.outputNode = this.call( builder );

  		return builder.removeStack();

  	}

  	generate( builder, output ) {

  		const outputNode = this.getOutputNode( builder );

  		return outputNode.build( builder, output );

  	}

  }

  class ShaderNodeInternal extends Node {

  	constructor( jsFunc, nodeType ) {

  		super( nodeType );

  		this.jsFunc = jsFunc;
  		this.layout = null;

  		this.global = true;

  		this.once = false;

  	}

  	setLayout( layout ) {

  		this.layout = layout;

  		return this;

  	}

  	call( inputs = null ) {

  		nodeObjects( inputs );

  		return nodeObject( new ShaderCallNodeInternal( this, inputs ) );

  	}

  	setup() {

  		return this.call();

  	}

  }

  const bools = [ false, true ];
  const uints = [ 0, 1, 2, 3 ];
  const ints = [ - 1, - 2 ];
  const floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];

  const boolsCacheMap = new Map();
  for ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );

  const uintsCacheMap = new Map();
  for ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );

  const intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );
  for ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );

  const floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );
  for ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );
  for ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );

  const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };

  const constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );

  const getConstNode = ( value, type ) => {

  	if ( constNodesCacheMap.has( value ) ) {

  		return constNodesCacheMap.get( value );

  	} else if ( value.isNode === true ) {

  		return value;

  	} else {

  		return new ConstNode( value, type );

  	}

  };

  const safeGetNodeType = ( node ) => {

  	try {

  		return node.getNodeType();

  	} catch ( _ ) {

  		return undefined;

  	}

  };

  const ConvertType = function ( type, cacheMap = null ) {

  	return ( ...params ) => {

  		if ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {

  			params = [ getValueFromType( type, ...params ) ];

  		}

  		if ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {

  			return nodeObject( cacheMap.get( params[ 0 ] ) );

  		}

  		if ( params.length === 1 ) {

  			const node = getConstNode( params[ 0 ], type );
  			if ( safeGetNodeType( node ) === type ) return nodeObject( node );
  			return nodeObject( new ConvertNode( node, type ) );

  		}

  		const nodes = params.map( param => getConstNode( param ) );
  		return nodeObject( new JoinNode( nodes, type ) );

  	};

  };

  // exports

  const defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function

  // utils

  const getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;

  // shader node base

  function ShaderNode( jsFunc, nodeType ) {

  	return new Proxy( new ShaderNodeInternal( jsFunc, nodeType ), shaderNodeHandler );

  }

  const nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );
  const nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );
  const nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );
  const nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );
  const nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );

  const Fn = ( jsFunc, nodeType ) => {

  	const shaderNode = new ShaderNode( jsFunc, nodeType );

  	const fn = ( ...params ) => {

  		let inputs;

  		nodeObjects( params );

  		if ( params[ 0 ] && params[ 0 ].isNode ) {

  			inputs = [ ...params ];

  		} else {

  			inputs = params[ 0 ];

  		}

  		return shaderNode.call( inputs );

  	};

  	fn.shaderNode = shaderNode;

  	fn.setLayout = ( layout ) => {

  		shaderNode.setLayout( layout );

  		return fn;

  	};

  	fn.once = () => {

  		shaderNode.once = true;

  		return fn;

  	};

  	return fn;

  };

  //

  addMethodChaining( 'toGlobal', ( node ) => {

  	node.global = true;

  	return node;

  } );

  //

  const setCurrentStack = ( stack ) => {

  	currentStack = stack;

  };

  const getCurrentStack = () => currentStack;

  const If = ( ...params ) => currentStack.If( ...params );

  function append( node ) {

  	if ( currentStack ) currentStack.add( node );

  	return node;

  }

  addMethodChaining( 'append', append );

  // types

  const color = new ConvertType( 'color' );

  const float = new ConvertType( 'float', cacheMaps.float );
  const int = new ConvertType( 'int', cacheMaps.ints );
  const uint = new ConvertType( 'uint', cacheMaps.uint );
  const bool = new ConvertType( 'bool', cacheMaps.bool );

  const vec2 = new ConvertType( 'vec2' );
  const ivec2 = new ConvertType( 'ivec2' );
  const uvec2 = new ConvertType( 'uvec2' );
  const bvec2 = new ConvertType( 'bvec2' );

  const vec3 = new ConvertType( 'vec3' );
  const ivec3 = new ConvertType( 'ivec3' );
  const uvec3 = new ConvertType( 'uvec3' );
  const bvec3 = new ConvertType( 'bvec3' );

  const vec4 = new ConvertType( 'vec4' );
  const ivec4 = new ConvertType( 'ivec4' );
  const uvec4 = new ConvertType( 'uvec4' );
  const bvec4 = new ConvertType( 'bvec4' );

  const mat2 = new ConvertType( 'mat2' );
  const mat3 = new ConvertType( 'mat3' );
  const mat4 = new ConvertType( 'mat4' );

  addMethodChaining( 'toColor', color );
  addMethodChaining( 'toFloat', float );
  addMethodChaining( 'toInt', int );
  addMethodChaining( 'toUint', uint );
  addMethodChaining( 'toBool', bool );
  addMethodChaining( 'toVec2', vec2 );
  addMethodChaining( 'toIVec2', ivec2 );
  addMethodChaining( 'toUVec2', uvec2 );
  addMethodChaining( 'toBVec2', bvec2 );
  addMethodChaining( 'toVec3', vec3 );
  addMethodChaining( 'toIVec3', ivec3 );
  addMethodChaining( 'toUVec3', uvec3 );
  addMethodChaining( 'toBVec3', bvec3 );
  addMethodChaining( 'toVec4', vec4 );
  addMethodChaining( 'toIVec4', ivec4 );
  addMethodChaining( 'toUVec4', uvec4 );
  addMethodChaining( 'toBVec4', bvec4 );
  addMethodChaining( 'toMat2', mat2 );
  addMethodChaining( 'toMat3', mat3 );
  addMethodChaining( 'toMat4', mat4 );

  // basic nodes

  const element = /*@__PURE__*/ nodeProxy( ArrayElementNode );
  const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );

  addMethodChaining( 'element', element );
  addMethodChaining( 'convert', convert );

  class UniformGroupNode extends Node {

  	static get type() {

  		return 'UniformGroupNode';

  	}

  	constructor( name, shared = false, order = 1 ) {

  		super( 'string' );

  		this.name = name;
  		this.version = 0;

  		this.shared = shared;
  		this.order = order;
  		this.isUniformGroup = true;

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.name = this.name;
  		data.version = this.version;
  		data.shared = this.shared;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.name = data.name;
  		this.version = data.version;
  		this.shared = data.shared;

  	}

  }

  const uniformGroup = ( name ) => new UniformGroupNode( name );
  const sharedUniformGroup = ( name, order = 0 ) => new UniformGroupNode( name, true, order );

  const frameGroup = /*@__PURE__*/ sharedUniformGroup( 'frame' );
  const renderGroup = /*@__PURE__*/ sharedUniformGroup( 'render' );
  const objectGroup = /*@__PURE__*/ uniformGroup( 'object' );

  class UniformNode extends InputNode {

  	static get type() {

  		return 'UniformNode';

  	}

  	constructor( value, nodeType = null ) {

  		super( value, nodeType );

  		this.isUniformNode = true;

  		this.name = '';
  		this.groupNode = objectGroup;

  	}

  	label( name ) {

  		this.name = name;

  		return this;

  	}

  	setGroup( group ) {

  		this.groupNode = group;

  		return this;

  	}

  	getGroup() {

  		return this.groupNode;

  	}

  	getUniformHash( builder ) {

  		return this.getHash( builder );

  	}

  	onUpdate( callback, updateType ) {

  		const self = this.getSelf();

  		callback = callback.bind( self );

  		return super.onUpdate( ( frame ) => {

  			const value = callback( frame, self );

  			if ( value !== undefined ) {

  				this.value = value;

  			}

  	 	}, updateType );

  	}

  	generate( builder, output ) {

  		const type = this.getNodeType( builder );

  		const hash = this.getUniformHash( builder );

  		let sharedNode = builder.getNodeFromHash( hash );

  		if ( sharedNode === undefined ) {

  			builder.setHashNode( this, hash );

  			sharedNode = this;

  		}

  		const sharedNodeType = sharedNode.getInputType( builder );

  		const nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label );
  		const propertyName = builder.getPropertyName( nodeUniform );

  		if ( builder.context.label !== undefined ) delete builder.context.label;

  		return builder.format( propertyName, type, output );

  	}

  }

  const uniform = ( arg1, arg2 ) => {

  	const nodeType = getConstNodeType( arg2 || arg1 );

  	// @TODO: get ConstNode from .traverse() in the future
  	const value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;

  	return nodeObject( new UniformNode( value, nodeType ) );

  };

  class PropertyNode extends Node {

  	static get type() {

  		return 'PropertyNode';

  	}

  	constructor( nodeType, name = null, varying = false ) {

  		super( nodeType );

  		this.name = name;
  		this.varying = varying;

  		this.isPropertyNode = true;

  	}

  	getHash( builder ) {

  		return this.name || super.getHash( builder );

  	}

  	isGlobal( /*builder*/ ) {

  		return true;

  	}

  	generate( builder ) {

  		let nodeVar;

  		if ( this.varying === true ) {

  			nodeVar = builder.getVaryingFromNode( this, this.name );
  			nodeVar.needsInterpolation = true;

  		} else {

  			nodeVar = builder.getVarFromNode( this, this.name );

  		}

  		return builder.getPropertyName( nodeVar );

  	}

  }

  const property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );
  const varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );

  const diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );
  const emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );
  const roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );
  const metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );
  const clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );
  const clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );
  const sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );
  const sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );
  const iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );
  const iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );
  const iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );
  const alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );
  const anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );
  const anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );
  const anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );
  const specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );
  const specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );
  const shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );
  const output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );
  const dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );
  const gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );
  const ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );
  const transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );
  const thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );
  const attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );
  const attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );
  const dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );

  class AssignNode extends TempNode {

  	static get type() {

  		return 'AssignNode';

  	}

  	constructor( targetNode, sourceNode ) {

  		super();

  		this.targetNode = targetNode;
  		this.sourceNode = sourceNode;

  	}

  	hasDependencies() {

  		return false;

  	}

  	getNodeType( builder, output ) {

  		return output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';

  	}

  	needsSplitAssign( builder ) {

  		const { targetNode } = this;

  		if ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {

  			const targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );
  			const assignDiferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;

  			return assignDiferentVector;

  		}

  		return false;

  	}

  	generate( builder, output ) {

  		const { targetNode, sourceNode } = this;

  		const needsSplitAssign = this.needsSplitAssign( builder );

  		const targetType = targetNode.getNodeType( builder );

  		const target = targetNode.context( { assign: true } ).build( builder );
  		const source = sourceNode.build( builder, targetType );

  		const sourceType = sourceNode.getNodeType( builder );

  		const nodeData = builder.getDataFromNode( this );

  		//

  		let snippet;

  		if ( nodeData.initialized === true ) {

  			if ( output !== 'void' ) {

  				snippet = target;

  			}

  		} else if ( needsSplitAssign ) {

  			const sourceVar = builder.getVarFromNode( this, null, targetType );
  			const sourceProperty = builder.getPropertyName( sourceVar );

  			builder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );

  			const targetRoot = targetNode.node.context( { assign: true } ).build( builder );

  			for ( let i = 0; i < targetNode.components.length; i ++ ) {

  				const component = targetNode.components[ i ];

  				builder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );

  			}

  			if ( output !== 'void' ) {

  				snippet = target;

  			}

  		} else {

  			snippet = `${ target } = ${ source }`;

  			if ( output === 'void' || sourceType === 'void' ) {

  				builder.addLineFlowCode( snippet, this );

  				if ( output !== 'void' ) {

  					snippet = target;

  				}

  			}

  		}

  		nodeData.initialized = true;

  		return builder.format( snippet, targetType, output );

  	}

  }

  const assign = /*@__PURE__*/ nodeProxy( AssignNode );

  addMethodChaining( 'assign', assign );

  class FunctionCallNode extends TempNode {

  	static get type() {

  		return 'FunctionCallNode';

  	}

  	constructor( functionNode = null, parameters = {} ) {

  		super();

  		this.functionNode = functionNode;
  		this.parameters = parameters;

  	}

  	setParameters( parameters ) {

  		this.parameters = parameters;

  		return this;

  	}

  	getParameters() {

  		return this.parameters;

  	}

  	getNodeType( builder ) {

  		return this.functionNode.getNodeType( builder );

  	}

  	generate( builder ) {

  		const params = [];

  		const functionNode = this.functionNode;

  		const inputs = functionNode.getInputs( builder );
  		const parameters = this.parameters;

  		if ( Array.isArray( parameters ) ) {

  			for ( let i = 0; i < parameters.length; i ++ ) {

  				const inputNode = inputs[ i ];
  				const node = parameters[ i ];

  				params.push( node.build( builder, inputNode.type ) );

  			}

  		} else {

  			for ( const inputNode of inputs ) {

  				const node = parameters[ inputNode.name ];

  				if ( node !== undefined ) {

  					params.push( node.build( builder, inputNode.type ) );

  				} else {

  					throw new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );

  				}

  			}

  		}

  		const functionName = functionNode.build( builder, 'property' );

  		return `${functionName}( ${params.join( ', ' )} )`;

  	}

  }

  const call = ( func, ...params ) => {

  	params = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );

  	return nodeObject( new FunctionCallNode( nodeObject( func ), params ) );

  };

  addMethodChaining( 'call', call );

  class OperatorNode extends TempNode {

  	static get type() {

  		return 'OperatorNode';

  	}

  	constructor( op, aNode, bNode, ...params ) {

  		super();

  		if ( params.length > 0 ) {

  			let finalOp = new OperatorNode( op, aNode, bNode );

  			for ( let i = 0; i < params.length - 1; i ++ ) {

  				finalOp = new OperatorNode( op, finalOp, params[ i ] );

  			}

  			aNode = finalOp;
  			bNode = params[ params.length - 1 ];

  		}

  		this.op = op;
  		this.aNode = aNode;
  		this.bNode = bNode;

  	}

  	getNodeType( builder, output ) {

  		const op = this.op;

  		const aNode = this.aNode;
  		const bNode = this.bNode;

  		const typeA = aNode.getNodeType( builder );
  		const typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;

  		if ( typeA === 'void' || typeB === 'void' ) {

  			return 'void';

  		} else if ( op === '%' ) {

  			return typeA;

  		} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {

  			return builder.getIntegerType( typeA );

  		} else if ( op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^' ) {

  			return 'bool';

  		} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {

  			const typeLength = output ? builder.getTypeLength( output ) : Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );

  			return typeLength > 1 ? `bvec${ typeLength }` : 'bool';

  		} else {

  			if ( typeA === 'float' && builder.isMatrix( typeB ) ) {

  				return typeB;

  			} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {

  				// matrix x vector

  				return builder.getVectorFromMatrix( typeA );

  			} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {

  				// vector x matrix

  				return builder.getVectorFromMatrix( typeB );

  			} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {

  				// anytype x anytype: use the greater length vector

  				return typeB;

  			}

  			return typeA;

  		}

  	}

  	generate( builder, output ) {

  		const op = this.op;

  		const aNode = this.aNode;
  		const bNode = this.bNode;

  		const type = this.getNodeType( builder, output );

  		let typeA = null;
  		let typeB = null;

  		if ( type !== 'void' ) {

  			typeA = aNode.getNodeType( builder );
  			typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;

  			if ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' ) {

  				if ( builder.isVector( typeA ) ) {

  					typeB = typeA;

  				} else if ( typeA !== typeB ) {

  					typeA = typeB = 'float';

  				}

  			} else if ( op === '>>' || op === '<<' ) {

  				typeA = type;
  				typeB = builder.changeComponentType( typeB, 'uint' );

  			} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {

  				// matrix x vector

  				typeB = builder.getVectorFromMatrix( typeA );

  			} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {

  				// vector x matrix

  				typeA = builder.getVectorFromMatrix( typeB );

  			} else {

  				// anytype x anytype

  				typeA = typeB = type;

  			}

  		} else {

  			typeA = typeB = type;

  		}

  		const a = aNode.build( builder, typeA );
  		const b = typeof bNode !== 'undefined' ? bNode.build( builder, typeB ) : null;

  		const outputLength = builder.getTypeLength( output );
  		const fnOpSnippet = builder.getFunctionOperator( op );

  		if ( output !== 'void' ) {

  			if ( op === '<' && outputLength > 1 ) {

  				if ( builder.useComparisonMethod ) {

  					return builder.format( `${ builder.getMethod( 'lessThan', output ) }( ${ a }, ${ b } )`, type, output );

  				} else {

  					return builder.format( `( ${ a } < ${ b } )`, type, output );

  				}

  			} else if ( op === '<=' && outputLength > 1 ) {

  				if ( builder.useComparisonMethod ) {

  					return builder.format( `${ builder.getMethod( 'lessThanEqual', output ) }( ${ a }, ${ b } )`, type, output );

  				} else {

  					return builder.format( `( ${ a } <= ${ b } )`, type, output );

  				}

  			} else if ( op === '>' && outputLength > 1 ) {

  				if ( builder.useComparisonMethod ) {

  					return builder.format( `${ builder.getMethod( 'greaterThan', output ) }( ${ a }, ${ b } )`, type, output );

  				} else {

  					return builder.format( `( ${ a } > ${ b } )`, type, output );

  				}

  			} else if ( op === '>=' && outputLength > 1 ) {

  				if ( builder.useComparisonMethod ) {

  					return builder.format( `${ builder.getMethod( 'greaterThanEqual', output ) }( ${ a }, ${ b } )`, type, output );

  				} else {

  					return builder.format( `( ${ a } >= ${ b } )`, type, output );

  				}

  			} else if ( op === '!' || op === '~' ) {

  				return builder.format( `(${op}${a})`, typeA, output );

  			} else if ( fnOpSnippet ) {

  				return builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );

  			} else {

  				return builder.format( `( ${ a } ${ op } ${ b } )`, type, output );

  			}

  		} else if ( typeA !== 'void' ) {

  			if ( fnOpSnippet ) {

  				return builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );

  			} else {

  				return builder.format( `${ a } ${ op } ${ b }`, type, output );

  			}

  		}

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.op = this.op;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.op = data.op;

  	}

  }

  const add = /*@__PURE__*/ nodeProxy( OperatorNode, '+' );
  const sub = /*@__PURE__*/ nodeProxy( OperatorNode, '-' );
  const mul = /*@__PURE__*/ nodeProxy( OperatorNode, '*' );
  const div = /*@__PURE__*/ nodeProxy( OperatorNode, '/' );
  const modInt = /*@__PURE__*/ nodeProxy( OperatorNode, '%' );
  const equal = /*@__PURE__*/ nodeProxy( OperatorNode, '==' );
  const notEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '!=' );
  const lessThan = /*@__PURE__*/ nodeProxy( OperatorNode, '<' );
  const greaterThan = /*@__PURE__*/ nodeProxy( OperatorNode, '>' );
  const lessThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '<=' );
  const greaterThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '>=' );
  const and = /*@__PURE__*/ nodeProxy( OperatorNode, '&&' );
  const or = /*@__PURE__*/ nodeProxy( OperatorNode, '||' );
  const not = /*@__PURE__*/ nodeProxy( OperatorNode, '!' );
  const xor = /*@__PURE__*/ nodeProxy( OperatorNode, '^^' );
  const bitAnd = /*@__PURE__*/ nodeProxy( OperatorNode, '&' );
  const bitNot = /*@__PURE__*/ nodeProxy( OperatorNode, '~' );
  const bitOr = /*@__PURE__*/ nodeProxy( OperatorNode, '|' );
  const bitXor = /*@__PURE__*/ nodeProxy( OperatorNode, '^' );
  const shiftLeft = /*@__PURE__*/ nodeProxy( OperatorNode, '<<' );
  const shiftRight = /*@__PURE__*/ nodeProxy( OperatorNode, '>>' );

  addMethodChaining( 'add', add );
  addMethodChaining( 'sub', sub );
  addMethodChaining( 'mul', mul );
  addMethodChaining( 'div', div );
  addMethodChaining( 'modInt', modInt );
  addMethodChaining( 'equal', equal );
  addMethodChaining( 'notEqual', notEqual );
  addMethodChaining( 'lessThan', lessThan );
  addMethodChaining( 'greaterThan', greaterThan );
  addMethodChaining( 'lessThanEqual', lessThanEqual );
  addMethodChaining( 'greaterThanEqual', greaterThanEqual );
  addMethodChaining( 'and', and );
  addMethodChaining( 'or', or );
  addMethodChaining( 'not', not );
  addMethodChaining( 'xor', xor );
  addMethodChaining( 'bitAnd', bitAnd );
  addMethodChaining( 'bitNot', bitNot );
  addMethodChaining( 'bitOr', bitOr );
  addMethodChaining( 'bitXor', bitXor );
  addMethodChaining( 'shiftLeft', shiftLeft );
  addMethodChaining( 'shiftRight', shiftRight );


  const remainder = ( ...params ) => { // @deprecated, r168

  	console.warn( 'TSL.OperatorNode: .remainder() has been renamed to .modInt().' );
  	return modInt( ...params );

  };

  addMethodChaining( 'remainder', remainder );

  class MathNode extends TempNode {

  	static get type() {

  		return 'MathNode';

  	}

  	constructor( method, aNode, bNode = null, cNode = null ) {

  		super();

  		this.method = method;

  		this.aNode = aNode;
  		this.bNode = bNode;
  		this.cNode = cNode;

  	}

  	getInputType( builder ) {

  		const aType = this.aNode.getNodeType( builder );
  		const bType = this.bNode ? this.bNode.getNodeType( builder ) : null;
  		const cType = this.cNode ? this.cNode.getNodeType( builder ) : null;

  		const aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );
  		const bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );
  		const cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );

  		if ( aLen > bLen && aLen > cLen ) {

  			return aType;

  		} else if ( bLen > cLen ) {

  			return bType;

  		} else if ( cLen > aLen ) {

  			return cType;

  		}

  		return aType;

  	}

  	getNodeType( builder ) {

  		const method = this.method;

  		if ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {

  			return 'float';

  		} else if ( method === MathNode.CROSS ) {

  			return 'vec3';

  		} else if ( method === MathNode.ALL ) {

  			return 'bool';

  		} else if ( method === MathNode.EQUALS ) {

  			return builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );

  		} else if ( method === MathNode.MOD ) {

  			return this.aNode.getNodeType( builder );

  		} else {

  			return this.getInputType( builder );

  		}

  	}

  	generate( builder, output ) {

  		const method = this.method;

  		const type = this.getNodeType( builder );
  		const inputType = this.getInputType( builder );

  		const a = this.aNode;
  		const b = this.bNode;
  		const c = this.cNode;

  		const isWebGL = builder.renderer.isWebGLRenderer === true;

  		if ( method === MathNode.TRANSFORM_DIRECTION ) {

  			// dir can be either a direction vector or a normal vector
  			// upper-left 3x3 of matrix is assumed to be orthogonal

  			let tA = a;
  			let tB = b;

  			if ( builder.isMatrix( tA.getNodeType( builder ) ) ) {

  				tB = vec4( vec3( tB ), 0.0 );

  			} else {

  				tA = vec4( vec3( tA ), 0.0 );

  			}

  			const mulNode = mul( tA, tB ).xyz;

  			return normalize( mulNode ).build( builder, output );

  		} else if ( method === MathNode.NEGATE ) {

  			return builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );

  		} else if ( method === MathNode.ONE_MINUS ) {

  			return sub( 1.0, a ).build( builder, output );

  		} else if ( method === MathNode.RECIPROCAL ) {

  			return div( 1.0, a ).build( builder, output );

  		} else if ( method === MathNode.DIFFERENCE ) {

  			return abs( sub( a, b ) ).build( builder, output );

  		} else {

  			const params = [];

  			if ( method === MathNode.CROSS || method === MathNode.MOD ) {

  				params.push(
  					a.build( builder, type ),
  					b.build( builder, type )
  				);

  			} else if ( isWebGL && method === MathNode.STEP ) {

  				params.push(
  					a.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),
  					b.build( builder, inputType )
  				);

  			} else if ( ( isWebGL && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {

  				params.push(
  					a.build( builder, inputType ),
  					b.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )
  				);

  			} else if ( method === MathNode.REFRACT ) {

  				params.push(
  					a.build( builder, inputType ),
  					b.build( builder, inputType ),
  					c.build( builder, 'float' )
  				);

  			} else if ( method === MathNode.MIX ) {

  				params.push(
  					a.build( builder, inputType ),
  					b.build( builder, inputType ),
  					c.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )
  				);

  			} else {

  				params.push( a.build( builder, inputType ) );
  				if ( b !== null ) params.push( b.build( builder, inputType ) );
  				if ( c !== null ) params.push( c.build( builder, inputType ) );

  			}

  			return builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );

  		}

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.method = this.method;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.method = data.method;

  	}

  }

  // 1 input

  MathNode.ALL = 'all';
  MathNode.ANY = 'any';
  MathNode.EQUALS = 'equals';

  MathNode.RADIANS = 'radians';
  MathNode.DEGREES = 'degrees';
  MathNode.EXP = 'exp';
  MathNode.EXP2 = 'exp2';
  MathNode.LOG = 'log';
  MathNode.LOG2 = 'log2';
  MathNode.SQRT = 'sqrt';
  MathNode.INVERSE_SQRT = 'inversesqrt';
  MathNode.FLOOR = 'floor';
  MathNode.CEIL = 'ceil';
  MathNode.NORMALIZE = 'normalize';
  MathNode.FRACT = 'fract';
  MathNode.SIN = 'sin';
  MathNode.COS = 'cos';
  MathNode.TAN = 'tan';
  MathNode.ASIN = 'asin';
  MathNode.ACOS = 'acos';
  MathNode.ATAN = 'atan';
  MathNode.ABS = 'abs';
  MathNode.SIGN = 'sign';
  MathNode.LENGTH = 'length';
  MathNode.NEGATE = 'negate';
  MathNode.ONE_MINUS = 'oneMinus';
  MathNode.DFDX = 'dFdx';
  MathNode.DFDY = 'dFdy';
  MathNode.ROUND = 'round';
  MathNode.RECIPROCAL = 'reciprocal';
  MathNode.TRUNC = 'trunc';
  MathNode.FWIDTH = 'fwidth';
  MathNode.BITCAST = 'bitcast';
  MathNode.TRANSPOSE = 'transpose';

  // 2 inputs

  MathNode.ATAN2 = 'atan2';
  MathNode.MIN = 'min';
  MathNode.MAX = 'max';
  MathNode.MOD = 'mod';
  MathNode.STEP = 'step';
  MathNode.REFLECT = 'reflect';
  MathNode.DISTANCE = 'distance';
  MathNode.DIFFERENCE = 'difference';
  MathNode.DOT = 'dot';
  MathNode.CROSS = 'cross';
  MathNode.POW = 'pow';
  MathNode.TRANSFORM_DIRECTION = 'transformDirection';

  // 3 inputs

  MathNode.MIX = 'mix';
  MathNode.CLAMP = 'clamp';
  MathNode.REFRACT = 'refract';
  MathNode.SMOOTHSTEP = 'smoothstep';
  MathNode.FACEFORWARD = 'faceforward';

  const EPSILON = /*@__PURE__*/ float( 1e-6 );
  const PI = /*@__PURE__*/ float( Math.PI );

  const all = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ALL );
  const any = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ANY );
  const equals = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EQUALS );

  const radians = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RADIANS );
  const degrees = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DEGREES );
  const exp = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP );
  const exp2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP2 );
  const log = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG );
  const log2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG2 );
  const sqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SQRT );
  const inverseSqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.INVERSE_SQRT );
  const floor = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FLOOR );
  const ceil = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CEIL );
  const normalize = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NORMALIZE );
  const fract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FRACT );
  const sin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIN );
  const cos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.COS );
  const tan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TAN );
  const asin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ASIN );
  const acos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ACOS );
  const atan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN );
  const abs = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ABS );
  const sign = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIGN );
  const length = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LENGTH );
  const negate = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NEGATE );
  const oneMinus = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ONE_MINUS );
  const dFdx = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDX );
  const dFdy = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDY );
  const round = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ROUND );
  const reciprocal = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RECIPROCAL );
  const trunc = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRUNC );
  const fwidth = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FWIDTH );
  /*@__PURE__*/ nodeProxy( MathNode, MathNode.BITCAST );
  const transpose = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSPOSE );

  const atan2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN2 );
  const min$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIN );
  const max$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MAX );
  const mod = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MOD );
  const step = /*@__PURE__*/ nodeProxy( MathNode, MathNode.STEP );
  const reflect = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFLECT );
  const distance = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DISTANCE );
  const difference = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DIFFERENCE );
  const dot = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DOT );
  const cross = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CROSS );
  const pow = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW );
  const pow2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 2 );
  const pow3 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 3 );
  const pow4 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 4 );
  const transformDirection = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );

  const cbrt = ( a ) => mul( sign( a ), pow( abs( a ), 1.0 / 3.0 ) );
  const lengthSq = ( a ) => dot( a, a );
  const mix$2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIX );
  const clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );
  const saturate$1 = ( value ) => clamp( value );
  const refract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFRACT );
  const smoothstep = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SMOOTHSTEP );
  const faceForward = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FACEFORWARD );

  const rand = /*@__PURE__*/ Fn( ( [ uv ] ) => {

  	const a = 12.9898, b = 78.233, c = 43758.5453;
  	const dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );

  	return fract( sin( sn ).mul( c ) );

  } );

  const mixElement = ( t, e1, e2 ) => mix$2( e1, e2, t );
  const smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );

  addMethodChaining( 'all', all );
  addMethodChaining( 'any', any );
  addMethodChaining( 'equals', equals );

  addMethodChaining( 'radians', radians );
  addMethodChaining( 'degrees', degrees );
  addMethodChaining( 'exp', exp );
  addMethodChaining( 'exp2', exp2 );
  addMethodChaining( 'log', log );
  addMethodChaining( 'log2', log2 );
  addMethodChaining( 'sqrt', sqrt );
  addMethodChaining( 'inverseSqrt', inverseSqrt );
  addMethodChaining( 'floor', floor );
  addMethodChaining( 'ceil', ceil );
  addMethodChaining( 'normalize', normalize );
  addMethodChaining( 'fract', fract );
  addMethodChaining( 'sin', sin );
  addMethodChaining( 'cos', cos );
  addMethodChaining( 'tan', tan );
  addMethodChaining( 'asin', asin );
  addMethodChaining( 'acos', acos );
  addMethodChaining( 'atan', atan );
  addMethodChaining( 'abs', abs );
  addMethodChaining( 'sign', sign );
  addMethodChaining( 'length', length );
  addMethodChaining( 'lengthSq', lengthSq );
  addMethodChaining( 'negate', negate );
  addMethodChaining( 'oneMinus', oneMinus );
  addMethodChaining( 'dFdx', dFdx );
  addMethodChaining( 'dFdy', dFdy );
  addMethodChaining( 'round', round );
  addMethodChaining( 'reciprocal', reciprocal );
  addMethodChaining( 'trunc', trunc );
  addMethodChaining( 'fwidth', fwidth );
  addMethodChaining( 'atan2', atan2 );
  addMethodChaining( 'min', min$1 );
  addMethodChaining( 'max', max$1 );
  addMethodChaining( 'mod', mod );
  addMethodChaining( 'step', step );
  addMethodChaining( 'reflect', reflect );
  addMethodChaining( 'distance', distance );
  addMethodChaining( 'dot', dot );
  addMethodChaining( 'cross', cross );
  addMethodChaining( 'pow', pow );
  addMethodChaining( 'pow2', pow2 );
  addMethodChaining( 'pow3', pow3 );
  addMethodChaining( 'pow4', pow4 );
  addMethodChaining( 'transformDirection', transformDirection );
  addMethodChaining( 'mix', mixElement );
  addMethodChaining( 'clamp', clamp );
  addMethodChaining( 'refract', refract );
  addMethodChaining( 'smoothstep', smoothstepElement );
  addMethodChaining( 'faceForward', faceForward );
  addMethodChaining( 'difference', difference );
  addMethodChaining( 'saturate', saturate$1 );
  addMethodChaining( 'cbrt', cbrt );
  addMethodChaining( 'transpose', transpose );
  addMethodChaining( 'rand', rand );

  class ConditionalNode extends Node {

  	static get type() {

  		return 'ConditionalNode';

  	}

  	constructor( condNode, ifNode, elseNode = null ) {

  		super();

  		this.condNode = condNode;

  		this.ifNode = ifNode;
  		this.elseNode = elseNode;

  	}

  	getNodeType( builder ) {

  		const ifType = this.ifNode.getNodeType( builder );

  		if ( this.elseNode !== null ) {

  			const elseType = this.elseNode.getNodeType( builder );

  			if ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {

  				return elseType;

  			}

  		}

  		return ifType;

  	}

  	setup( builder ) {

  		const condNode = this.condNode.cache();
  		const ifNode = this.ifNode.cache();
  		const elseNode = this.elseNode ? this.elseNode.cache() : null;

  		//

  		const currentNodeBlock = builder.context.nodeBlock;

  		builder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;
  		if ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;

  		//

  		const properties = builder.getNodeProperties( this );
  		properties.condNode = condNode;
  		properties.ifNode = ifNode.context( { nodeBlock: ifNode } );
  		properties.elseNode = elseNode ? elseNode.context( { nodeBlock: elseNode } ) : null;

  	}

  	generate( builder, output ) {

  		const type = this.getNodeType( builder );

  		const nodeData = builder.getDataFromNode( this );

  		if ( nodeData.nodeProperty !== undefined ) {

  			return nodeData.nodeProperty;

  		}

  		const { condNode, ifNode, elseNode } = builder.getNodeProperties( this );

  		const needsOutput = output !== 'void';
  		const nodeProperty = needsOutput ? property( type ).build( builder ) : '';

  		nodeData.nodeProperty = nodeProperty;

  		const nodeSnippet = condNode.build( builder, 'bool' );

  		builder.addFlowCode( `\n${ builder.tab }if ( ${ nodeSnippet } ) {\n\n` ).addFlowTab();

  		let ifSnippet = ifNode.build( builder, type );

  		if ( ifSnippet ) {

  			if ( needsOutput ) {

  				ifSnippet = nodeProperty + ' = ' + ifSnippet + ';';

  			} else {

  				ifSnippet = 'return ' + ifSnippet + ';';

  			}

  		}

  		builder.removeFlowTab().addFlowCode( builder.tab + '\t' + ifSnippet + '\n\n' + builder.tab + '}' );

  		if ( elseNode !== null ) {

  			builder.addFlowCode( ' else {\n\n' ).addFlowTab();

  			let elseSnippet = elseNode.build( builder, type );

  			if ( elseSnippet ) {

  				if ( needsOutput ) {

  					elseSnippet = nodeProperty + ' = ' + elseSnippet + ';';

  				} else {

  					elseSnippet = 'return ' + elseSnippet + ';';

  				}

  			}

  			builder.removeFlowTab().addFlowCode( builder.tab + '\t' + elseSnippet + '\n\n' + builder.tab + '}\n\n' );

  		} else {

  			builder.addFlowCode( '\n\n' );

  		}

  		return builder.format( nodeProperty, type, output );

  	}

  }

  const select = /*@__PURE__*/ nodeProxy( ConditionalNode );

  addMethodChaining( 'select', select );

  //

  const cond = ( ...params ) => { // @deprecated, r168

  	console.warn( 'TSL.ConditionalNode: cond() has been renamed to select().' );
  	return select( ...params );

  };

  addMethodChaining( 'cond', cond );

  class ContextNode extends Node {

  	static get type() {

  		return 'ContextNode';

  	}

  	constructor( node, value = {} ) {

  		super();

  		this.isContextNode = true;

  		this.node = node;
  		this.value = value;

  	}

  	getScope() {

  		return this.node.getScope();

  	}

  	getNodeType( builder ) {

  		return this.node.getNodeType( builder );

  	}

  	analyze( builder ) {

  		this.node.build( builder );

  	}

  	setup( builder ) {

  		const previousContext = builder.getContext();

  		builder.setContext( { ...builder.context, ...this.value } );

  		const node = this.node.build( builder );

  		builder.setContext( previousContext );

  		return node;

  	}

  	generate( builder, output ) {

  		const previousContext = builder.getContext();

  		builder.setContext( { ...builder.context, ...this.value } );

  		const snippet = this.node.build( builder, output );

  		builder.setContext( previousContext );

  		return snippet;

  	}

  }

  const context = /*@__PURE__*/ nodeProxy( ContextNode );
  const label = ( node, name ) => context( node, { label: name } );

  addMethodChaining( 'context', context );
  addMethodChaining( 'label', label );

  class VarNode extends Node {

  	static get type() {

  		return 'VarNode';

  	}

  	constructor( node, name = null ) {

  		super();

  		this.node = node;
  		this.name = name;

  		this.global = true;

  		this.isVarNode = true;

  	}

  	getHash( builder ) {

  		return this.name || super.getHash( builder );

  	}

  	getNodeType( builder ) {

  		return this.node.getNodeType( builder );

  	}

  	generate( builder ) {

  		const { node, name } = this;

  		const nodeVar = builder.getVarFromNode( this, name, builder.getVectorType( this.getNodeType( builder ) ) );

  		const propertyName = builder.getPropertyName( nodeVar );

  		const snippet = node.build( builder, nodeVar.type );

  		builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

  		return propertyName;

  	}

  }

  const temp = /*@__PURE__*/ nodeProxy( VarNode );

  addMethodChaining( 'temp', temp ); // @TODO: Will be removed in the future
  addMethodChaining( 'toVar', ( ...params ) => temp( ...params ).append() );

  class VaryingNode extends Node {

  	static get type() {

  		return 'VaryingNode';

  	}

  	constructor( node, name = null ) {

  		super();

  		this.node = node;
  		this.name = name;

  		this.isVaryingNode = true;

  	}

  	isGlobal() {

  		return true;

  	}

  	getHash( builder ) {

  		return this.name || super.getHash( builder );

  	}

  	getNodeType( builder ) {

  		// VaryingNode is auto type

  		return this.node.getNodeType( builder );

  	}

  	setupVarying( builder ) {

  		const properties = builder.getNodeProperties( this );

  		let varying = properties.varying;

  		if ( varying === undefined ) {

  			const name = this.name;
  			const type = this.getNodeType( builder );

  			properties.varying = varying = builder.getVaryingFromNode( this, name, type );
  			properties.node = this.node;

  		}

  		// this property can be used to check if the varying can be optimized for a variable
  		varying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );

  		return varying;

  	}

  	setup( builder ) {

  		this.setupVarying( builder );

  	}

  	analyze( builder ) {

  		this.setupVarying( builder );

  		return this.node.analyze( builder );

  	}

  	generate( builder ) {

  		const properties = builder.getNodeProperties( this );
  		const varying = this.setupVarying( builder );

  		if ( properties.propertyName === undefined ) {

  			const type = this.getNodeType( builder );
  			const propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );

  			// force node run in vertex stage
  			builder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node, type, propertyName );

  			properties.propertyName = propertyName;

  		}

  		return builder.getPropertyName( varying );

  	}

  }

  const varying = /*@__PURE__*/ nodeProxy( VaryingNode );

  addMethodChaining( 'varying', varying );

  const WORKING_COLOR_SPACE = 'WorkingColorSpace';
  const OUTPUT_COLOR_SPACE = 'OutputColorSpace';

  function getColorSpaceName( colorSpace ) {

  	let method = null;

  	if ( colorSpace === LinearSRGBColorSpace ) {

  		method = 'Linear';

  	} else if ( colorSpace === SRGBColorSpace ) {

  		method = 'sRGB';

  	}

  	return method;

  }

  function getColorSpaceMethod( source, target ) {

  	return getColorSpaceName( source ) + 'To' + getColorSpaceName( target );

  }

  class ColorSpaceNode extends TempNode {

  	static get type() {

  		return 'ColorSpaceNode';

  	}

  	constructor( colorNode, source, target ) {

  		super( 'vec4' );

  		this.colorNode = colorNode;
  		this.source = source;
  		this.target = target;

  	}

  	getColorSpace( builder, colorSpace ) {

  		if ( colorSpace === WORKING_COLOR_SPACE ) {

  			return ColorManagement.workingColorSpace;

  		} else if ( colorSpace === OUTPUT_COLOR_SPACE ) {

  			return builder.context.outputColorSpace || builder.renderer.outputColorSpace;

  		}

  		return colorSpace;

  	}

  	setup( builder ) {

  		const { renderer } = builder;
  		const { colorNode } = this;

  		const source = this.getColorSpace( builder, this.source );
  		const target = this.getColorSpace( builder, this.target );

  		if ( source === target ) return colorNode;

  		const colorSpace = getColorSpaceMethod( source, target );

  		let outputNode = null;

  		const colorSpaceFn = renderer.nodes.library.getColorSpaceFunction( colorSpace );

  		if ( colorSpaceFn !== null ) {

  			outputNode = vec4( colorSpaceFn( colorNode.rgb ), colorNode.a );

  		} else {

  			console.error( 'ColorSpaceNode: Unsupported Color Space configuration.', colorSpace );

  			outputNode = colorNode;

  		}

  		return outputNode;

  	}

  }

  const toOutputColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE ) );
  const toWorkingColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE ) );

  const workingToColorSpace = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, colorSpace ) );
  const colorSpaceToWorking = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), colorSpace, WORKING_COLOR_SPACE ) );

  addMethodChaining( 'toOutputColorSpace', toOutputColorSpace );
  addMethodChaining( 'toWorkingColorSpace', toWorkingColorSpace );

  addMethodChaining( 'workingToColorSpace', workingToColorSpace );
  addMethodChaining( 'colorSpaceToWorking', colorSpaceToWorking );

  let ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {

  	static get type() {

  		return 'ReferenceElementNode';

  	}

  	constructor( referenceNode, indexNode ) {

  		super( referenceNode, indexNode );

  		this.referenceNode = referenceNode;

  		this.isReferenceElementNode = true;

  	}

  	getNodeType() {

  		return this.referenceNode.uniformType;

  	}

  	generate( builder ) {

  		const snippet = super.generate( builder );
  		const arrayType = this.referenceNode.getNodeType();
  		const elementType = this.getNodeType();

  		return builder.format( snippet, arrayType, elementType );

  	}

  };

  class ReferenceBaseNode extends Node {

  	static get type() {

  		return 'ReferenceBaseNode';

  	}

  	constructor( property, uniformType, object = null, count = null ) {

  		super();

  		this.property = property;
  		this.uniformType = uniformType;
  		this.object = object;
  		this.count = count;

  		this.properties = property.split( '.' );
  		this.reference = object;
  		this.node = null;
  		this.group = null;

  		this.updateType = NodeUpdateType.OBJECT;

  	}

  	setGroup( group ) {

  		this.group = group;

  		return this;

  	}

  	element( indexNode ) {

  		return nodeObject( new ReferenceElementNode$1( this, nodeObject( indexNode ) ) );

  	}

  	setNodeType( uniformType ) {

  		const node = uniform( null, uniformType ).getSelf();

  		if ( this.group !== null ) {

  			node.setGroup( this.group );

  		}

  		this.node = node;

  	}

  	getNodeType( builder ) {

  		if ( this.node === null ) {

  			this.updateReference( builder );
  			this.updateValue();

  		}

  		return this.node.getNodeType( builder );

  	}

  	getValueFromReference( object = this.reference ) {

  		const { properties } = this;

  		let value = object[ properties[ 0 ] ];

  		for ( let i = 1; i < properties.length; i ++ ) {

  			value = value[ properties[ i ] ];

  		}

  		return value;

  	}

  	updateReference( state ) {

  		this.reference = this.object !== null ? this.object : state.object;

  		return this.reference;

  	}

  	setup() {

  		this.updateValue();

  		return this.node;

  	}

  	update( /*frame*/ ) {

  		this.updateValue();

  	}

  	updateValue() {

  		if ( this.node === null ) this.setNodeType( this.uniformType );

  		const value = this.getValueFromReference();

  		if ( Array.isArray( value ) ) {

  			this.node.array = value;

  		} else {

  			this.node.value = value;

  		}

  	}

  }

  const reference$1 = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );

  class RendererReferenceNode extends ReferenceBaseNode {

  	static get type() {

  		return 'RendererReferenceNode';

  	}

  	constructor( property, inputType, renderer = null ) {

  		super( property, inputType, renderer );

  		this.renderer = renderer;

  		this.setGroup( renderGroup );

  	}

  	updateReference( state ) {

  		this.reference = this.renderer !== null ? this.renderer : state.renderer;

  		return this.reference;

  	}

  }

  const rendererReference = ( name, type, renderer ) => nodeObject( new RendererReferenceNode( name, type, renderer ) );

  class ToneMappingNode extends TempNode {

  	static get type() {

  		return 'ToneMappingNode';

  	}

  	constructor( toneMapping, exposureNode = toneMappingExposure, colorNode = null ) {

  		super( 'vec3' );

  		this.toneMapping = toneMapping;

  		this.exposureNode = exposureNode;
  		this.colorNode = colorNode;

  	}

  	getCacheKey() {

  		return hash$1( super.getCacheKey(), this.toneMapping );

  	}

  	setup( builder ) {

  		const colorNode = this.colorNode || builder.context.color;
  		const toneMapping = this.toneMapping;

  		if ( toneMapping === NoToneMapping ) return colorNode;

  		let outputNode = null;

  		const toneMappingFn = builder.renderer.nodes.library.getToneMappingFunction( toneMapping );

  		if ( toneMappingFn !== null ) {

  			outputNode = vec4( toneMappingFn( colorNode.rgb, this.exposureNode ), colorNode.a );

  		} else {

  			console.error( 'ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping );

  			outputNode = colorNode;

  		}

  		return outputNode;

  	}

  }

  const toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );
  const toneMappingExposure = /*@__PURE__*/ rendererReference( 'toneMappingExposure', 'float' );

  addMethodChaining( 'toneMapping', ( color, mapping, exposure ) => toneMapping( mapping, exposure, color ) );

  class BufferAttributeNode extends InputNode {

  	static get type() {

  		return 'BufferAttributeNode';

  	}

  	constructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {

  		super( value, bufferType );

  		this.isBufferNode = true;

  		this.bufferType = bufferType;
  		this.bufferStride = bufferStride;
  		this.bufferOffset = bufferOffset;

  		this.usage = StaticDrawUsage;
  		this.instanced = false;

  		this.attribute = null;

  		this.global = true;

  		if ( value && value.isBufferAttribute === true ) {

  			this.attribute = value;
  			this.usage = value.usage;
  			this.instanced = value.isInstancedBufferAttribute;

  		}

  	}

  	getHash( builder ) {

  		if ( this.bufferStride === 0 && this.bufferOffset === 0 ) {

  			let bufferData = builder.globalCache.getData( this.value );

  			if ( bufferData === undefined ) {

  				bufferData = {
  					node: this
  				};

  				builder.globalCache.setData( this.value, bufferData );

  			}

  			return bufferData.node.uuid;

  		}

  		return this.uuid;

  	}

  	getNodeType( builder ) {

  		if ( this.bufferType === null ) {

  			this.bufferType = builder.getTypeFromAttribute( this.attribute );

  		}

  		return this.bufferType;

  	}

  	setup( builder ) {

  		if ( this.attribute !== null ) return;

  		const type = this.getNodeType( builder );
  		const array = this.value;
  		const itemSize = builder.getTypeLength( type );
  		const stride = this.bufferStride || itemSize;
  		const offset = this.bufferOffset;

  		const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );
  		const bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );

  		buffer.setUsage( this.usage );

  		this.attribute = bufferAttribute;
  		this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute

  	}

  	generate( builder ) {

  		const nodeType = this.getNodeType( builder );

  		const nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );
  		const propertyName = builder.getPropertyName( nodeAttribute );

  		let output = null;

  		if ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {

  			this.name = propertyName;

  			output = propertyName;

  		} else {

  			const nodeVarying = varying( this );

  			output = nodeVarying.build( builder, nodeType );

  		}

  		return output;

  	}

  	getInputType( /*builder*/ ) {

  		return 'bufferAttribute';

  	}

  	setUsage( value ) {

  		this.usage = value;

  		if ( this.attribute && this.attribute.isBufferAttribute === true ) {

  			this.attribute.usage = value;

  		}

  		return this;

  	}

  	setInstanced( value ) {

  		this.instanced = value;

  		return this;

  	}

  }

  const bufferAttribute = ( array, type, stride, offset ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );
  const dynamicBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );

  const instancedBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );
  const instancedDynamicBufferAttribute = ( array, type, stride, offset ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );

  addMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );

  class ComputeNode extends Node {

  	static get type() {

  		return 'ComputeNode';

  	}

  	constructor( computeNode, count, workgroupSize = [ 64 ] ) {

  		super( 'void' );

  		this.isComputeNode = true;

  		this.computeNode = computeNode;

  		this.count = count;
  		this.workgroupSize = workgroupSize;
  		this.dispatchCount = 0;

  		this.version = 1;
  		this.updateBeforeType = NodeUpdateType.OBJECT;

  		this.updateDispatchCount();

  	}

  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	updateDispatchCount() {

  		const { count, workgroupSize } = this;

  		let size = workgroupSize[ 0 ];

  		for ( let i = 1; i < workgroupSize.length; i ++ )
  			size *= workgroupSize[ i ];

  		this.dispatchCount = Math.ceil( count / size );

  	}

  	onInit() { }

  	updateBefore( { renderer } ) {

  		renderer.compute( this );

  	}

  	generate( builder ) {

  		const { shaderStage } = builder;

  		if ( shaderStage === 'compute' ) {

  			const snippet = this.computeNode.build( builder, 'void' );

  			if ( snippet !== '' ) {

  				builder.addLineFlowCode( snippet, this );

  			}

  		}

  	}

  }

  const compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );

  addMethodChaining( 'compute', compute );

  class CacheNode extends Node {

  	static get type() {

  		return 'CacheNode';

  	}

  	constructor( node, parent = true ) {

  		super();

  		this.node = node;
  		this.parent = parent;

  		this.isCacheNode = true;

  	}

  	getNodeType( builder ) {

  		return this.node.getNodeType( builder );

  	}

  	build( builder, ...params ) {

  		const previousCache = builder.getCache();
  		const cache = builder.getCacheFromNode( this, this.parent );

  		builder.setCache( cache );

  		const data = this.node.build( builder, ...params );

  		builder.setCache( previousCache );

  		return data;

  	}

  }

  const cache = ( node, ...params ) => nodeObject( new CacheNode( nodeObject( node ), ...params ) );

  addMethodChaining( 'cache', cache );

  class BypassNode extends Node {

  	static get type() {

  		return 'BypassNode';

  	}

  	constructor( returnNode, callNode ) {

  		super();

  		this.isBypassNode = true;

  		this.outputNode = returnNode;
  		this.callNode = callNode;

  	}

  	getNodeType( builder ) {

  		return this.outputNode.getNodeType( builder );

  	}

  	generate( builder ) {

  		const snippet = this.callNode.build( builder, 'void' );

  		if ( snippet !== '' ) {

  			builder.addLineFlowCode( snippet, this );

  		}

  		return this.outputNode.build( builder );

  	}

  }

  const bypass = /*@__PURE__*/ nodeProxy( BypassNode );

  addMethodChaining( 'bypass', bypass );

  class RemapNode extends Node {

  	static get type() {

  		return 'RemapNode';

  	}

  	constructor( node, inLowNode, inHighNode, outLowNode = float( 0 ), outHighNode = float( 1 ) ) {

  		super();

  		this.node = node;
  		this.inLowNode = inLowNode;
  		this.inHighNode = inHighNode;
  		this.outLowNode = outLowNode;
  		this.outHighNode = outHighNode;

  		this.doClamp = true;

  	}

  	setup() {

  		const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;

  		let t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );

  		if ( doClamp === true ) t = t.clamp();

  		return t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );

  	}

  }

  const remap = /*@__PURE__*/ nodeProxy( RemapNode, null, null, { doClamp: false } );
  const remapClamp = /*@__PURE__*/ nodeProxy( RemapNode );

  addMethodChaining( 'remap', remap );
  addMethodChaining( 'remapClamp', remapClamp );

  class ExpressionNode extends Node {

  	static get type() {

  		return 'ExpressionNode';

  	}

  	constructor( snippet = '', nodeType = 'void' ) {

  		super( nodeType );

  		this.snippet = snippet;

  	}

  	generate( builder, output ) {

  		const type = this.getNodeType( builder );
  		const snippet = this.snippet;

  		if ( type === 'void' ) {

  			builder.addLineFlowCode( snippet, this );

  		} else {

  			return builder.format( `( ${ snippet } )`, type, output );

  		}

  	}

  }

  const expression = /*@__PURE__*/ nodeProxy( ExpressionNode );

  const Discard = ( conditional ) => ( conditional ? select( conditional, expression( 'discard' ) ) : expression( 'discard' ) ).append();

  addMethodChaining( 'discard', Discard );

  class RenderOutputNode extends TempNode {

  	static get type() {

  		return 'RenderOutputNode';

  	}

  	constructor( colorNode, toneMapping, outputColorSpace ) {

  		super( 'vec4' );

  		this.colorNode = colorNode;
  		this.toneMapping = toneMapping;
  		this.outputColorSpace = outputColorSpace;

  		this.isRenderOutput = true;

  	}

  	setup( { context } ) {

  		let outputNode = this.colorNode || context.color;

  		// tone mapping

  		const toneMapping = ( this.toneMapping !== null ? this.toneMapping : context.toneMapping ) || NoToneMapping;
  		const outputColorSpace = ( this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace ) || NoColorSpace;

  		if ( toneMapping !== NoToneMapping ) {

  			outputNode = outputNode.toneMapping( toneMapping );

  		}

  		// working to output color space

  		if ( outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace ) {

  			outputNode = outputNode.workingToColorSpace( outputColorSpace );

  		}

  		return outputNode;

  	}

  }

  const renderOutput = ( color, toneMapping = null, outputColorSpace = null ) => nodeObject( new RenderOutputNode( nodeObject( color ), toneMapping, outputColorSpace ) );

  addMethodChaining( 'renderOutput', renderOutput );

  class AttributeNode extends Node {

  	static get type() {

  		return 'AttributeNode';

  	}

  	constructor( attributeName, nodeType = null ) {

  		super( nodeType );

  		this.global = true;

  		this._attributeName = attributeName;

  	}

  	getHash( builder ) {

  		return this.getAttributeName( builder );

  	}

  	getNodeType( builder ) {

  		let nodeType = this.nodeType;

  		if ( nodeType === null ) {

  			const attributeName = this.getAttributeName( builder );

  			if ( builder.hasGeometryAttribute( attributeName ) ) {

  				const attribute = builder.geometry.getAttribute( attributeName );

  				nodeType = builder.getTypeFromAttribute( attribute );

  			} else {

  				nodeType = 'float';

  			}

  		}

  		return nodeType;

  	}

  	setAttributeName( attributeName ) {

  		this._attributeName = attributeName;

  		return this;

  	}

  	getAttributeName( /*builder*/ ) {

  		return this._attributeName;

  	}

  	generate( builder ) {

  		const attributeName = this.getAttributeName( builder );
  		const nodeType = this.getNodeType( builder );
  		const geometryAttribute = builder.hasGeometryAttribute( attributeName );

  		if ( geometryAttribute === true ) {

  			const attribute = builder.geometry.getAttribute( attributeName );
  			const attributeType = builder.getTypeFromAttribute( attribute );

  			const nodeAttribute = builder.getAttribute( attributeName, attributeType );

  			if ( builder.shaderStage === 'vertex' ) {

  				return builder.format( nodeAttribute.name, attributeType, nodeType );

  			} else {

  				const nodeVarying = varying( this );

  				return nodeVarying.build( builder, nodeType );

  			}

  		} else {

  			console.warn( `AttributeNode: Vertex attribute "${ attributeName }" not found on geometry.` );

  			return builder.generateConst( nodeType );

  		}

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.global = this.global;
  		data._attributeName = this._attributeName;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.global = data.global;
  		this._attributeName = data._attributeName;

  	}

  }

  const attribute = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );

  const uv = ( index ) => attribute( 'uv' + ( index > 0 ? index : '' ), 'vec2' );

  class TextureSizeNode extends Node {

  	static get type() {

  		return 'TextureSizeNode';

  	}

  	constructor( textureNode, levelNode = null ) {

  		super( 'uvec2' );

  		this.isTextureSizeNode = true;

  		this.textureNode = textureNode;
  		this.levelNode = levelNode;

  	}

  	generate( builder, output ) {

  		const textureProperty = this.textureNode.build( builder, 'property' );
  		const level = this.levelNode === null ? '0' : this.levelNode.build( builder, 'int' );

  		return builder.format( `${ builder.getMethod( 'textureDimensions' ) }( ${ textureProperty }, ${ level } )`, this.getNodeType( builder ), output );

  	}

  }

  const textureSize = /*@__PURE__*/ nodeProxy( TextureSizeNode );

  class MaxMipLevelNode extends UniformNode {

  	static get type() {

  		return 'MaxMipLevelNode';

  	}

  	constructor( textureNode ) {

  		super( 0 );

  		this._textureNode = textureNode;

  		this.updateType = NodeUpdateType.FRAME;

  	}

  	get textureNode() {

  		return this._textureNode;

  	}

  	get texture() {

  		return this._textureNode.value;

  	}

  	update() {

  		const texture = this.texture;
  		const images = texture.images;
  		const image = ( images && images.length > 0 ) ? ( ( images[ 0 ] && images[ 0 ].image ) || images[ 0 ] ) : texture.image;

  		if ( image && image.width !== undefined ) {

  			const { width, height } = image;

  			this.value = Math.log2( Math.max( width, height ) );

  		}

  	}

  }

  const maxMipLevel = /*@__PURE__*/ nodeProxy( MaxMipLevelNode );

  class TextureNode extends UniformNode {

  	static get type() {

  		return 'TextureNode';

  	}

  	constructor( value, uvNode = null, levelNode = null, biasNode = null ) {

  		super( value );

  		this.isTextureNode = true;

  		this.uvNode = uvNode;
  		this.levelNode = levelNode;
  		this.biasNode = biasNode;
  		this.compareNode = null;
  		this.depthNode = null;
  		this.gradNode = null;

  		this.sampler = true;
  		this.updateMatrix = false;
  		this.updateType = NodeUpdateType.NONE;

  		this.referenceNode = null;

  		this._value = value;
  		this._matrixUniform = null;

  		this.setUpdateMatrix( uvNode === null );

  	}

  	set value( value ) {

  		if ( this.referenceNode ) {

  			this.referenceNode.value = value;

  		} else {

  			this._value = value;

  		}

  	}

  	get value() {

  		return this.referenceNode ? this.referenceNode.value : this._value;

  	}

  	getUniformHash( /*builder*/ ) {

  		return this.value.uuid;

  	}

  	getNodeType( /*builder*/ ) {

  		if ( this.value.isDepthTexture === true ) return 'float';

  		if ( this.value.type === UnsignedIntType ) {

  			return 'uvec4';

  		} else if ( this.value.type === IntType ) {

  			return 'ivec4';

  		}

  		return 'vec4';

  	}

  	getInputType( /*builder*/ ) {

  		return 'texture';

  	}

  	getDefaultUV() {

  		return uv( this.value.channel );

  	}

  	updateReference( /*state*/ ) {

  		return this.value;

  	}

  	getTransformedUV( uvNode ) {

  		if ( this._matrixUniform === null ) this._matrixUniform = uniform( this.value.matrix );

  		return this._matrixUniform.mul( vec3( uvNode, 1 ) ).xy;

  	}

  	setUpdateMatrix( value ) {

  		this.updateMatrix = value;
  		this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;

  		return this;

  	}

  	setupUV( builder, uvNode ) {

  		const texture = this.value;

  		if ( builder.isFlipY() && ( texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {

  			if ( this.sampler ) {

  				uvNode = uvNode.flipY();

  			} else {

  				uvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );

  			}

  		}

  		return uvNode;

  	}

  	setup( builder ) {

  		const properties = builder.getNodeProperties( this );
  		properties.referenceNode = this.referenceNode;

  		//

  		let uvNode = this.uvNode;

  		if ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {

  			uvNode = builder.context.getUV( this );

  		}

  		if ( ! uvNode ) uvNode = this.getDefaultUV();

  		if ( this.updateMatrix === true ) {

  			uvNode = this.getTransformedUV( uvNode );

  		}

  		uvNode = this.setupUV( builder, uvNode );

  		//

  		let levelNode = this.levelNode;

  		if ( levelNode === null && builder.context.getTextureLevel ) {

  			levelNode = builder.context.getTextureLevel( this );

  		}

  		//

  		properties.uvNode = uvNode;
  		properties.levelNode = levelNode;
  		properties.biasNode = this.biasNode;
  		properties.compareNode = this.compareNode;
  		properties.gradNode = this.gradNode;
  		properties.depthNode = this.depthNode;

  	}

  	generateUV( builder, uvNode ) {

  		return uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );

  	}

  	generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet ) {

  		const texture = this.value;

  		let snippet;

  		if ( levelSnippet ) {

  			snippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );

  		} else if ( biasSnippet ) {

  			snippet = builder.generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet );

  		} else if ( gradSnippet ) {

  			snippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet );

  		} else if ( compareSnippet ) {

  			snippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );

  		} else if ( this.sampler === false ) {

  			snippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );

  		} else {

  			snippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );

  		}

  		return snippet;

  	}

  	generate( builder, output ) {

  		const properties = builder.getNodeProperties( this );

  		const texture = this.value;

  		if ( ! texture || texture.isTexture !== true ) {

  			throw new Error( 'TextureNode: Need a three.js texture.' );

  		}

  		const textureProperty = super.generate( builder, 'property' );

  		if ( output === 'sampler' ) {

  			return textureProperty + '_sampler';

  		} else if ( builder.isReference( output ) ) {

  			return textureProperty;

  		} else {

  			const nodeData = builder.getDataFromNode( this );

  			let propertyName = nodeData.propertyName;

  			if ( propertyName === undefined ) {

  				const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;

  				const uvSnippet = this.generateUV( builder, uvNode );
  				const levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;
  				const biasSnippet = biasNode ? biasNode.build( builder, 'float' ) : null;
  				const depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;
  				const compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;
  				const gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;

  				const nodeVar = builder.getVarFromNode( this );

  				propertyName = builder.getPropertyName( nodeVar );

  				const snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet );

  				builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

  				nodeData.snippet = snippet;
  				nodeData.propertyName = propertyName;

  			}

  			let snippet = propertyName;
  			const nodeType = this.getNodeType( builder );

  			if ( builder.needsToWorkingColorSpace( texture ) ) {

  				snippet = colorSpaceToWorking( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );

  			}

  			return builder.format( snippet, nodeType, output );

  		}

  	}

  	setSampler( value ) {

  		this.sampler = value;

  		return this;

  	}

  	getSampler() {

  		return this.sampler;

  	}

  	// @TODO: Move to TSL

  	uv( uvNode ) {

  		const textureNode = this.clone();
  		textureNode.uvNode = nodeObject( uvNode );
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	blur( amountNode ) {

  		const textureNode = this.clone();
  		textureNode.biasNode = nodeObject( amountNode ).mul( maxMipLevel( textureNode ) );
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	level( levelNode ) {

  		const textureNode = this.clone();
  		textureNode.levelNode = nodeObject( levelNode );
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	size( levelNode ) {

  		return textureSize( this, levelNode );

  	}

  	bias( biasNode ) {

  		const textureNode = this.clone();
  		textureNode.biasNode = nodeObject( biasNode );
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	compare( compareNode ) {

  		const textureNode = this.clone();
  		textureNode.compareNode = nodeObject( compareNode );
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	grad( gradNodeX, gradNodeY ) {

  		const textureNode = this.clone();
  		textureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	depth( depthNode ) {

  		const textureNode = this.clone();
  		textureNode.depthNode = nodeObject( depthNode );
  		textureNode.referenceNode = this.getSelf();

  		return nodeObject( textureNode );

  	}

  	// --

  	serialize( data ) {

  		super.serialize( data );

  		data.value = this.value.toJSON( data.meta ).uuid;
  		data.sampler = this.sampler;
  		data.updateMatrix = this.updateMatrix;
  		data.updateType = this.updateType;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.value = data.meta.textures[ data.value ];
  		this.sampler = data.sampler;
  		this.updateMatrix = data.updateMatrix;
  		this.updateType = data.updateType;

  	}

  	update() {

  		const texture = this.value;
  		const matrixUniform = this._matrixUniform;

  		if ( matrixUniform !== null ) matrixUniform.value = texture.matrix;

  		if ( texture.matrixAutoUpdate === true ) {

  			texture.updateMatrix();

  		}

  	}

  	clone() {

  		const newNode = new this.constructor( this.value, this.uvNode, this.levelNode, this.biasNode );
  		newNode.sampler = this.sampler;

  		return newNode;

  	}

  }

  const texture = /*@__PURE__*/ nodeProxy( TextureNode );
  const textureLoad = ( ...params ) => texture( ...params ).setSampler( false );

  const cameraNear = /*@__PURE__*/ uniform( 'float' ).label( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );
  const cameraFar = /*@__PURE__*/ uniform( 'float' ).label( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );
  const cameraLogDepth = /*@__PURE__*/ uniform( 'float' ).label( 'cameraLogDepth' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
  const cameraProjectionMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );
  const cameraViewMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );
  const cameraPosition = /*@__PURE__*/ uniform( new Vector3() ).label( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );

  class Object3DNode extends Node {

  	static get type() {

  		return 'Object3DNode';

  	}

  	constructor( scope, object3d = null ) {

  		super();

  		this.scope = scope;
  		this.object3d = object3d;

  		this.updateType = NodeUpdateType.OBJECT;

  		this._uniformNode = new UniformNode( null );

  	}

  	getNodeType() {

  		const scope = this.scope;

  		if ( scope === Object3DNode.WORLD_MATRIX ) {

  			return 'mat4';

  		} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

  			return 'vec3';

  		}

  	}

  	update( frame ) {

  		const object = this.object3d;
  		const uniformNode = this._uniformNode;
  		const scope = this.scope;

  		if ( scope === Object3DNode.WORLD_MATRIX ) {

  			uniformNode.value = object.matrixWorld;

  		} else if ( scope === Object3DNode.POSITION ) {

  			uniformNode.value = uniformNode.value || new Vector3();

  			uniformNode.value.setFromMatrixPosition( object.matrixWorld );

  		} else if ( scope === Object3DNode.SCALE ) {

  			uniformNode.value = uniformNode.value || new Vector3();

  			uniformNode.value.setFromMatrixScale( object.matrixWorld );

  		} else if ( scope === Object3DNode.DIRECTION ) {

  			uniformNode.value = uniformNode.value || new Vector3();

  			object.getWorldDirection( uniformNode.value );

  		} else if ( scope === Object3DNode.VIEW_POSITION ) {

  			const camera = frame.camera;

  			uniformNode.value = uniformNode.value || new Vector3();
  			uniformNode.value.setFromMatrixPosition( object.matrixWorld );

  			uniformNode.value.applyMatrix4( camera.matrixWorldInverse );

  		}

  	}

  	generate( builder ) {

  		const scope = this.scope;

  		if ( scope === Object3DNode.WORLD_MATRIX ) {

  			this._uniformNode.nodeType = 'mat4';

  		} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

  			this._uniformNode.nodeType = 'vec3';

  		}

  		return this._uniformNode.build( builder );

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.scope = this.scope;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.scope = data.scope;

  	}

  }

  Object3DNode.WORLD_MATRIX = 'worldMatrix';
  Object3DNode.POSITION = 'position';
  Object3DNode.SCALE = 'scale';
  Object3DNode.VIEW_POSITION = 'viewPosition';
  Object3DNode.DIRECTION = 'direction';

  /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.DIRECTION );
  /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX );
  /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.POSITION );
  /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.SCALE );
  /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION );

  class ModelNode extends Object3DNode {

  	static get type() {

  		return 'ModelNode';

  	}

  	constructor( scope ) {

  		super( scope );

  	}

  	update( frame ) {

  		this.object3d = frame.object;

  		super.update( frame );

  	}

  }

  /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );
  const modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );
  /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );
  /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );
  /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );
  const modelNormalMatrix = /*@__PURE__*/ uniform( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );
  const modelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix ).toVar( 'modelViewMatrix' );

  const positionGeometry = /*@__PURE__*/ attribute( 'position', 'vec3' );
  const positionLocal = /*@__PURE__*/ positionGeometry.varying( 'positionLocal' );
  const positionPrevious = /*@__PURE__*/ positionGeometry.varying( 'positionPrevious' );
  const positionWorld = /*@__PURE__*/ modelWorldMatrix.mul( positionLocal ).xyz.varying( 'v_positionWorld' );
  const positionWorldDirection = /*@__PURE__*/ positionLocal.transformDirection( modelWorldMatrix ).varying( 'v_positionWorldDirection' ).normalize().toVar( 'positionWorldDirection' );
  const positionView = /*@__PURE__*/ modelViewMatrix.mul( positionLocal ).xyz.varying( 'v_positionView' );
  const positionViewDirection = /*@__PURE__*/ positionView.negate().varying( 'v_positionViewDirection' ).normalize().toVar( 'positionViewDirection' );

  class FrontFacingNode extends Node {

  	static get type() {

  		return 'FrontFacingNode';

  	}

  	constructor() {

  		super( 'bool' );

  		this.isFrontFacingNode = true;

  	}

  	generate( builder ) {

  		const { renderer, material } = builder;

  		if ( renderer.coordinateSystem === WebGLCoordinateSystem ) {

  			if ( material.side === BackSide ) {

  				return 'false';

  			}

  		}

  		return builder.getFrontFacing();

  	}

  }

  const frontFacing = /*@__PURE__*/ nodeImmutable( FrontFacingNode );
  const faceDirection = /*@__PURE__*/ float( frontFacing ).mul( 2.0 ).sub( 1.0 );

  const normalGeometry = /*@__PURE__*/ attribute( 'normal', 'vec3' );

  const normalLocal = /*@__PURE__*/ ( Fn( ( builder ) => {

  	if ( builder.geometry.hasAttribute( 'normal' ) === false ) {

  		console.warn( 'TSL.NormalNode: Vertex attribute "normal" not found on geometry.' );

  		return vec3( 0, 1, 0 );

  	}

  	return normalGeometry;

  }, 'vec3' ).once() )().toVar( 'normalLocal' );

  const normalFlat = /*@__PURE__*/ positionView.dFdx().cross( positionView.dFdy() ).normalize().toVar( 'normalFlat' );

  const normalView = /*@__PURE__*/ ( Fn( ( builder ) => {

  	let node;

  	if ( builder.material.flatShading === true ) {

  		node = normalFlat;

  	} else {

  		node = varying( transformNormalToView( normalLocal ), 'v_normalView' ).normalize();

  	}

  	return node;

  }, 'vec3' ).once() )().toVar( 'normalView' );

  const normalWorld = /*@__PURE__*/ varying( normalView.transformDirection( cameraViewMatrix ), 'v_normalWorld' ).normalize().toVar( 'normalWorld' );

  const transformedNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {

  	return builder.context.setupNormal();

  }, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedNormalView' );


  const transformedNormalWorld = /*@__PURE__*/ transformedNormalView.transformDirection( cameraViewMatrix ).toVar( 'transformedNormalWorld' );

  const transformedClearcoatNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {

  	return builder.context.setupClearcoatNormal();

  }, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedClearcoatNormalView' );

  const transformNormal = /*@__PURE__*/ Fn( ( [ normal, matrix = modelWorldMatrix ] ) => {

  	const m = mat3( matrix );

  	const transformedNormal = normal.div( vec3( m[ 0 ].dot( m[ 0 ] ), m[ 1 ].dot( m[ 1 ] ), m[ 2 ].dot( m[ 2 ] ) ) );

  	return m.mul( transformedNormal ).xyz;

  } );

  const transformNormalToView = /*@__PURE__*/ Fn( ( [ normal ], builder ) => {

  	const modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;

  	if ( modelNormalViewMatrix !== null ) {

  		return modelNormalViewMatrix.transformDirection( normal );

  	}

  	//

  	const transformedNormal = modelNormalMatrix.mul( normal );

  	return cameraViewMatrix.transformDirection( transformedNormal );

  } );

  const materialRefractionRatio = /*@__PURE__*/ uniform( 0 ).onReference( ( { material } ) => material ).onRenderUpdate( ( { material } ) => material.refractionRatio );

  const reflectView = /*@__PURE__*/ positionViewDirection.negate().reflect( transformedNormalView );
  const refractView = /*@__PURE__*/ positionViewDirection.negate().refract( transformedNormalView, materialRefractionRatio );

  const reflectVector = /*@__PURE__*/ reflectView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );
  const refractVector = /*@__PURE__*/ refractView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );

  class CubeTextureNode extends TextureNode {

  	static get type() {

  		return 'CubeTextureNode';

  	}

  	constructor( value, uvNode = null, levelNode = null, biasNode = null ) {

  		super( value, uvNode, levelNode, biasNode );

  		this.isCubeTextureNode = true;

  	}

  	getInputType( /*builder*/ ) {

  		return 'cubeTexture';

  	}

  	getDefaultUV() {

  		const texture = this.value;

  		if ( texture.mapping === CubeReflectionMapping ) {

  			return reflectVector;

  		} else if ( texture.mapping === CubeRefractionMapping ) {

  			return refractVector;

  		} else {

  			console.error( 'THREE.CubeTextureNode: Mapping "%s" not supported.', texture.mapping );

  			return vec3( 0, 0, 0 );

  		}

  	}

  	setUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode

  	setupUV( builder, uvNode ) {

  		const texture = this.value;

  		if ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem || ! texture.isRenderTargetTexture ) {

  			return vec3( uvNode.x.negate(), uvNode.yz );

  		} else {

  			return uvNode;

  		}

  	}

  	generateUV( builder, cubeUV ) {

  		return cubeUV.build( builder, 'vec3' );

  	}

  }

  const cubeTexture = /*@__PURE__*/ nodeProxy( CubeTextureNode );

  class BufferNode extends UniformNode {

  	static get type() {

  		return 'BufferNode';

  	}

  	constructor( value, bufferType, bufferCount = 0 ) {

  		super( value, bufferType );

  		this.isBufferNode = true;

  		this.bufferType = bufferType;
  		this.bufferCount = bufferCount;

  	}

  	getElementType( builder ) {

  		return this.getNodeType( builder );

  	}

  	getInputType( /*builder*/ ) {

  		return 'buffer';

  	}

  }

  const buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );

  class UniformArrayElementNode extends ArrayElementNode {

  	static get type() {

  		return 'UniformArrayElementNode';

  	}

  	constructor( arrayBuffer, indexNode ) {

  		super( arrayBuffer, indexNode );

  		this.isArrayBufferElementNode = true;

  	}

  	generate( builder ) {

  		const snippet = super.generate( builder );
  		const type = this.getNodeType();

  		return builder.format( snippet, 'vec4', type );

  	}

  }

  class UniformArrayNode extends BufferNode {

  	static get type() {

  		return 'UniformArrayNode';

  	}

  	constructor( value, elementType = null ) {

  		super( null, 'vec4' );

  		this.array = value;
  		this.elementType = elementType;

  		this._elementType = null;
  		this._elementLength = 0;

  		this.updateType = NodeUpdateType.RENDER;

  		this.isArrayBufferNode = true;

  	}

  	getElementType() {

  		return this.elementType || this._elementType;

  	}

  	getElementLength() {

  		return this._elementLength;

  	}

  	update( /*frame*/ ) {

  		const { array, value } = this;

  		const elementLength = this.getElementLength();
  		const elementType = this.getElementType();

  		if ( elementLength === 1 ) {

  			for ( let i = 0; i < array.length; i ++ ) {

  				const index = i * 4;

  				value[ index ] = array[ i ];

  			}

  		} else if ( elementType === 'color' ) {

  			for ( let i = 0; i < array.length; i ++ ) {

  				const index = i * 4;
  				const vector = array[ i ];

  				value[ index ] = vector.r;
  				value[ index + 1 ] = vector.g;
  				value[ index + 2 ] = vector.b || 0;
  				//value[ index + 3 ] = vector.a || 0;

  			}

  		} else {

  			for ( let i = 0; i < array.length; i ++ ) {

  				const index = i * 4;
  				const vector = array[ i ];

  				value[ index ] = vector.x;
  				value[ index + 1 ] = vector.y;
  				value[ index + 2 ] = vector.z || 0;
  				value[ index + 3 ] = vector.w || 0;

  			}

  		}

  	}

  	setup( builder ) {

  		const length = this.array.length;

  		this._elementType = this.elementType === null ? getValueType( this.array[ 0 ] ) : this.elementType;
  		this._elementLength = builder.getTypeLength( this._elementType );

  		let arrayType = Float32Array;

  		if ( this._elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;
  		else if ( this._elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;

  		this.value = new arrayType( length * 4 );
  		this.bufferCount = length;
  		this.bufferType = builder.changeComponentType( 'vec4', builder.getComponentType( this._elementType ) );

  		return super.setup( builder );

  	}

  	element( indexNode ) {

  		return nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );

  	}

  }

  const uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );

  class ReferenceElementNode extends ArrayElementNode {

  	static get type() {

  		return 'ReferenceElementNode';

  	}

  	constructor( referenceNode, indexNode ) {

  		super( referenceNode, indexNode );

  		this.referenceNode = referenceNode;

  		this.isReferenceElementNode = true;

  	}

  	getNodeType() {

  		return this.referenceNode.uniformType;

  	}

  	generate( builder ) {

  		const snippet = super.generate( builder );
  		const arrayType = this.referenceNode.getNodeType();
  		const elementType = this.getNodeType();

  		return builder.format( snippet, arrayType, elementType );

  	}

  }

  // TODO: Extends this from ReferenceBaseNode
  class ReferenceNode extends Node {

  	static get type() {

  		return 'ReferenceNode';

  	}

  	constructor( property, uniformType, object = null, count = null ) {

  		super();

  		this.property = property;
  		this.uniformType = uniformType;
  		this.object = object;
  		this.count = count;

  		this.properties = property.split( '.' );
  		this.reference = object;
  		this.node = null;
  		this.group = null;
  		this.name = null;

  		this.updateType = NodeUpdateType.OBJECT;

  	}

  	element( indexNode ) {

  		return nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );

  	}

  	setGroup( group ) {

  		this.group = group;

  		return this;

  	}

  	label( name ) {

  		this.name = name;

  		return this;

  	}

  	setNodeType( uniformType ) {

  		let node = null;

  		if ( this.count !== null ) {

  			node = buffer( null, uniformType, this.count );

  		} else if ( Array.isArray( this.getValueFromReference() ) ) {

  			node = uniformArray( null, uniformType );

  		} else if ( uniformType === 'texture' ) {

  			node = texture( null );

  		} else if ( uniformType === 'cubeTexture' ) {

  			node = cubeTexture( null );

  		} else {

  			node = uniform( null, uniformType );

  		}

  		if ( this.group !== null ) {

  			node.setGroup( this.group );

  		}

  		if ( this.name !== null ) node.label( this.name );

  		this.node = node.getSelf();

  	}

  	getNodeType( builder ) {

  		if ( this.node === null ) {

  			this.updateReference( builder );
  			this.updateValue();

  		}

  		return this.node.getNodeType( builder );

  	}

  	getValueFromReference( object = this.reference ) {

  		const { properties } = this;

  		let value = object[ properties[ 0 ] ];

  		for ( let i = 1; i < properties.length; i ++ ) {

  			value = value[ properties[ i ] ];

  		}

  		return value;

  	}

  	updateReference( state ) {

  		this.reference = this.object !== null ? this.object : state.object;

  		return this.reference;

  	}

  	setup() {

  		this.updateValue();

  		return this.node;

  	}

  	update( /*frame*/ ) {

  		this.updateValue();

  	}

  	updateValue() {

  		if ( this.node === null ) this.setNodeType( this.uniformType );

  		const value = this.getValueFromReference();

  		if ( Array.isArray( value ) ) {

  			this.node.array = value;

  		} else {

  			this.node.value = value;

  		}

  	}

  }

  const reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );
  const referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceNode( name, type, object, count ) );

  class MaterialReferenceNode extends ReferenceNode {

  	static get type() {

  		return 'MaterialReferenceNode';

  	}

  	constructor( property, inputType, material = null ) {

  		super( property, inputType, material );

  		this.material = material;

  		//this.updateType = NodeUpdateType.RENDER;

  		this.isMaterialReferenceNode = true;

  	}

  	/*setNodeType( node ) {

  		super.setNodeType( node );

  		this.node.groupNode = renderGroup;

  	}*/

  	updateReference( state ) {

  		this.reference = this.material !== null ? this.material : state.material;

  		return this.reference;

  	}

  }

  const materialReference = ( name, type, material ) => nodeObject( new MaterialReferenceNode( name, type, material ) );

  const tangentGeometry = /*@__PURE__*/ Fn( ( builder ) => {

  	if ( builder.geometry.hasAttribute( 'tangent' ) === false ) {

  		builder.geometry.computeTangents();

  	}

  	return attribute( 'tangent', 'vec4' );

  } )();

  const tangentLocal = /*@__PURE__*/ tangentGeometry.xyz.toVar( 'tangentLocal' );
  const tangentView = /*@__PURE__*/ modelViewMatrix.mul( vec4( tangentLocal, 0 ) ).xyz.varying( 'v_tangentView' ).normalize().toVar( 'tangentView' );

  const getBitangent = ( crossNormalTangent ) => crossNormalTangent.mul( tangentGeometry.w ).xyz;
  const bitangentView = /*@__PURE__*/ varying( getBitangent( normalView.cross( tangentView ) ), 'v_bitangentView' ).normalize().toVar( 'bitangentView' );

  const TBNViewMatrix = /*@__PURE__*/ mat3( tangentView, bitangentView, normalView );

  const transformedBentNormalView = /*@__PURE__*/ ( () => {

  	// https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy

  	let bentNormal = anisotropyB.cross( positionViewDirection );
  	bentNormal = bentNormal.cross( anisotropyB ).normalize();
  	bentNormal = mix$2( bentNormal, transformedNormalView, anisotropy.mul( roughness.oneMinus() ).oneMinus().pow2().pow2() ).normalize();

  	return bentNormal;


  } )();

  // Normal Mapping Without Precomputed Tangents
  // http://www.thetenthplanet.de/archives/1180

  const perturbNormal2Arb = /*@__PURE__*/ Fn( ( inputs ) => {

  	const { eye_pos, surf_norm, mapN, uv } = inputs;

  	const q0 = eye_pos.dFdx();
  	const q1 = eye_pos.dFdy();
  	const st0 = uv.dFdx();
  	const st1 = uv.dFdy();

  	const N = surf_norm; // normalized

  	const q1perp = q1.cross( N );
  	const q0perp = N.cross( q0 );

  	const T = q1perp.mul( st0.x ).add( q0perp.mul( st1.x ) );
  	const B = q1perp.mul( st0.y ).add( q0perp.mul( st1.y ) );

  	const det = T.dot( T ).max( B.dot( B ) );
  	const scale = faceDirection.mul( det.inverseSqrt() );

  	return add( T.mul( mapN.x, scale ), B.mul( mapN.y, scale ), N.mul( mapN.z ) ).normalize();

  } );

  class NormalMapNode extends TempNode {

  	static get type() {

  		return 'NormalMapNode';

  	}

  	constructor( node, scaleNode = null ) {

  		super( 'vec3' );

  		this.node = node;
  		this.scaleNode = scaleNode;

  		this.normalMapType = TangentSpaceNormalMap;

  	}

  	setup( builder ) {

  		const { normalMapType, scaleNode } = this;

  		let normalMap = this.node.mul( 2.0 ).sub( 1.0 );

  		if ( scaleNode !== null ) {

  			normalMap = vec3( normalMap.xy.mul( scaleNode ), normalMap.z );

  		}

  		let outputNode = null;

  		if ( normalMapType === ObjectSpaceNormalMap ) {

  			outputNode = transformNormalToView( normalMap );

  		} else if ( normalMapType === TangentSpaceNormalMap ) {

  			const tangent = builder.hasGeometryAttribute( 'tangent' );

  			if ( tangent === true ) {

  				outputNode = TBNViewMatrix.mul( normalMap ).normalize();

  			} else {

  				outputNode = perturbNormal2Arb( {
  					eye_pos: positionView,
  					surf_norm: normalView,
  					mapN: normalMap,
  					uv: uv()
  				} );

  			}

  		}

  		return outputNode;

  	}

  }

  const normalMap = /*@__PURE__*/ nodeProxy( NormalMapNode );

  // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
  // https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

  const dHdxy_fwd = Fn( ( { textureNode, bumpScale } ) => {

  	// It's used to preserve the same TextureNode instance
  	const sampleTexture = ( callback ) => textureNode.cache().context( { getUV: ( texNode ) => callback( texNode.uvNode || uv() ), forceUVContext: true } );

  	const Hll = float( sampleTexture( ( uvNode ) => uvNode ) );

  	return vec2(
  		float( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),
  		float( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )
  	).mul( bumpScale );

  } );

  // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

  const perturbNormalArb = Fn( ( inputs ) => {

  	const { surf_pos, surf_norm, dHdxy } = inputs;

  	// normalize is done to ensure that the bump map looks the same regardless of the texture's scale
  	const vSigmaX = surf_pos.dFdx().normalize();
  	const vSigmaY = surf_pos.dFdy().normalize();
  	const vN = surf_norm; // normalized

  	const R1 = vSigmaY.cross( vN );
  	const R2 = vN.cross( vSigmaX );

  	const fDet = vSigmaX.dot( R1 ).mul( faceDirection );

  	const vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );

  	return fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();

  } );

  class BumpMapNode extends TempNode {

  	static get type() {

  		return 'BumpMapNode';

  	}

  	constructor( textureNode, scaleNode = null ) {

  		super( 'vec3' );

  		this.textureNode = textureNode;
  		this.scaleNode = scaleNode;

  	}

  	setup() {

  		const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
  		const dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );

  		return perturbNormalArb( {
  			surf_pos: positionView,
  			surf_norm: normalView,
  			dHdxy
  		} );

  	}

  }

  const bumpMap = /*@__PURE__*/ nodeProxy( BumpMapNode );

  const _propertyCache = new Map();

  class MaterialNode extends Node {

  	static get type() {

  		return 'MaterialNode';

  	}

  	constructor( scope ) {

  		super();

  		this.scope = scope;

  	}

  	getCache( property, type ) {

  		let node = _propertyCache.get( property );

  		if ( node === undefined ) {

  			node = materialReference( property, type );

  			_propertyCache.set( property, node );

  		}

  		return node;

  	}

  	getFloat( property ) {

  		return this.getCache( property, 'float' );

  	}

  	getColor( property ) {

  		return this.getCache( property, 'color' );

  	}

  	getTexture( property ) {

  		return this.getCache( property === 'map' ? 'map' : property + 'Map', 'texture' );

  	}

  	setup( builder ) {

  		const material = builder.context.material;
  		const scope = this.scope;

  		let node = null;

  		if ( scope === MaterialNode.COLOR ) {

  			const colorNode = material.color !== undefined ? this.getColor( scope ) : vec3();

  			if ( material.map && material.map.isTexture === true ) {

  				node = colorNode.mul( this.getTexture( 'map' ) );

  			} else {

  				node = colorNode;

  			}

  		} else if ( scope === MaterialNode.OPACITY ) {

  			const opacityNode = this.getFloat( scope );

  			if ( material.alphaMap && material.alphaMap.isTexture === true ) {

  				node = opacityNode.mul( this.getTexture( 'alpha' ) );

  			} else {

  				node = opacityNode;

  			}

  		} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {

  			if ( material.specularMap && material.specularMap.isTexture === true ) {

  				node = this.getTexture( 'specular' ).r;

  			} else {

  				node = float( 1 );

  			}

  		} else if ( scope === MaterialNode.SPECULAR_INTENSITY ) {

  			const specularIntensity = this.getFloat( scope );

  			if ( material.specularMap ) {

  				node = specularIntensity.mul( this.getTexture( scope ).a );

  			} else {

  				node = specularIntensity;

  			}

  		} else if ( scope === MaterialNode.SPECULAR_COLOR ) {

  			const specularColorNode = this.getColor( scope );

  			if ( material.specularColorMap && material.specularColorMap.isTexture === true ) {

  				node = specularColorNode.mul( this.getTexture( scope ).rgb );

  			} else {

  				node = specularColorNode;

  			}

  		} else if ( scope === MaterialNode.ROUGHNESS ) { // TODO: cleanup similar branches

  			const roughnessNode = this.getFloat( scope );

  			if ( material.roughnessMap && material.roughnessMap.isTexture === true ) {

  				node = roughnessNode.mul( this.getTexture( scope ).g );

  			} else {

  				node = roughnessNode;

  			}

  		} else if ( scope === MaterialNode.METALNESS ) {

  			const metalnessNode = this.getFloat( scope );

  			if ( material.metalnessMap && material.metalnessMap.isTexture === true ) {

  				node = metalnessNode.mul( this.getTexture( scope ).b );

  			} else {

  				node = metalnessNode;

  			}

  		} else if ( scope === MaterialNode.EMISSIVE ) {

  			const emissiveIntensityNode = this.getFloat( 'emissiveIntensity' );
  			const emissiveNode = this.getColor( scope ).mul( emissiveIntensityNode );

  			if ( material.emissiveMap && material.emissiveMap.isTexture === true ) {

  				node = emissiveNode.mul( this.getTexture( scope ) );

  			} else {

  				node = emissiveNode;

  			}

  		} else if ( scope === MaterialNode.NORMAL ) {

  			if ( material.normalMap ) {

  				node = normalMap( this.getTexture( 'normal' ), this.getCache( 'normalScale', 'vec2' ) );
  				node.normalMapType = material.normalMapType;

  			} else if ( material.bumpMap ) {

  				node = bumpMap( this.getTexture( 'bump' ).r, this.getFloat( 'bumpScale' ) );

  			} else {

  				node = normalView;

  			}

  		} else if ( scope === MaterialNode.CLEARCOAT ) {

  			const clearcoatNode = this.getFloat( scope );

  			if ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {

  				node = clearcoatNode.mul( this.getTexture( scope ).r );

  			} else {

  				node = clearcoatNode;

  			}

  		} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {

  			const clearcoatRoughnessNode = this.getFloat( scope );

  			if ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {

  				node = clearcoatRoughnessNode.mul( this.getTexture( scope ).r );

  			} else {

  				node = clearcoatRoughnessNode;

  			}

  		} else if ( scope === MaterialNode.CLEARCOAT_NORMAL ) {

  			if ( material.clearcoatNormalMap ) {

  				node = normalMap( this.getTexture( scope ), this.getCache( scope + 'Scale', 'vec2' ) );

  			} else {

  				node = normalView;

  			}

  		} else if ( scope === MaterialNode.SHEEN ) {

  			const sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU

  			if ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {

  				node = sheenNode.mul( this.getTexture( 'sheenColor' ).rgb );

  			} else {

  				node = sheenNode;

  			}

  		} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {

  			const sheenRoughnessNode = this.getFloat( scope );

  			if ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {

  				node = sheenRoughnessNode.mul( this.getTexture( scope ).a );

  			} else {

  				node = sheenRoughnessNode;

  			}

  			node = node.clamp( 0.07, 1.0 );

  		} else if ( scope === MaterialNode.ANISOTROPY ) {

  			if ( material.anisotropyMap && material.anisotropyMap.isTexture === true ) {

  				const anisotropyPolar = this.getTexture( scope );
  				const anisotropyMat = mat2( materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x );

  				node = anisotropyMat.mul( anisotropyPolar.rg.mul( 2.0 ).sub( vec2( 1.0 ) ).normalize().mul( anisotropyPolar.b ) );

  			} else {

  				node = materialAnisotropyVector;

  			}

  		} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {

  			const iridescenceThicknessMaximum = reference( '1', 'float', material.iridescenceThicknessRange );

  			if ( material.iridescenceThicknessMap ) {

  				const iridescenceThicknessMinimum = reference( '0', 'float', material.iridescenceThicknessRange );

  				node = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( scope ).g ).add( iridescenceThicknessMinimum );

  			} else {

  				node = iridescenceThicknessMaximum;

  			}

  		} else if ( scope === MaterialNode.TRANSMISSION ) {

  			const transmissionNode = this.getFloat( scope );

  			if ( material.transmissionMap ) {

  				node = transmissionNode.mul( this.getTexture( scope ).r );

  			} else {

  				node = transmissionNode;

  			}

  		} else if ( scope === MaterialNode.THICKNESS ) {

  			const thicknessNode = this.getFloat( scope );

  			if ( material.thicknessMap ) {

  				node = thicknessNode.mul( this.getTexture( scope ).g );

  			} else {

  				node = thicknessNode;

  			}

  		} else if ( scope === MaterialNode.IOR ) {

  			node = this.getFloat( scope );

  		} else if ( scope === MaterialNode.LIGHT_MAP ) {

  			node = this.getTexture( scope ).rgb.mul( this.getFloat( 'lightMapIntensity' ) );

  		} else if ( scope === MaterialNode.AO_MAP ) {

  			node = this.getTexture( scope ).r.sub( 1.0 ).mul( this.getFloat( 'aoMapIntensity' ) ).add( 1.0 );

  		} else {

  			const outputType = this.getNodeType( builder );

  			node = this.getCache( scope, outputType );

  		}

  		return node;

  	}

  }

  MaterialNode.ALPHA_TEST = 'alphaTest';
  MaterialNode.COLOR = 'color';
  MaterialNode.OPACITY = 'opacity';
  MaterialNode.SHININESS = 'shininess';
  MaterialNode.SPECULAR = 'specular';
  MaterialNode.SPECULAR_STRENGTH = 'specularStrength';
  MaterialNode.SPECULAR_INTENSITY = 'specularIntensity';
  MaterialNode.SPECULAR_COLOR = 'specularColor';
  MaterialNode.REFLECTIVITY = 'reflectivity';
  MaterialNode.ROUGHNESS = 'roughness';
  MaterialNode.METALNESS = 'metalness';
  MaterialNode.NORMAL = 'normal';
  MaterialNode.CLEARCOAT = 'clearcoat';
  MaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';
  MaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';
  MaterialNode.EMISSIVE = 'emissive';
  MaterialNode.ROTATION = 'rotation';
  MaterialNode.SHEEN = 'sheen';
  MaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';
  MaterialNode.ANISOTROPY = 'anisotropy';
  MaterialNode.IRIDESCENCE = 'iridescence';
  MaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';
  MaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';
  MaterialNode.IOR = 'ior';
  MaterialNode.TRANSMISSION = 'transmission';
  MaterialNode.THICKNESS = 'thickness';
  MaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';
  MaterialNode.ATTENUATION_COLOR = 'attenuationColor';
  MaterialNode.LINE_SCALE = 'scale';
  MaterialNode.LINE_DASH_SIZE = 'dashSize';
  MaterialNode.LINE_GAP_SIZE = 'gapSize';
  MaterialNode.LINE_WIDTH = 'linewidth';
  MaterialNode.LINE_DASH_OFFSET = 'dashOffset';
  MaterialNode.POINT_WIDTH = 'pointWidth';
  MaterialNode.DISPERSION = 'dispersion';
  MaterialNode.LIGHT_MAP = 'light';
  MaterialNode.AO_MAP = 'ao';

  const materialAlphaTest = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );
  const materialColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.COLOR );
  const materialShininess = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHININESS );
  const materialEmissive = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );
  const materialOpacity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.OPACITY );
  const materialSpecular = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR );

  const materialSpecularIntensity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_INTENSITY );
  const materialSpecularColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );

  const materialSpecularStrength = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );
  const materialReflectivity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );
  const materialRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );
  const materialMetalness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.METALNESS );
  const materialNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.NORMAL ).context( { getUV: null } );
  const materialClearcoat = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );
  const materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );
  const materialClearcoatNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_NORMAL ).context( { getUV: null } );
  const materialRotation = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROTATION );
  const materialSheen = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN );
  const materialSheenRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );
  const materialAnisotropy = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ANISOTROPY );
  const materialIridescence = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );
  const materialIridescenceIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );
  const materialIridescenceThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );
  const materialTransmission = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.TRANSMISSION );
  const materialThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.THICKNESS );
  const materialIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IOR );
  const materialAttenuationDistance = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_DISTANCE );
  const materialAttenuationColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_COLOR );
  const materialLineScale = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_SCALE );
  const materialLineDashSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_SIZE );
  const materialLineGapSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_GAP_SIZE );
  /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_WIDTH );
  /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_OFFSET );
  /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.POINT_WIDTH );
  const materialDispersion = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.DISPERSION );
  const materialLightMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LIGHT_MAP );
  const materialAOMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.AO_MAP );
  const materialAnisotropyVector = /*@__PURE__*/ uniform( new Vector2() ).onReference( function ( frame ) {

  	return frame.material;

  } ).onRenderUpdate( function ( { material } ) {

  	this.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

  } );

  class ModelViewProjectionNode extends TempNode {

  	static get type() {

  		return 'ModelViewProjectionNode';

  	}

  	constructor( positionNode = null ) {

  		super( 'vec4' );

  		this.positionNode = positionNode;

  	}

  	setup( builder ) {

  		if ( builder.shaderStage === 'fragment' ) {

  			return varying( builder.context.mvp );

  		}

  		const position = this.positionNode || positionLocal;
  		const viewMatrix = builder.renderer.nodes.modelViewMatrix || modelViewMatrix;

  		return cameraProjectionMatrix.mul( viewMatrix ).mul( position );

  	}

  }

  const modelViewProjection = /*@__PURE__*/ nodeProxy( ModelViewProjectionNode );

  class IndexNode extends Node {

  	static get type() {

  		return 'IndexNode';

  	}

  	constructor( scope ) {

  		super( 'uint' );

  		this.scope = scope;

  		this.isInstanceIndexNode = true;

  	}

  	generate( builder ) {

  		const nodeType = this.getNodeType( builder );
  		const scope = this.scope;

  		let propertyName;

  		if ( scope === IndexNode.VERTEX ) {

  			// The index of a vertex within a mesh.
  			propertyName = builder.getVertexIndex();

  		} else if ( scope === IndexNode.INSTANCE ) {

  			// The index of either a mesh instance or an invocation of a compute shader.
  			propertyName = builder.getInstanceIndex();

  		} else if ( scope === IndexNode.DRAW ) {

  			// The index of a draw call.
  			propertyName = builder.getDrawIndex();

  		} else if ( scope === IndexNode.INVOCATION_LOCAL ) {

  			// The index of a compute invocation within the scope of a workgroup load.
  			propertyName = builder.getInvocationLocalIndex();

  		} else if ( scope === IndexNode.INVOCATION_SUBGROUP ) {

  			// The index of a compute invocation within the scope of a subgroup.
  			propertyName = builder.getInvocationSubgroupIndex();

  		} else if ( scope === IndexNode.SUBGROUP ) {

  			// The index of the subgroup the current compute invocation belongs to.
  			propertyName = builder.getSubgroupIndex();

  		} else {

  			throw new Error( 'THREE.IndexNode: Unknown scope: ' + scope );

  		}

  		let output;

  		if ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {

  			output = propertyName;

  		} else {

  			const nodeVarying = varying( this );

  			output = nodeVarying.build( builder, nodeType );

  		}

  		return output;

  	}

  }

  IndexNode.VERTEX = 'vertex';
  IndexNode.INSTANCE = 'instance';
  IndexNode.SUBGROUP = 'subgroup';
  IndexNode.INVOCATION_LOCAL = 'invocationLocal';
  IndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';
  IndexNode.DRAW = 'draw';

  const vertexIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.VERTEX );
  const instanceIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INSTANCE );
  /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.SUBGROUP );
  /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_SUBGROUP );
  /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_LOCAL );
  const drawIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.DRAW );

  class InstanceNode extends Node {

  	static get type() {

  		return 'InstanceNode';

  	}

  	constructor( instanceMesh ) {

  		super( 'void' );

  		this.instanceMesh = instanceMesh;

  		this.instanceMatrixNode = null;

  		this.instanceColorNode = null;

  		this.updateType = NodeUpdateType.FRAME;

  		this.buffer = null;
  		this.bufferColor = null;

  	}

  	setup( builder ) {

  		let instanceMatrixNode = this.instanceMatrixNode;
  		let instanceColorNode = this.instanceColorNode;

  		const instanceMesh = this.instanceMesh;

  		if ( instanceMatrixNode === null ) {

  			const instanceAttribute = instanceMesh.instanceMatrix;

  			// Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.

  			if ( instanceMesh.count <= 1000 ) {

  				instanceMatrixNode = buffer( instanceAttribute.array, 'mat4', Math.max( instanceMesh.count, 1 ) ).element( instanceIndex );

  			} else {

  				const buffer = new InstancedInterleavedBuffer( instanceAttribute.array, 16, 1 );

  				this.buffer = buffer;

  				const bufferFn = instanceAttribute.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;

  				const instanceBuffers = [
  					// F.Signature -> bufferAttribute( array, type, stride, offset )
  					bufferFn( buffer, 'vec4', 16, 0 ),
  					bufferFn( buffer, 'vec4', 16, 4 ),
  					bufferFn( buffer, 'vec4', 16, 8 ),
  					bufferFn( buffer, 'vec4', 16, 12 )
  				];

  				instanceMatrixNode = mat4( ...instanceBuffers );

  			}

  			this.instanceMatrixNode = instanceMatrixNode;

  		}

  		const instanceColorAttribute = instanceMesh.instanceColor;

  		if ( instanceColorAttribute && instanceColorNode === null ) {

  			const buffer = new InstancedBufferAttribute( instanceColorAttribute.array, 3 );

  			const bufferFn = instanceColorAttribute.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;

  			this.bufferColor = buffer;

  			instanceColorNode = vec3( bufferFn( buffer, 'vec3', 3, 0 ) );

  			this.instanceColorNode = instanceColorNode;

  		}

  		// POSITION

  		const instancePosition = instanceMatrixNode.mul( positionLocal ).xyz;
  		positionLocal.assign( instancePosition );

  		// NORMAL

  		if ( builder.hasGeometryAttribute( 'normal' ) ) {

  			const instanceNormal = transformNormal( normalLocal, instanceMatrixNode );

  			// ASSIGNS

  			normalLocal.assign( instanceNormal );

  		}

  		// COLOR

  		if ( this.instanceColorNode !== null ) {

  			varyingProperty( 'vec3', 'vInstanceColor' ).assign( this.instanceColorNode );

  		}

  	}

  	update( /*frame*/ ) {

  		if ( this.instanceMesh.instanceMatrix.usage !== DynamicDrawUsage && this.buffer != null && this.instanceMesh.instanceMatrix.version !== this.buffer.version ) {

  			this.buffer.version = this.instanceMesh.instanceMatrix.version;

  		}

  		if ( this.instanceMesh.instanceColor && this.instanceMesh.instanceColor.usage !== DynamicDrawUsage && this.bufferColor != null && this.instanceMesh.instanceColor.version !== this.bufferColor.version ) {

  			this.bufferColor.version = this.instanceMesh.instanceColor.version;

  		}

  	}

  }

  const instance = /*@__PURE__*/ nodeProxy( InstanceNode );

  class BatchNode extends Node {

  	static get type() {

  		return 'BatchNode';

  	}

  	constructor( batchMesh ) {

  		super( 'void' );

  		this.batchMesh = batchMesh;


  		this.batchingIdNode = null;

  	}

  	setup( builder ) {

  		// POSITION

  		if ( this.batchingIdNode === null ) {

  			if ( builder.getDrawIndex() === null ) {

  				this.batchingIdNode = instanceIndex;

  			} else {

  				this.batchingIdNode = drawIndex;

  			}

  		}

  		const getIndirectIndex = Fn( ( [ id ] ) => {

  			const size = textureSize( textureLoad( this.batchMesh._indirectTexture ), 0 );
  			const x = int( id ).modInt( int( size ) );
  			const y = int( id ).div( int( size ) );
  			return textureLoad( this.batchMesh._indirectTexture, ivec2( x, y ) ).x;

  		} ).setLayout( {
  			name: 'getIndirectIndex',
  			type: 'uint',
  			inputs: [
  				{ name: 'id', type: 'int' }
  			]
  		} );

  		const indirectId = getIndirectIndex( int( this.batchingIdNode ) );

  		const matricesTexture = this.batchMesh._matricesTexture;

  		const size = textureSize( textureLoad( matricesTexture ), 0 );
  		const j = float( indirectId ).mul( 4 ).toInt().toVar();

  		const x = j.modInt( size );
  		const y = j.div( int( size ) );
  		const batchingMatrix = mat4(
  			textureLoad( matricesTexture, ivec2( x, y ) ),
  			textureLoad( matricesTexture, ivec2( x.add( 1 ), y ) ),
  			textureLoad( matricesTexture, ivec2( x.add( 2 ), y ) ),
  			textureLoad( matricesTexture, ivec2( x.add( 3 ), y ) )
  		);


  		const colorsTexture = this.batchMesh._colorsTexture;

  		if ( colorsTexture !== null ) {

  			const getBatchingColor = Fn( ( [ id ] ) => {

  				const size = textureSize( textureLoad( colorsTexture ), 0 ).x;
  				const j = id;
  				const x = j.modInt( size );
  				const y = j.div( size );
  				return textureLoad( colorsTexture, ivec2( x, y ) ).rgb;

  			} ).setLayout( {
  				name: 'getBatchingColor',
  				type: 'vec3',
  				inputs: [
  					{ name: 'id', type: 'int' }
  				]
  			} );

  			const color = getBatchingColor( indirectId );

  			varyingProperty( 'vec3', 'vBatchColor' ).assign( color );

  		}

  		const bm = mat3( batchingMatrix );

  		positionLocal.assign( batchingMatrix.mul( positionLocal ) );

  		const transformedNormal = normalLocal.div( vec3( bm[ 0 ].dot( bm[ 0 ] ), bm[ 1 ].dot( bm[ 1 ] ), bm[ 2 ].dot( bm[ 2 ] ) ) );

  		const batchingNormal = bm.mul( transformedNormal ).xyz;

  		normalLocal.assign( batchingNormal );

  		if ( builder.hasGeometryAttribute( 'tangent' ) ) {

  			tangentLocal.mulAssign( bm );

  		}

  	}

  }

  const batch = /*@__PURE__*/ nodeProxy( BatchNode );

  const _frameId = new WeakMap();

  class SkinningNode extends Node {

  	static get type() {

  		return 'SkinningNode';

  	}

  	constructor( skinnedMesh, useReference = false ) {

  		super( 'void' );

  		this.skinnedMesh = skinnedMesh;
  		this.useReference = useReference;

  		this.updateType = NodeUpdateType.OBJECT;

  		//

  		this.skinIndexNode = attribute( 'skinIndex', 'uvec4' );
  		this.skinWeightNode = attribute( 'skinWeight', 'vec4' );

  		let bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;

  		if ( useReference ) {

  			bindMatrixNode = reference( 'bindMatrix', 'mat4' );
  			bindMatrixInverseNode = reference( 'bindMatrixInverse', 'mat4' );
  			boneMatricesNode = referenceBuffer( 'skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );

  		} else {

  			bindMatrixNode = uniform( skinnedMesh.bindMatrix, 'mat4' );
  			bindMatrixInverseNode = uniform( skinnedMesh.bindMatrixInverse, 'mat4' );
  			boneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );

  		}

  		this.bindMatrixNode = bindMatrixNode;
  		this.bindMatrixInverseNode = bindMatrixInverseNode;
  		this.boneMatricesNode = boneMatricesNode;
  		this.previousBoneMatricesNode = null;

  	}

  	getSkinnedPosition( boneMatrices = this.boneMatricesNode, position = positionLocal ) {

  		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;

  		const boneMatX = boneMatrices.element( skinIndexNode.x );
  		const boneMatY = boneMatrices.element( skinIndexNode.y );
  		const boneMatZ = boneMatrices.element( skinIndexNode.z );
  		const boneMatW = boneMatrices.element( skinIndexNode.w );

  		// POSITION

  		const skinVertex = bindMatrixNode.mul( position );

  		const skinned = add(
  			boneMatX.mul( skinWeightNode.x ).mul( skinVertex ),
  			boneMatY.mul( skinWeightNode.y ).mul( skinVertex ),
  			boneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),
  			boneMatW.mul( skinWeightNode.w ).mul( skinVertex )
  		);

  		return bindMatrixInverseNode.mul( skinned ).xyz;

  	}

  	getSkinnedNormal( boneMatrices = this.boneMatricesNode, normal = normalLocal ) {

  		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;

  		const boneMatX = boneMatrices.element( skinIndexNode.x );
  		const boneMatY = boneMatrices.element( skinIndexNode.y );
  		const boneMatZ = boneMatrices.element( skinIndexNode.z );
  		const boneMatW = boneMatrices.element( skinIndexNode.w );

  		// NORMAL

  		let skinMatrix = add(
  			skinWeightNode.x.mul( boneMatX ),
  			skinWeightNode.y.mul( boneMatY ),
  			skinWeightNode.z.mul( boneMatZ ),
  			skinWeightNode.w.mul( boneMatW )
  		);

  		skinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );

  		return skinMatrix.transformDirection( normal ).xyz;

  	}

  	getPreviousSkinnedPosition( builder ) {

  		const skinnedMesh = builder.object;

  		if ( this.previousBoneMatricesNode === null ) {

  			skinnedMesh.skeleton.previousBoneMatrices = new Float32Array( skinnedMesh.skeleton.boneMatrices );

  			this.previousBoneMatricesNode = referenceBuffer( 'skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );

  		}

  		return this.getSkinnedPosition( this.previousBoneMatricesNode, positionPrevious );

  	}

  	needsPreviousBoneMatrices( builder ) {

  		const mrt = builder.renderer.getMRT();

  		return mrt && mrt.has( 'velocity' );

  	}

  	setup( builder ) {

  		if ( this.needsPreviousBoneMatrices( builder ) ) {

  			positionPrevious.assign( this.getPreviousSkinnedPosition( builder ) );

  		}

  		const skinPosition = this.getSkinnedPosition();


  		positionLocal.assign( skinPosition );

  		if ( builder.hasGeometryAttribute( 'normal' ) ) {

  			const skinNormal = this.getSkinnedNormal();

  			normalLocal.assign( skinNormal );

  			if ( builder.hasGeometryAttribute( 'tangent' ) ) {

  				tangentLocal.assign( skinNormal );

  			}

  		}

  	}

  	generate( builder, output ) {

  		if ( output !== 'void' ) {

  			return positionLocal.build( builder, output );

  		}

  	}

  	update( frame ) {

  		const object = this.useReference ? frame.object : this.skinnedMesh;
  		const skeleton = object.skeleton;

  		if ( _frameId.get( skeleton ) === frame.frameId ) return;

  		_frameId.set( skeleton, frame.frameId );

  		if ( this.previousBoneMatricesNode !== null ) skeleton.previousBoneMatrices.set( skeleton.boneMatrices );

  		skeleton.update();

  	}

  }
  const skinningReference = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh, true ) );

  class LoopNode extends Node {

  	static get type() {

  		return 'LoopNode';

  	}

  	constructor( params = [] ) {

  		super();

  		this.params = params;

  	}

  	getVarName( index ) {

  		return String.fromCharCode( 'i'.charCodeAt() + index );

  	}

  	getProperties( builder ) {

  		const properties = builder.getNodeProperties( this );

  		if ( properties.stackNode !== undefined ) return properties;

  		//

  		const inputs = {};

  		for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

  			const param = this.params[ i ];

  			const name = ( param.isNode !== true && param.name ) || this.getVarName( i );
  			const type = ( param.isNode !== true && param.type ) || 'int';

  			inputs[ name ] = expression( name, type );

  		}

  		const stack = builder.addStack(); // TODO: cache() it

  		properties.returnsNode = this.params[ this.params.length - 1 ]( inputs, stack, builder );
  		properties.stackNode = stack;

  		builder.removeStack();

  		return properties;

  	}

  	getNodeType( builder ) {

  		const { returnsNode } = this.getProperties( builder );

  		return returnsNode ? returnsNode.getNodeType( builder ) : 'void';

  	}

  	setup( builder ) {

  		// setup properties

  		this.getProperties( builder );

  	}

  	generate( builder ) {

  		const properties = this.getProperties( builder );

  		const params = this.params;
  		const stackNode = properties.stackNode;

  		for ( let i = 0, l = params.length - 1; i < l; i ++ ) {

  			const param = params[ i ];

  			let start = null, end = null, name = null, type = null, condition = null, update = null;

  			if ( param.isNode ) {

  				type = 'int';
  				name = this.getVarName( i );
  				start = '0';
  				end = param.build( builder, type );
  				condition = '<';

  			} else {

  				type = param.type || 'int';
  				name = param.name || this.getVarName( i );
  				start = param.start;
  				end = param.end;
  				condition = param.condition;
  				update = param.update;

  				if ( typeof start === 'number' ) start = start.toString();
  				else if ( start && start.isNode ) start = start.build( builder, type );

  				if ( typeof end === 'number' ) end = end.toString();
  				else if ( end && end.isNode ) end = end.build( builder, type );

  				if ( start !== undefined && end === undefined ) {

  					start = start + ' - 1';
  					end = '0';
  					condition = '>=';

  				} else if ( end !== undefined && start === undefined ) {

  					start = '0';
  					condition = '<';

  				}

  				if ( condition === undefined ) {

  					if ( Number( start ) > Number( end ) ) {

  						condition = '>=';

  					} else {

  						condition = '<';

  					}

  				}

  			}

  			const internalParam = { start, end, condition };

  			//

  			const startSnippet = internalParam.start;
  			const endSnippet = internalParam.end;

  			let declarationSnippet = '';
  			let conditionalSnippet = '';
  			let updateSnippet = '';

  			if ( ! update ) {

  				if ( type === 'int' || type === 'uint' ) {

  					if ( condition.includes( '<' ) ) update = '++';
  					else update = '--';

  				} else {

  					if ( condition.includes( '<' ) ) update = '+= 1.';
  					else update = '-= 1.';

  				}

  			}

  			declarationSnippet += builder.getVar( type, name ) + ' = ' + startSnippet;

  			conditionalSnippet += name + ' ' + condition + ' ' + endSnippet;
  			updateSnippet += name + ' ' + update;

  			const forSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;

  			builder.addFlowCode( ( i === 0 ? '\n' : '' ) + builder.tab + forSnippet + ' {\n\n' ).addFlowTab();

  		}

  		const stackSnippet = stackNode.build( builder, 'void' );

  		const returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';

  		builder.removeFlowTab().addFlowCode( '\n' + builder.tab + stackSnippet );

  		for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

  			builder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\n\n' ).removeFlowTab();

  		}

  		builder.addFlowTab();

  		return returnsSnippet;

  	}

  }

  const Loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) ).append();
  const Break = () => expression( 'break' ).append();

  const _morphTextures = /*@__PURE__*/ new WeakMap();
  const _morphVec4 = /*@__PURE__*/ new Vector4();

  const getMorph = /*@__PURE__*/ Fn( ( { bufferMap, influence, stride, width, depth, offset } ) => {

  	const texelIndex = int( vertexIndex ).mul( stride ).add( offset );

  	const y = texelIndex.div( width );
  	const x = texelIndex.sub( y.mul( width ) );

  	const bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth );

  	return bufferAttrib.mul( influence );

  } );

  function getEntry( geometry ) {

  	const hasMorphPosition = geometry.morphAttributes.position !== undefined;
  	const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
  	const hasMorphColors = geometry.morphAttributes.color !== undefined;

  	// instead of using attributes, the WebGL 2 code path encodes morph targets
  	// into an array of data textures. Each layer represents a single morph target.

  	const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  	const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

  	let entry = _morphTextures.get( geometry );

  	if ( entry === undefined || entry.count !== morphTargetsCount ) {

  		if ( entry !== undefined ) entry.texture.dispose();

  		const morphTargets = geometry.morphAttributes.position || [];
  		const morphNormals = geometry.morphAttributes.normal || [];
  		const morphColors = geometry.morphAttributes.color || [];

  		let vertexDataCount = 0;

  		if ( hasMorphPosition === true ) vertexDataCount = 1;
  		if ( hasMorphNormals === true ) vertexDataCount = 2;
  		if ( hasMorphColors === true ) vertexDataCount = 3;

  		let width = geometry.attributes.position.count * vertexDataCount;
  		let height = 1;

  		const maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'

  		if ( width > maxTextureSize ) {

  			height = Math.ceil( width / maxTextureSize );
  			width = maxTextureSize;

  		}

  		const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

  		const bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
  		bufferTexture.type = FloatType;
  		bufferTexture.needsUpdate = true;

  		// fill buffer

  		const vertexDataStride = vertexDataCount * 4;

  		for ( let i = 0; i < morphTargetsCount; i ++ ) {

  			const morphTarget = morphTargets[ i ];
  			const morphNormal = morphNormals[ i ];
  			const morphColor = morphColors[ i ];

  			const offset = width * height * 4 * i;

  			for ( let j = 0; j < morphTarget.count; j ++ ) {

  				const stride = j * vertexDataStride;

  				if ( hasMorphPosition === true ) {

  					_morphVec4.fromBufferAttribute( morphTarget, j );

  					buffer[ offset + stride + 0 ] = _morphVec4.x;
  					buffer[ offset + stride + 1 ] = _morphVec4.y;
  					buffer[ offset + stride + 2 ] = _morphVec4.z;
  					buffer[ offset + stride + 3 ] = 0;

  				}

  				if ( hasMorphNormals === true ) {

  					_morphVec4.fromBufferAttribute( morphNormal, j );

  					buffer[ offset + stride + 4 ] = _morphVec4.x;
  					buffer[ offset + stride + 5 ] = _morphVec4.y;
  					buffer[ offset + stride + 6 ] = _morphVec4.z;
  					buffer[ offset + stride + 7 ] = 0;

  				}

  				if ( hasMorphColors === true ) {

  					_morphVec4.fromBufferAttribute( morphColor, j );

  					buffer[ offset + stride + 8 ] = _morphVec4.x;
  					buffer[ offset + stride + 9 ] = _morphVec4.y;
  					buffer[ offset + stride + 10 ] = _morphVec4.z;
  					buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? _morphVec4.w : 1;

  				}

  			}

  		}

  		entry = {
  			count: morphTargetsCount,
  			texture: bufferTexture,
  			stride: vertexDataCount,
  			size: new Vector2( width, height )
  		};

  		_morphTextures.set( geometry, entry );

  		function disposeTexture() {

  			bufferTexture.dispose();

  			_morphTextures.delete( geometry );

  			geometry.removeEventListener( 'dispose', disposeTexture );

  		}

  		geometry.addEventListener( 'dispose', disposeTexture );

  	}

  	return entry;

  }


  class MorphNode extends Node {

  	static get type() {

  		return 'MorphNode';

  	}

  	constructor( mesh ) {

  		super( 'void' );

  		this.mesh = mesh;
  		this.morphBaseInfluence = uniform( 1 );

  		this.updateType = NodeUpdateType.OBJECT;

  	}

  	setup( builder ) {

  		const { geometry } = builder;

  		const hasMorphPosition = geometry.morphAttributes.position !== undefined;
  		const hasMorphNormals = geometry.hasAttribute( 'normal' ) && geometry.morphAttributes.normal !== undefined;

  		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

  		// nodes

  		const { texture: bufferMap, stride, size } = getEntry( geometry );

  		if ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );
  		if ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );

  		const width = int( size.width );

  		Loop( morphTargetsCount, ( { i } ) => {

  			const influence = float( 0 ).toVar();

  			if ( this.mesh.count > 1 && ( this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined ) ) {

  				influence.assign( textureLoad( this.mesh.morphTexture, ivec2( int( i ).add( 1 ), int( instanceIndex ) ) ).r );

  			} else {

  				influence.assign( reference( 'morphTargetInfluences', 'float' ).element( i ).toVar() );

  			}

  			if ( hasMorphPosition === true ) {

  				positionLocal.addAssign( getMorph( {
  					bufferMap,
  					influence,
  					stride,
  					width,
  					depth: i,
  					offset: int( 0 )
  				} ) );

  			}

  			if ( hasMorphNormals === true ) {

  				normalLocal.addAssign( getMorph( {
  					bufferMap,
  					influence,
  					stride,
  					width,
  					depth: i,
  					offset: int( 1 )
  				} ) );

  			}

  		} );

  	}

  	update() {

  		const morphBaseInfluence = this.morphBaseInfluence;

  		if ( this.mesh.geometry.morphTargetsRelative ) {

  			morphBaseInfluence.value = 1;

  		} else {

  			morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );

  		}

  	}

  }

  const morphReference = /*@__PURE__*/ nodeProxy( MorphNode );

  const sortLights = ( lights ) => {

  	return lights.sort( ( a, b ) => a.id - b.id );

  };

  const getLightNodeById = ( id, lightNodes ) => {

  	for ( const lightNode of lightNodes ) {

  		if ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {

  			return lightNode;

  		}

  	}

  	return null;

  };

  const _lightsNodeRef = /*@__PURE__*/ new WeakMap();

  class LightsNode extends Node {

  	static get type() {

  		return 'LightsNode';

  	}

  	constructor( lights = [] ) {

  		super( 'vec3' );

  		this.totalDiffuseNode = vec3().toVar( 'totalDiffuse' );
  		this.totalSpecularNode = vec3().toVar( 'totalSpecular' );

  		this.outgoingLightNode = vec3().toVar( 'outgoingLight' );

  		this._lights = lights;

  		this._lightNodes = null;
  		this._lightNodesHash = null;

  		this.global = true;

  	}

  	getHash( builder ) {

  		if ( this._lightNodesHash === null ) {

  			if ( this._lightNodes === null ) this.setupLightsNode( builder );

  			const hash = [];

  			for ( const lightNode of this._lightNodes ) {

  				hash.push( lightNode.getHash() );

  			}

  			this._lightNodesHash = 'lights-' + hash.join( ',' );

  		}

  		return this._lightNodesHash;

  	}

  	analyze( builder ) {

  		const properties = builder.getDataFromNode( this );

  		for ( const node of properties.nodes ) {

  			node.build( builder );

  		}

  	}

  	setupLightsNode( builder ) {

  		const lightNodes = [];

  		const previousLightNodes = this._lightNodes;

  		const lights = sortLights( this._lights );
  		const nodeLibrary = builder.renderer.nodes.library;

  		for ( const light of lights ) {

  			if ( light.isNode ) {

  				lightNodes.push( nodeObject( light ) );

  			} else {

  				let lightNode = null;

  				if ( previousLightNodes !== null ) {

  					lightNode = getLightNodeById( light.id, previousLightNodes ); // resuse existing light node

  				}

  				if ( lightNode === null ) {

  					const lightNodeClass = nodeLibrary.getLightNodeClass( light.constructor );

  					if ( lightNodeClass === null ) {

  						console.warn( `LightsNode.setupNodeLights: Light node not found for ${ light.constructor.name }` );
  						continue;

  					}

  					let lightNode = null;

  					if ( ! _lightsNodeRef.has( light ) ) {

  						lightNode = new lightNodeClass( light );
  						_lightsNodeRef.set( light, lightNode );

  					} else {

  						lightNode = _lightsNodeRef.get( light );

  					}

  					lightNodes.push( lightNode );

  				}

  			}

  		}

  		this._lightNodes = lightNodes;

  	}

  	setup( builder ) {

  		if ( this._lightNodes === null ) this.setupLightsNode( builder );

  		const context = builder.context;
  		const lightingModel = context.lightingModel;

  		let outgoingLightNode = this.outgoingLightNode;

  		if ( lightingModel ) {

  			const { _lightNodes, totalDiffuseNode, totalSpecularNode } = this;

  			context.outgoingLight = outgoingLightNode;

  			const stack = builder.addStack();

  			//

  			const properties = builder.getDataFromNode( this );
  			properties.nodes = stack.nodes;

  			//

  			lightingModel.start( context, stack, builder );

  			// lights

  			for ( const lightNode of _lightNodes ) {

  				lightNode.build( builder );

  			}

  			//

  			lightingModel.indirect( context, stack, builder );

  			//

  			const { backdrop, backdropAlpha } = context;
  			const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;

  			let totalDiffuse = directDiffuse.add( indirectDiffuse );

  			if ( backdrop !== null ) {

  				if ( backdropAlpha !== null ) {

  					totalDiffuse = vec3( backdropAlpha.mix( totalDiffuse, backdrop ) );

  				} else {

  					totalDiffuse = vec3( backdrop );

  				}

  				context.material.transparent = true;

  			}

  			totalDiffuseNode.assign( totalDiffuse );
  			totalSpecularNode.assign( directSpecular.add( indirectSpecular ) );

  			outgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );

  			//

  			lightingModel.finish( context, stack, builder );

  			//

  			outgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );

  		}

  		return outgoingLightNode;

  	}

  	setLights( lights ) {

  		this._lights = lights;

  		this._lightNodes = null;
  		this._lightNodesHash = null;

  		return this;

  	}

  	getLights() {

  		return this._lights;

  	}

  }

  const lights = /*@__PURE__*/ nodeProxy( LightsNode );

  class LightingNode extends Node {

  	static get type() {

  		return 'LightingNode';

  	}

  	constructor() {

  		super( 'vec3' );

  		this.isLightingNode = true;

  	}

  	generate( /*builder*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  }

  class AONode extends LightingNode {

  	static get type() {

  		return 'AONode';

  	}

  	constructor( aoNode = null ) {

  		super();

  		this.aoNode = aoNode;

  	}

  	setup( builder ) {

  		builder.context.ambientOcclusion.mulAssign( this.aoNode );

  	}

  }

  class LightingContextNode extends ContextNode {

  	static get type() {

  		return 'LightingContextNode';

  	}

  	constructor( node, lightingModel = null, backdropNode = null, backdropAlphaNode = null ) {

  		super( node );

  		this.lightingModel = lightingModel;
  		this.backdropNode = backdropNode;
  		this.backdropAlphaNode = backdropAlphaNode;

  		this._value = null;

  	}

  	getContext() {

  		const { backdropNode, backdropAlphaNode } = this;

  		const directDiffuse = vec3().toVar( 'directDiffuse' ),
  			directSpecular = vec3().toVar( 'directSpecular' ),
  			indirectDiffuse = vec3().toVar( 'indirectDiffuse' ),
  			indirectSpecular = vec3().toVar( 'indirectSpecular' );

  		const reflectedLight = {
  			directDiffuse,
  			directSpecular,
  			indirectDiffuse,
  			indirectSpecular
  		};

  		const context = {
  			radiance: vec3().toVar( 'radiance' ),
  			irradiance: vec3().toVar( 'irradiance' ),
  			iblIrradiance: vec3().toVar( 'iblIrradiance' ),
  			ambientOcclusion: float( 1 ).toVar( 'ambientOcclusion' ),
  			reflectedLight,
  			backdrop: backdropNode,
  			backdropAlpha: backdropAlphaNode
  		};

  		return context;

  	}

  	setup( builder ) {

  		this.value = this._value || ( this._value = this.getContext() );
  		this.value.lightingModel = this.lightingModel || builder.context.lightingModel;

  		return super.setup( builder );

  	}

  }

  const lightingContext = /*@__PURE__*/ nodeProxy( LightingContextNode );

  class IrradianceNode extends LightingNode {

  	static get type() {

  		return 'IrradianceNode';

  	}

  	constructor( node ) {

  		super();

  		this.node = node;

  	}

  	setup( builder ) {

  		builder.context.irradiance.addAssign( this.node );

  	}

  }

  let screenSizeVec, viewportVec;

  class ScreenNode extends Node {

  	static get type() {

  		return 'ScreenNode';

  	}

  	constructor( scope ) {

  		super();

  		this.scope = scope;

  		this.isViewportNode = true;

  	}

  	getNodeType() {

  		if ( this.scope === ScreenNode.VIEWPORT ) return 'vec4';
  		else return 'vec2';

  	}

  	getUpdateType() {

  		let updateType = NodeUpdateType.NONE;

  		if ( this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT ) {

  			updateType = NodeUpdateType.RENDER;

  		}

  		this.updateType = updateType;

  		return updateType;

  	}

  	update( { renderer } ) {

  		const renderTarget = renderer.getRenderTarget();

  		if ( this.scope === ScreenNode.VIEWPORT ) {

  			if ( renderTarget !== null ) {

  				viewportVec.copy( renderTarget.viewport );

  			} else {

  				renderer.getViewport( viewportVec );

  				viewportVec.multiplyScalar( renderer.getPixelRatio() );

  			}

  		} else {

  			if ( renderTarget !== null ) {

  				screenSizeVec.width = renderTarget.width;
  				screenSizeVec.height = renderTarget.height;

  			} else {

  				renderer.getDrawingBufferSize( screenSizeVec );

  			}

  		}

  	}

  	setup( /*builder*/ ) {

  		const scope = this.scope;

  		let output = null;

  		if ( scope === ScreenNode.SIZE ) {

  			output = uniform( screenSizeVec || ( screenSizeVec = new Vector2() ) );

  		} else if ( scope === ScreenNode.VIEWPORT ) {

  			output = uniform( viewportVec || ( viewportVec = new Vector4() ) );

  		} else {

  			output = vec2( screenCoordinate.div( screenSize ) );

  		}

  		return output;

  	}

  	generate( builder ) {

  		if ( this.scope === ScreenNode.COORDINATE ) {

  			let coord = builder.getFragCoord();

  			if ( builder.isFlipY() ) {

  				// follow webgpu standards

  				const size = builder.getNodeProperties( screenSize ).outputNode.build( builder );

  				coord = `${ builder.getType( 'vec2' ) }( ${ coord }.x, ${ size }.y - ${ coord }.y )`;

  			}

  			return coord;

  		}

  		return super.generate( builder );

  	}

  }

  ScreenNode.COORDINATE = 'coordinate';
  ScreenNode.VIEWPORT = 'viewport';
  ScreenNode.SIZE = 'size';
  ScreenNode.UV = 'uv';

  // Screen

  const screenUV = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.UV );
  const screenSize = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.SIZE );
  const screenCoordinate = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.COORDINATE );

  // Viewport

  const viewport = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.VIEWPORT );
  viewport.zw;
  /*@__PURE__*/ screenCoordinate.sub( viewport.xy );

  const _size$a = /*@__PURE__*/ new Vector2();

  class ViewportTextureNode extends TextureNode {

  	static get type() {

  		return 'ViewportTextureNode';

  	}

  	constructor( uvNode = screenUV, levelNode = null, framebufferTexture = null ) {

  		if ( framebufferTexture === null ) {

  			framebufferTexture = new FramebufferTexture();
  			framebufferTexture.minFilter = LinearMipmapLinearFilter;

  		}

  		super( framebufferTexture, uvNode, levelNode );

  		this.generateMipmaps = false;

  		this.isOutputTextureNode = true;

  		this.updateBeforeType = NodeUpdateType.FRAME;

  	}

  	updateBefore( frame ) {

  		const renderer = frame.renderer;
  		renderer.getDrawingBufferSize( _size$a );

  		//

  		const framebufferTexture = this.value;

  		if ( framebufferTexture.image.width !== _size$a.width || framebufferTexture.image.height !== _size$a.height ) {

  			framebufferTexture.image.width = _size$a.width;
  			framebufferTexture.image.height = _size$a.height;
  			framebufferTexture.needsUpdate = true;

  		}

  		//

  		const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
  		framebufferTexture.generateMipmaps = this.generateMipmaps;

  		renderer.copyFramebufferToTexture( framebufferTexture );

  		framebufferTexture.generateMipmaps = currentGenerateMipmaps;

  	}

  	clone() {

  		const viewportTextureNode = new this.constructor( this.uvNode, this.levelNode, this.value );
  		viewportTextureNode.generateMipmaps = this.generateMipmaps;

  		return viewportTextureNode;

  	}

  }
  const viewportMipTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } );

  let sharedDepthbuffer = null;

  class ViewportDepthTextureNode extends ViewportTextureNode {

  	static get type() {

  		return 'ViewportDepthTextureNode';

  	}

  	constructor( uvNode = screenUV, levelNode = null ) {

  		if ( sharedDepthbuffer === null ) {

  			sharedDepthbuffer = new DepthTexture();

  		}

  		super( uvNode, levelNode, sharedDepthbuffer );

  	}

  }

  const viewportDepthTexture = /*@__PURE__*/ nodeProxy( ViewportDepthTextureNode );

  class ViewportDepthNode extends Node {

  	static get type() {

  		return 'ViewportDepthNode';

  	}

  	constructor( scope, valueNode = null ) {

  		super( 'float' );

  		this.scope = scope;
  		this.valueNode = valueNode;

  		this.isViewportDepthNode = true;

  	}

  	generate( builder ) {

  		const { scope } = this;

  		if ( scope === ViewportDepthNode.DEPTH_BASE ) {

  			return builder.getFragDepth();

  		}

  		return super.generate( builder );

  	}

  	setup( { camera } ) {

  		const { scope } = this;
  		const value = this.valueNode;

  		let node = null;

  		if ( scope === ViewportDepthNode.DEPTH_BASE ) {

  			if ( value !== null ) {

   				node = depthBase().assign( value );

  			}

  		} else if ( scope === ViewportDepthNode.DEPTH ) {

  			if ( camera.isPerspectiveCamera ) {

  				node = viewZToPerspectiveDepth( positionView.z, cameraNear, cameraFar );

  			} else {

  				node = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

  			}

  		} else if ( scope === ViewportDepthNode.LINEAR_DEPTH ) {

  			if ( value !== null ) {

  				if ( camera.isPerspectiveCamera ) {

  					const viewZ = perspectiveDepthToViewZ( value, cameraNear, cameraFar );

  					node = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

  				} else {

  					node = value;

  				}

  			} else {

  				node = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

  			}

  		}

  		return node;

  	}

  }

  ViewportDepthNode.DEPTH_BASE = 'depthBase';
  ViewportDepthNode.DEPTH = 'depth';
  ViewportDepthNode.LINEAR_DEPTH = 'linearDepth';

  // NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera

  // -near maps to 0; -far maps to 1
  const viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );

  // NOTE: https://twitter.com/gonnavis/status/1377183786949959682

  // -near maps to 0; -far maps to 1
  const viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( far.sub( near ).mul( viewZ ) );

  // maps perspective depth in [ 0, 1 ] to viewZ
  const perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );

  const depthBase = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_BASE );

  const depth = /*@__PURE__*/ nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );
  const linearDepth = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH );
  /*@__PURE__*/ linearDepth( viewportDepthTexture() );

  depth.assign = ( value ) => depthBase( value );

  class ClippingNode extends Node {

  	static get type() {

  		return 'ClippingNode';

  	}

  	constructor( scope = ClippingNode.DEFAULT ) {

  		super();

  		this.scope = scope;

  	}

  	setup( builder ) {

  		super.setup( builder );

  		const clippingContext = builder.clippingContext;
  		const { localClipIntersection, localClippingCount, globalClippingCount } = clippingContext;

  		const numClippingPlanes = globalClippingCount + localClippingCount;
  		const numUnionClippingPlanes = localClipIntersection ? numClippingPlanes - localClippingCount : numClippingPlanes;

  		if ( this.scope === ClippingNode.ALPHA_TO_COVERAGE ) {

  			return this.setupAlphaToCoverage( clippingContext.planes, numClippingPlanes, numUnionClippingPlanes );

  		} else {

  			return this.setupDefault( clippingContext.planes, numClippingPlanes, numUnionClippingPlanes );

  		}

  	}

  	setupAlphaToCoverage( planes, numClippingPlanes, numUnionClippingPlanes ) {

  		return Fn( () => {

  			const clippingPlanes = uniformArray( planes );

  			const distanceToPlane = property( 'float', 'distanceToPlane' );
  			const distanceGradient = property( 'float', 'distanceToGradient' );

  			const clipOpacity = property( 'float', 'clipOpacity' );

  			clipOpacity.assign( 1 );

  			let plane;

  			Loop( numUnionClippingPlanes, ( { i } ) => {

  				plane = clippingPlanes.element( i );

  				distanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );
  				distanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );

  				clipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ) );

  				clipOpacity.equal( 0.0 ).discard();

  			} );

  			if ( numUnionClippingPlanes < numClippingPlanes ) {

  				const unionClipOpacity = property( 'float', 'unionclipOpacity' );

  				unionClipOpacity.assign( 1 );

  				Loop( { start: numUnionClippingPlanes, end: numClippingPlanes }, ( { i } ) => {

  					plane = clippingPlanes.element( i );

  					distanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );
  					distanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );

  					unionClipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ).oneMinus() );

  				} );

  				clipOpacity.mulAssign( unionClipOpacity.oneMinus() );

  			}

  			diffuseColor.a.mulAssign( clipOpacity );

  			diffuseColor.a.equal( 0.0 ).discard();

  		} )();

  	}

  	setupDefault( planes, numClippingPlanes, numUnionClippingPlanes ) {

  		return Fn( () => {

  			const clippingPlanes = uniformArray( planes );

  			let plane;

  			Loop( numUnionClippingPlanes, ( { i } ) => {

  				plane = clippingPlanes.element( i );
  				positionView.dot( plane.xyz ).greaterThan( plane.w ).discard();

  			} );

  			if ( numUnionClippingPlanes < numClippingPlanes ) {

  				const clipped = property( 'bool', 'clipped' );

  				clipped.assign( true );

  				Loop( { start: numUnionClippingPlanes, end: numClippingPlanes }, ( { i } ) => {

  					plane = clippingPlanes.element( i );
  					clipped.assign( positionView.dot( plane.xyz ).greaterThan( plane.w ).and( clipped ) );

  				} );

  				clipped.discard();

  			}

  		} )();

  	}

  }

  ClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';
  ClippingNode.DEFAULT = 'default';

  const clipping = () => nodeObject( new ClippingNode() );

  const clippingAlpha = () => nodeObject( new ClippingNode( ClippingNode.ALPHA_TO_COVERAGE ) );

  class NodeMaterial extends Material {

  	static get type() {

  		return 'NodeMaterial';

  	}

  	constructor() {

  		super();

  		this.isNodeMaterial = true;

  		this.type = this.constructor.type;

  		this.forceSinglePass = false;

  		this.fog = true;
  		this.lights = false;

  		this.lightsNode = null;
  		this.envNode = null;
  		this.aoNode = null;

  		this.colorNode = null;
  		this.normalNode = null;
  		this.opacityNode = null;
  		this.backdropNode = null;
  		this.backdropAlphaNode = null;
  		this.alphaTestNode = null;

  		this.positionNode = null;

  		this.depthNode = null;
  		this.shadowNode = null;
  		this.shadowPositionNode = null;

  		this.outputNode = null;
  		this.mrtNode = null;

  		this.fragmentNode = null;
  		this.vertexNode = null;

  	}

  	customProgramCacheKey() {

  		return this.type + getCacheKey$1( this );

  	}

  	build( builder ) {

  		this.setup( builder );

  	}

  	setupObserver( builder ) {

  		return new NodeMaterialObserver( builder );

  	}

  	setup( builder ) {

  		builder.context.setupNormal = () => this.setupNormal( builder );

  		// < VERTEX STAGE >

  		builder.addStack();

  		builder.stack.outputNode = this.vertexNode || this.setupPosition( builder );

  		builder.addFlow( 'vertex', builder.removeStack() );

  		// < FRAGMENT STAGE >

  		builder.addStack();

  		let resultNode;

  		const clippingNode = this.setupClipping( builder );

  		if ( this.depthWrite === true ) this.setupDepth( builder );

  		if ( this.fragmentNode === null ) {

  			this.setupDiffuseColor( builder );
  			this.setupVariants( builder );

  			const outgoingLightNode = this.setupLighting( builder );

  			if ( clippingNode !== null ) builder.stack.add( clippingNode );

  			// force unsigned floats - useful for RenderTargets

  			const basicOutput = vec4( outgoingLightNode, diffuseColor.a ).max( 0 );

  			resultNode = this.setupOutput( builder, basicOutput );

  			// OUTPUT NODE

  			output.assign( resultNode );

  			//

  			if ( this.outputNode !== null ) resultNode = this.outputNode;

  			// MRT

  			const renderTarget = builder.renderer.getRenderTarget();

  			if ( renderTarget !== null ) {

  				const mrt = builder.renderer.getMRT();
  				const materialMRT = this.mrtNode;

  				if ( mrt !== null ) {

  					resultNode = mrt;

  					if ( materialMRT !== null ) {

  						resultNode = mrt.merge( materialMRT );

  					}

  				} else if ( materialMRT !== null ) {

  					resultNode = materialMRT;

  				}

  			}

  		} else {

  			let fragmentNode = this.fragmentNode;

  			if ( fragmentNode.isOutputStructNode !== true ) {

  				fragmentNode = vec4( fragmentNode );

  			}

  			resultNode = this.setupOutput( builder, fragmentNode );

  		}

  		builder.stack.outputNode = resultNode;

  		builder.addFlow( 'fragment', builder.removeStack() );

  		// < MONITOR >

  		builder.monitor = this.setupObserver( builder );

  	}

  	setupClipping( builder ) {

  		if ( builder.clippingContext === null ) return null;

  		const { globalClippingCount, localClippingCount } = builder.clippingContext;

  		let result = null;

  		if ( globalClippingCount || localClippingCount ) {

  			const samples = builder.renderer.samples;

  			if ( this.alphaToCoverage && samples > 1 ) {

  				// to be added to flow when the color/alpha value has been determined
  				result = clippingAlpha();

  			} else {

  				builder.stack.add( clipping() );

  			}

  		}

  		return result;

  	}

  	setupDepth( builder ) {

  		const { renderer } = builder;

  		// Depth

  		let depthNode = this.depthNode;

  		if ( depthNode === null ) {

  			const mrt = renderer.getMRT();

  			if ( mrt && mrt.has( 'depth' ) ) {

  				depthNode = mrt.get( 'depth' );

  			} else if ( renderer.logarithmicDepthBuffer === true ) {

  				const fragDepth = modelViewProjection().w.add( 1 );

  				depthNode = fragDepth.log2().mul( cameraLogDepth ).mul( 0.5 );

  			}

  		}

  		if ( depthNode !== null ) {

  			depth.assign( depthNode ).append();

  		}

  	}

  	setupPosition( builder ) {

  		const { object } = builder;
  		const geometry = object.geometry;

  		builder.addStack();

  		// Vertex

  		if ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {

  			morphReference( object ).append();

  		}

  		if ( object.isSkinnedMesh === true ) {

  			skinningReference( object ).append();

  		}

  		if ( this.displacementMap ) {

  			const displacementMap = materialReference( 'displacementMap', 'texture' );
  			const displacementScale = materialReference( 'displacementScale', 'float' );
  			const displacementBias = materialReference( 'displacementBias', 'float' );

  			positionLocal.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );

  		}

  		if ( object.isBatchedMesh ) {

  			batch( object ).append();

  		}

  		if ( ( object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) ) {

  			instance( object ).append();

  		}

  		if ( this.positionNode !== null ) {

  			positionLocal.assign( this.positionNode );

  		}

  		const mvp = modelViewProjection();

  		builder.context.vertex = builder.removeStack();
  		builder.context.mvp = mvp;

  		return mvp;

  	}

  	setupDiffuseColor( { object, geometry } ) {

  		let colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;

  		// VERTEX COLORS

  		if ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {

  			colorNode = vec4( colorNode.xyz.mul( attribute( 'color', 'vec3' ) ), colorNode.a );

  		}

  		// Instanced colors

  		if ( object.instanceColor ) {

  			const instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );

  			colorNode = instanceColor.mul( colorNode );

  		}

  		if ( object.isBatchedMesh && object._colorsTexture ) {

  			const batchColor = varyingProperty( 'vec3', 'vBatchColor' );

  			colorNode = batchColor.mul( colorNode );

  		}


  		// COLOR

  		diffuseColor.assign( colorNode );

  		// OPACITY

  		const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;
  		diffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );

  		// ALPHA TEST

  		if ( this.alphaTestNode !== null || this.alphaTest > 0 ) {

  			const alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;

  			diffuseColor.a.lessThanEqual( alphaTestNode ).discard();

  		}

  		if ( this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false ) {

  			diffuseColor.a.assign( 1.0 );

  		}

  	}

  	setupVariants( /*builder*/ ) {

  		// Interface function.

  	}

  	setupOutgoingLight() {

  		return ( this.lights === true ) ? vec3( 0 ) : diffuseColor.rgb;

  	}

  	setupNormal() {

  		return this.normalNode ? vec3( this.normalNode ) : materialNormal;

  	}

  	setupEnvironment( /*builder*/ ) {

  		let node = null;

  		if ( this.envNode ) {

  			node = this.envNode;

  		} else if ( this.envMap ) {

  			node = this.envMap.isCubeTexture ? materialReference( 'envMap', 'cubeTexture' ) : materialReference( 'envMap', 'texture' );

  		}

  		return node;

  	}

  	setupLightMap( builder ) {

  		let node = null;

  		if ( builder.material.lightMap ) {

  			node = new IrradianceNode( materialLightMap );

  		}

  		return node;

  	}

  	setupLights( builder ) {

  		const materialLightsNode = [];

  		//

  		const envNode = this.setupEnvironment( builder );

  		if ( envNode && envNode.isLightingNode ) {

  			materialLightsNode.push( envNode );

  		}

  		const lightMapNode = this.setupLightMap( builder );

  		if ( lightMapNode && lightMapNode.isLightingNode ) {

  			materialLightsNode.push( lightMapNode );

  		}

  		if ( this.aoNode !== null || builder.material.aoMap ) {

  			const aoNode = this.aoNode !== null ? this.aoNode : materialAOMap;

  			materialLightsNode.push( new AONode( aoNode ) );

  		}

  		let lightsN = this.lightsNode || builder.lightsNode;

  		if ( materialLightsNode.length > 0 ) {

  			lightsN = lights( [ ...lightsN.getLights(), ...materialLightsNode ] );

  		}

  		return lightsN;

  	}

  	setupLightingModel( /*builder*/ ) {

  		// Interface function.

  	}

  	setupLighting( builder ) {

  		const { material } = builder;
  		const { backdropNode, backdropAlphaNode, emissiveNode } = this;

  		// OUTGOING LIGHT

  		const lights = this.lights === true || this.lightsNode !== null;

  		const lightsNode = lights ? this.setupLights( builder ) : null;

  		let outgoingLightNode = this.setupOutgoingLight( builder );

  		if ( lightsNode && lightsNode.getScope().getLights().length > 0 ) {

  			const lightingModel = this.setupLightingModel( builder );

  			outgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );

  		} else if ( backdropNode !== null ) {

  			outgoingLightNode = vec3( backdropAlphaNode !== null ? mix$2( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );

  		}

  		// EMISSIVE

  		if ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {

  			emissive.assign( vec3( emissiveNode ? emissiveNode : materialEmissive ) );

  			outgoingLightNode = outgoingLightNode.add( emissive );

  		}

  		return outgoingLightNode;

  	}

  	setupOutput( builder, outputNode ) {

  		// FOG

  		if ( this.fog === true ) {

  			const fogNode = builder.fogNode;

  			if ( fogNode ) outputNode = vec4( fogNode.mix( outputNode.rgb, fogNode.colorNode ), outputNode.a );

  		}

  		return outputNode;

  	}

  	setDefaultValues( material ) {

  		// This approach is to reuse the native refreshUniforms*
  		// and turn available the use of features like transmission and environment in core

  		for ( const property in material ) {

  			const value = material[ property ];

  			if ( this[ property ] === undefined ) {

  				this[ property ] = value;

  				if ( value && value.clone ) this[ property ] = value.clone();

  			}

  		}

  		const descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );

  		for ( const key in descriptors ) {

  			if ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&
  			     descriptors[ key ].get !== undefined ) {

  				Object.defineProperty( this.constructor.prototype, key, descriptors[ key ] );

  			}

  		}

  	}

  	toJSON( meta ) {

  		const isRoot = ( meta === undefined || typeof meta === 'string' );

  		if ( isRoot ) {

  			meta = {
  				textures: {},
  				images: {},
  				nodes: {}
  			};

  		}

  		const data = Material.prototype.toJSON.call( this, meta );
  		const nodeChildren = getNodeChildren( this );

  		data.inputNodes = {};

  		for ( const { property, childNode } of nodeChildren ) {

  			data.inputNodes[ property ] = childNode.toJSON( meta ).uuid;

  		}

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			const values = [];

  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRoot ) {

  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );
  			const nodes = extractFromCache( meta.nodes );

  			if ( textures.length > 0 ) data.textures = textures;
  			if ( images.length > 0 ) data.images = images;
  			if ( nodes.length > 0 ) data.nodes = nodes;

  		}

  		return data;

  	}

  	copy( source ) {

  		this.lightsNode = source.lightsNode;
  		this.envNode = source.envNode;

  		this.colorNode = source.colorNode;
  		this.normalNode = source.normalNode;
  		this.opacityNode = source.opacityNode;
  		this.backdropNode = source.backdropNode;
  		this.backdropAlphaNode = source.backdropAlphaNode;
  		this.alphaTestNode = source.alphaTestNode;

  		this.positionNode = source.positionNode;

  		this.depthNode = source.depthNode;
  		this.shadowNode = source.shadowNode;
  		this.shadowPositionNode = source.shadowPositionNode;

  		this.outputNode = source.outputNode;
  		this.mrtNode = source.mrtNode;

  		this.fragmentNode = source.fragmentNode;
  		this.vertexNode = source.vertexNode;

  		return super.copy( source );

  	}

  }

  const _defaultValues$d = /*@__PURE__*/ new LineBasicMaterial();

  class LineBasicNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'LineBasicNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.isLineBasicNodeMaterial = true;

  		this.lights = false;

  		this.setDefaultValues( _defaultValues$d );

  		this.setValues( parameters );

  	}

  }

  const _defaultValues$c = /*@__PURE__*/ new LineDashedMaterial();

  class LineDashedNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'LineDashedNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.isLineDashedNodeMaterial = true;

  		this.lights = false;

  		this.setDefaultValues( _defaultValues$c );

  		this.offsetNode = null;
  		this.dashScaleNode = null;
  		this.dashSizeNode = null;
  		this.gapSizeNode = null;

  		this.setValues( parameters );

  	}

  	setupVariants() {

  		const offsetNode = this.offsetNode;
  		const dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;
  		const dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;
  		const gapSizeNode = this.dashSizeNode ? float( this.dashGapNode ) : materialLineGapSize;

  		dashSize.assign( dashSizeNode );
  		gapSize.assign( gapSizeNode );

  		const vLineDistance = varying( attribute( 'lineDistance' ).mul( dashScaleNode ) );
  		const vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;

  		vLineDistanceOffset.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard();

  	}

  }

  const directionToColor = ( node ) => nodeObject( node ).mul( 0.5 ).add( 0.5 );

  const _defaultValues$a = /*@__PURE__*/ new MeshNormalMaterial();

  class MeshNormalNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshNormalNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.lights = false;

  		this.isMeshNormalNodeMaterial = true;

  		this.setDefaultValues( _defaultValues$a );

  		this.setValues( parameters );

  	}

  	setupDiffuseColor() {

  		const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;

  		diffuseColor.assign( vec4( directionToColor( transformedNormalView ), opacityNode ) );

  	}

  }

  class EquirectUVNode extends TempNode {

  	static get type() {

  		return 'EquirectUVNode';

  	}

  	constructor( dirNode = positionWorldDirection ) {

  		super( 'vec2' );

  		this.dirNode = dirNode;

  	}

  	setup() {

  		const dir = this.dirNode;

  		const u = dir.z.atan2( dir.x ).mul( 1 / ( Math.PI * 2 ) ).add( 0.5 );
  		const v = dir.y.clamp( - 1.0, 1.0 ).asin().mul( 1 / Math.PI ).add( 0.5 );

  		return vec2( u, v );

  	}

  }

  const equirectUV = /*@__PURE__*/ nodeProxy( EquirectUVNode );

  // @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget

  class CubeRenderTarget extends WebGLCubeRenderTarget {

  	constructor( size = 1, options = {} ) {

  		super( size, options );

  		this.isCubeRenderTarget = true;

  	}

  	fromEquirectangularTexture( renderer, texture$1 ) {

  		const currentMinFilter = texture$1.minFilter;
  		const currentGenerateMipmaps = texture$1.generateMipmaps;

  		texture$1.generateMipmaps = true;

  		this.texture.type = texture$1.type;
  		this.texture.colorSpace = texture$1.colorSpace;

  		this.texture.generateMipmaps = texture$1.generateMipmaps;
  		this.texture.minFilter = texture$1.minFilter;
  		this.texture.magFilter = texture$1.magFilter;

  		const geometry = new BoxGeometry( 5, 5, 5 );

  		const uvNode = equirectUV( positionWorldDirection );

  		const material = new NodeMaterial();
  		material.colorNode = texture( texture$1, uvNode, 0 );
  		material.side = BackSide;
  		material.blending = NoBlending;

  		const mesh = new Mesh( geometry, material );

  		const scene = new Scene();
  		scene.add( mesh );

  		// Avoid blurred poles
  		if ( texture$1.minFilter === LinearMipmapLinearFilter ) texture$1.minFilter = LinearFilter;

  		const camera = new CubeCamera( 1, 10, this );

  		const currentMRT = renderer.getMRT();
  		renderer.setMRT( null );

  		camera.update( renderer, scene );

  		renderer.setMRT( currentMRT );

  		texture$1.minFilter = currentMinFilter;
  		texture$1.currentGenerateMipmaps = currentGenerateMipmaps;

  		mesh.geometry.dispose();
  		mesh.material.dispose();

  		return this;

  	}

  }

  const _cache$1 = new WeakMap();

  class CubeMapNode extends TempNode {

  	static get type() {

  		return 'CubeMapNode';

  	}

  	constructor( envNode ) {

  		super( 'vec3' );

  		this.envNode = envNode;

  		this._cubeTexture = null;
  		this._cubeTextureNode = cubeTexture();

  		const defaultTexture = new CubeTexture();
  		defaultTexture.isRenderTargetTexture = true;

  		this._defaultTexture = defaultTexture;

  		this.updateBeforeType = NodeUpdateType.RENDER;

  	}

  	updateBefore( frame ) {

  		const { renderer, material } = frame;

  		const envNode = this.envNode;

  		if ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {

  			const texture = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];

  			if ( texture && texture.isTexture ) {

  				const mapping = texture.mapping;

  				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

  					// check for converted cubemap map

  					if ( _cache$1.has( texture ) ) {

  						const cubeMap = _cache$1.get( texture );

  						mapTextureMapping( cubeMap, texture.mapping );
  						this._cubeTexture = cubeMap;

  					} else {

  						// create cube map from equirectangular map

  						const image = texture.image;

  						if ( isEquirectangularMapReady$1( image ) ) {

  							const renderTarget = new CubeRenderTarget( image.height );
  							renderTarget.fromEquirectangularTexture( renderer, texture );

  							mapTextureMapping( renderTarget.texture, texture.mapping );
  							this._cubeTexture = renderTarget.texture;

  							_cache$1.set( texture, renderTarget.texture );

  							texture.addEventListener( 'dispose', onTextureDispose );

  						} else {

  							// default cube texture as fallback when equirectangular texture is not yet loaded

  							this._cubeTexture = this._defaultTexture;

  						}

  					}

  					//

  					this._cubeTextureNode.value = this._cubeTexture;

  				} else {

  					// envNode already refers to a cube map

  					this._cubeTextureNode = this.envNode;

  				}

  			}

  		}

  	}

  	setup( builder ) {

  		this.updateBefore( builder );

  		return this._cubeTextureNode;

  	}

  }

  function isEquirectangularMapReady$1( image ) {

  	if ( image === null || image === undefined ) return false;

  	return image.height > 0;

  }

  function onTextureDispose( event ) {

  	const texture = event.target;

  	texture.removeEventListener( 'dispose', onTextureDispose );

  	const renderTarget = _cache$1.get( texture );

  	if ( renderTarget !== undefined ) {

  		_cache$1.delete( texture );

  		renderTarget.dispose();

  	}

  }

  function mapTextureMapping( texture, mapping ) {

  	if ( mapping === EquirectangularReflectionMapping ) {

  		texture.mapping = CubeReflectionMapping;

  	} else if ( mapping === EquirectangularRefractionMapping ) {

  		texture.mapping = CubeRefractionMapping;

  	}

  }

  const cubeMapNode = /*@__PURE__*/ nodeProxy( CubeMapNode );

  class BasicEnvironmentNode extends LightingNode {

  	static get type() {

  		return 'BasicEnvironmentNode';

  	}

  	constructor( envNode = null ) {

  		super();

  		this.envNode = envNode;

  	}

  	setup( builder ) {

  		// environment property is used in the finish() method of BasicLightingModel

  		builder.context.environment = cubeMapNode( this.envNode );

  	}

  }

  class BasicLightMapNode extends LightingNode {

  	static get type() {

  		return 'BasicLightMapNode';

  	}

  	constructor( lightMapNode = null ) {

  		super();

  		this.lightMapNode = lightMapNode;

  	}

  	setup( builder ) {

  		// irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel

  		const RECIPROCAL_PI = float( 1 / Math.PI );

  		builder.context.irradianceLightMap = this.lightMapNode.mul( RECIPROCAL_PI );

  	}

  }

  class LightingModel {

  	start( /*input, stack, builder*/ ) { }

  	finish( /*input, stack, builder*/ ) { }

  	direct( /*input, stack, builder*/ ) { }

  	directRectArea( /*input, stack, builder*/ ) {}

  	indirect( /*input, stack, builder*/ ) { }

  	ambientOcclusion( /*input, stack, builder*/ ) { }

  }

  class BasicLightingModel extends LightingModel {

  	constructor() {

  		super();

  	}

  	indirect( context, stack, builder ) {

  		const ambientOcclusion = context.ambientOcclusion;
  		const reflectedLight = context.reflectedLight;
  		const irradianceLightMap = builder.context.irradianceLightMap;

  		reflectedLight.indirectDiffuse.assign( vec4( 0.0 ) );

  		// accumulation (baked indirect lighting only)

  		if ( irradianceLightMap ) {

  			reflectedLight.indirectDiffuse.addAssign( irradianceLightMap );

  		} else {

  			reflectedLight.indirectDiffuse.addAssign( vec4( 1.0, 1.0, 1.0, 0.0 ) );

  		}

  		// modulation

  		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

  		reflectedLight.indirectDiffuse.mulAssign( diffuseColor.rgb );

  	}

  	finish( context, stack, builder ) {

  		const material = builder.material;
  		const outgoingLight = context.outgoingLight;
  		const envNode = builder.context.environment;

  		if ( envNode ) {

  			switch ( material.combine ) {

  				case MultiplyOperation:
  					outgoingLight.rgb.assign( mix$2( outgoingLight.rgb, outgoingLight.rgb.mul( envNode.rgb ), materialSpecularStrength.mul( materialReflectivity ) ) );
  					break;

  				case MixOperation:
  					outgoingLight.rgb.assign( mix$2( outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul( materialReflectivity ) ) );
  					break;

  				case AddOperation:
  					outgoingLight.rgb.addAssign( envNode.rgb.mul( materialSpecularStrength.mul( materialReflectivity ) ) );
  					break;

  				default:
  					console.warn( 'THREE.BasicLightingModel: Unsupported .combine value:', material.combine );
  					break;

  			}

  		}

  	}

  }

  const _defaultValues$9 = /*@__PURE__*/ new MeshBasicMaterial();

  class MeshBasicNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshBasicNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.isMeshBasicNodeMaterial = true;

  		this.lights = true;

  		this.setDefaultValues( _defaultValues$9 );

  		this.setValues( parameters );

  	}

  	setupNormal() {

  		return normalView; // see #28839

  	}

  	setupEnvironment( builder ) {

  		const envNode = super.setupEnvironment( builder );

  		return envNode ? new BasicEnvironmentNode( envNode ) : null;

  	}

  	setupLightMap( builder ) {

  		let node = null;

  		if ( builder.material.lightMap ) {

  			node = new BasicLightMapNode( materialLightMap );

  		}

  		return node;

  	}

  	setupOutgoingLight() {

  		return diffuseColor.rgb;

  	}

  	setupLightingModel() {

  		return new BasicLightingModel();

  	}

  }

  const F_Schlick = /*@__PURE__*/ Fn( ( { f0, f90, dotVH } ) => {

  	// Original approximation by Christophe Schlick '94
  	// float fresnel = pow( 1.0 - dotVH, 5.0 );

  	// Optimized variant (presented by Epic at SIGGRAPH '13)
  	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
  	const fresnel = dotVH.mul( - 5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();

  	return f0.mul( fresnel.oneMinus() ).add( f90.mul( fresnel ) );

  } ); // validated

  const BRDF_Lambert = /*@__PURE__*/ Fn( ( inputs ) => {

  	return inputs.diffuseColor.mul( 1 / Math.PI ); // punctual light

  } ); // validated

  const G_BlinnPhong_Implicit = () => float( 0.25 );

  const D_BlinnPhong = /*@__PURE__*/ Fn( ( { dotNH } ) => {

  	return shininess.mul( float( 0.5 ) ).add( 1.0 ).mul( float( 1 / Math.PI ) ).mul( dotNH.pow( shininess ) );

  } );

  const BRDF_BlinnPhong = /*@__PURE__*/ Fn( ( { lightDirection } ) => {

  	const halfDir = lightDirection.add( positionViewDirection ).normalize();

  	const dotNH = transformedNormalView.dot( halfDir ).clamp();
  	const dotVH = positionViewDirection.dot( halfDir ).clamp();

  	const F = F_Schlick( { f0: specularColor, f90: 1.0, dotVH } );
  	const G = G_BlinnPhong_Implicit();
  	const D = D_BlinnPhong( { dotNH } );

  	return F.mul( G ).mul( D );

  } );

  class PhongLightingModel extends BasicLightingModel {

  	constructor( specular = true ) {

  		super();

  		this.specular = specular;

  	}

  	direct( { lightDirection, lightColor, reflectedLight } ) {

  		const dotNL = transformedNormalView.dot( lightDirection ).clamp();
  		const irradiance = dotNL.mul( lightColor );

  		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

  		if ( this.specular === true ) {

  			reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_BlinnPhong( { lightDirection } ) ).mul( materialSpecularStrength ) );

  		}

  	}

  	indirect( { ambientOcclusion, irradiance, reflectedLight } ) {

  		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

  		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

  	}

  }

  const _defaultValues$8 = /*@__PURE__*/ new MeshLambertMaterial();

  class MeshLambertNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshLambertNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.isMeshLambertNodeMaterial = true;

  		this.lights = true;

  		this.setDefaultValues( _defaultValues$8 );

  		this.setValues( parameters );

  	}

  	setupEnvironment( builder ) {

  		const envNode = super.setupEnvironment( builder );

  		return envNode ? new BasicEnvironmentNode( envNode ) : null;

  	}

  	setupLightingModel( /*builder*/ ) {

  		return new PhongLightingModel( false ); // ( specular ) -> force lambert

  	}

  }

  const _defaultValues$7 = /*@__PURE__*/ new MeshPhongMaterial();

  class MeshPhongNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshPhongNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.isMeshPhongNodeMaterial = true;

  		this.lights = true;

  		this.shininessNode = null;
  		this.specularNode = null;

  		this.setDefaultValues( _defaultValues$7 );

  		this.setValues( parameters );

  	}

  	setupEnvironment( builder ) {

  		const envNode = super.setupEnvironment( builder );

  		return envNode ? new BasicEnvironmentNode( envNode ) : null;

  	}

  	setupLightingModel( /*builder*/ ) {

  		return new PhongLightingModel();

  	}

  	setupVariants() {

  		// SHININESS

  		const shininessNode = ( this.shininessNode ? float( this.shininessNode ) : materialShininess ).max( 1e-4 ); // to prevent pow( 0.0, 0.0 )

  		shininess.assign( shininessNode );

  		// SPECULAR COLOR

  		const specularNode = this.specularNode || materialSpecular;

  		specularColor.assign( specularNode );

  	}

  	copy( source ) {

  		this.shininessNode = source.shininessNode;
  		this.specularNode = source.specularNode;

  		return super.copy( source );

  	}

  }

  const getGeometryRoughness = /*@__PURE__*/ Fn( () => {

  	const dxy = normalView.dFdx().abs().max( normalView.dFdy().abs() );
  	const geometryRoughness = dxy.x.max( dxy.y ).max( dxy.z );

  	return geometryRoughness;

  } );

  const getRoughness = /*@__PURE__*/ Fn( ( inputs ) => {

  	const { roughness } = inputs;

  	const geometryRoughness = getGeometryRoughness();

  	let roughnessFactor = roughness.max( 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.
  	roughnessFactor = roughnessFactor.add( geometryRoughness );
  	roughnessFactor = roughnessFactor.min( 1.0 );

  	return roughnessFactor;

  } );

  // Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
  // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  const V_GGX_SmithCorrelated = /*@__PURE__*/ Fn( ( { alpha, dotNL, dotNV } ) => {

  	const a2 = alpha.pow2();

  	const gv = dotNL.mul( a2.add( a2.oneMinus().mul( dotNV.pow2() ) ).sqrt() );
  	const gl = dotNV.mul( a2.add( a2.oneMinus().mul( dotNL.pow2() ) ).sqrt() );

  	return div( 0.5, gv.add( gl ).max( EPSILON ) );

  } ).setLayout( {
  	name: 'V_GGX_SmithCorrelated',
  	type: 'float',
  	inputs: [
  		{ name: 'alpha', type: 'float' },
  		{ name: 'dotNL', type: 'float' },
  		{ name: 'dotNV', type: 'float' }
  	]
  } ); // validated

  // https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

  const V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } ) => {

  	const gv = dotNL.mul( vec3( alphaT.mul( dotTV ), alphaB.mul( dotBV ), dotNV ).length() );
  	const gl = dotNV.mul( vec3( alphaT.mul( dotTL ), alphaB.mul( dotBL ), dotNL ).length() );
  	const v = div( 0.5, gv.add( gl ) );

  	return v.saturate();

  } ).setLayout( {
  	name: 'V_GGX_SmithCorrelated_Anisotropic',
  	type: 'float',
  	inputs: [
  		{ name: 'alphaT', type: 'float', qualifier: 'in' },
  		{ name: 'alphaB', type: 'float', qualifier: 'in' },
  		{ name: 'dotTV', type: 'float', qualifier: 'in' },
  		{ name: 'dotBV', type: 'float', qualifier: 'in' },
  		{ name: 'dotTL', type: 'float', qualifier: 'in' },
  		{ name: 'dotBL', type: 'float', qualifier: 'in' },
  		{ name: 'dotNV', type: 'float', qualifier: 'in' },
  		{ name: 'dotNL', type: 'float', qualifier: 'in' }
  	]
  } );

  // Microfacet Models for Refraction through Rough Surfaces - equation (33)
  // http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
  // alpha is "roughness squared" in Disney’s reparameterization
  const D_GGX = /*@__PURE__*/ Fn( ( { alpha, dotNH } ) => {

  	const a2 = alpha.pow2();

  	const denom = dotNH.pow2().mul( a2.oneMinus() ).oneMinus(); // avoid alpha = 0 with dotNH = 1

  	return a2.div( denom.pow2() ).mul( 1 / Math.PI );

  } ).setLayout( {
  	name: 'D_GGX',
  	type: 'float',
  	inputs: [
  		{ name: 'alpha', type: 'float' },
  		{ name: 'dotNH', type: 'float' }
  	]
  } ); // validated

  const RECIPROCAL_PI = /*@__PURE__*/ float( 1 / Math.PI );

  // https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

  const D_GGX_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotNH, dotTH, dotBH } ) => {

  	const a2 = alphaT.mul( alphaB );
  	const v = vec3( alphaB.mul( dotTH ), alphaT.mul( dotBH ), a2.mul( dotNH ) );
  	const v2 = v.dot( v );
  	const w2 = a2.div( v2 );

  	return RECIPROCAL_PI.mul( a2.mul( w2.pow2() ) );

  } ).setLayout( {
  	name: 'D_GGX_Anisotropic',
  	type: 'float',
  	inputs: [
  		{ name: 'alphaT', type: 'float', qualifier: 'in' },
  		{ name: 'alphaB', type: 'float', qualifier: 'in' },
  		{ name: 'dotNH', type: 'float', qualifier: 'in' },
  		{ name: 'dotTH', type: 'float', qualifier: 'in' },
  		{ name: 'dotBH', type: 'float', qualifier: 'in' }
  	]
  } );

  // GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
  const BRDF_GGX = /*@__PURE__*/ Fn( ( inputs ) => {

  	const { lightDirection, f0, f90, roughness, f, USE_IRIDESCENCE, USE_ANISOTROPY } = inputs;

  	const normalView = inputs.normalView || transformedNormalView;

  	const alpha = roughness.pow2(); // UE4's roughness

  	const halfDir = lightDirection.add( positionViewDirection ).normalize();

  	const dotNL = normalView.dot( lightDirection ).clamp();
  	const dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV
  	const dotNH = normalView.dot( halfDir ).clamp();
  	const dotVH = positionViewDirection.dot( halfDir ).clamp();

  	let F = F_Schlick( { f0, f90, dotVH } );
  	let V, D;

  	if ( defined( USE_IRIDESCENCE ) ) {

  		F = iridescence.mix( F, f );

  	}

  	if ( defined( USE_ANISOTROPY ) ) {

  		const dotTL = anisotropyT.dot( lightDirection );
  		const dotTV = anisotropyT.dot( positionViewDirection );
  		const dotTH = anisotropyT.dot( halfDir );
  		const dotBL = anisotropyB.dot( lightDirection );
  		const dotBV = anisotropyB.dot( positionViewDirection );
  		const dotBH = anisotropyB.dot( halfDir );

  		V = V_GGX_SmithCorrelated_Anisotropic( { alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } );
  		D = D_GGX_Anisotropic( { alphaT, alphaB: alpha, dotNH, dotTH, dotBH } );

  	} else {

  		V = V_GGX_SmithCorrelated( { alpha, dotNL, dotNV } );
  		D = D_GGX( { alpha, dotNH } );

  	}

  	return F.mul( V ).mul( D );

  } ); // validated

  // Analytical approximation of the DFG LUT, one half of the
  // split-sum approximation used in indirect specular lighting.
  // via 'environmentBRDF' from "Physically Based Shading on Mobile"
  // https://www.unrealengine.com/blog/physically-based-shading-on-mobile
  const DFGApprox = /*@__PURE__*/ Fn( ( { roughness, dotNV } ) => {

  	const c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

  	const c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

  	const r = roughness.mul( c0 ).add( c1 );

  	const a004 = r.x.mul( r.x ).min( dotNV.mul( - 9.28 ).exp2() ).mul( r.x ).add( r.y );

  	const fab = vec2( - 1.04, 1.04 ).mul( a004 ).add( r.zw );

  	return fab;

  } ).setLayout( {
  	name: 'DFGApprox',
  	type: 'vec2',
  	inputs: [
  		{ name: 'roughness', type: 'float' },
  		{ name: 'dotNV', type: 'vec3' }
  	]
  } );

  const EnvironmentBRDF = /*@__PURE__*/ Fn( ( inputs ) => {

  	const { dotNV, specularColor, specularF90, roughness } = inputs;

  	const fab = DFGApprox( { dotNV, roughness } );
  	return specularColor.mul( fab.x ).add( specularF90.mul( fab.y ) );

  } );

  const Schlick_to_F0 = /*@__PURE__*/ Fn( ( { f, f90, dotVH } ) => {

  	const x = dotVH.oneMinus().saturate();
  	const x2 = x.mul( x );
  	const x5 = x.mul( x2, x2 ).clamp( 0, .9999 );

  	return f.sub( vec3( f90 ).mul( x5 ) ).div( x5.oneMinus() );

  } ).setLayout( {
  	name: 'Schlick_to_F0',
  	type: 'vec3',
  	inputs: [
  		{ name: 'f', type: 'vec3' },
  		{ name: 'f90', type: 'float' },
  		{ name: 'dotVH', type: 'float' }
  	]
  } );

  // https://github.com/google/filament/blob/master/shaders/src/brdf.fs
  const D_Charlie = /*@__PURE__*/ Fn( ( { roughness, dotNH } ) => {

  	const alpha = roughness.pow2();

  	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  	const invAlpha = float( 1.0 ).div( alpha );
  	const cos2h = dotNH.pow2();
  	const sin2h = cos2h.oneMinus().max( 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

  	return float( 2.0 ).add( invAlpha ).mul( sin2h.pow( invAlpha.mul( 0.5 ) ) ).div( 2.0 * Math.PI );

  } ).setLayout( {
  	name: 'D_Charlie',
  	type: 'float',
  	inputs: [
  		{ name: 'roughness', type: 'float' },
  		{ name: 'dotNH', type: 'float' }
  	]
  } );

  // https://github.com/google/filament/blob/master/shaders/src/brdf.fs
  const V_Neubelt = /*@__PURE__*/ Fn( ( { dotNV, dotNL } ) => {

  	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
  	return float( 1.0 ).div( float( 4.0 ).mul( dotNL.add( dotNV ).sub( dotNL.mul( dotNV ) ) ) );

  } ).setLayout( {
  	name: 'V_Neubelt',
  	type: 'float',
  	inputs: [
  		{ name: 'dotNV', type: 'float' },
  		{ name: 'dotNL', type: 'float' }
  	]
  } );

  const BRDF_Sheen = /*@__PURE__*/ Fn( ( { lightDirection } ) => {

  	const halfDir = lightDirection.add( positionViewDirection ).normalize();

  	const dotNL = transformedNormalView.dot( lightDirection ).clamp();
  	const dotNV = transformedNormalView.dot( positionViewDirection ).clamp();
  	const dotNH = transformedNormalView.dot( halfDir ).clamp();

  	const D = D_Charlie( { roughness: sheenRoughness, dotNH } );
  	const V = V_Neubelt( { dotNV, dotNL } );

  	return sheen.mul( D ).mul( V );

  } );

  // Rect Area Light

  // Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
  // by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
  // code: https://github.com/selfshadow/ltc_code/

  const LTC_Uv = /*@__PURE__*/ Fn( ( { N, V, roughness } ) => {

  	const LUT_SIZE = 64.0;
  	const LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
  	const LUT_BIAS = 0.5 / LUT_SIZE;

  	const dotNV = N.dot( V ).saturate();

  	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
  	const uv = vec2( roughness, dotNV.oneMinus().sqrt() );

  	uv.assign( uv.mul( LUT_SCALE ).add( LUT_BIAS ) );

  	return uv;

  } ).setLayout( {
  	name: 'LTC_Uv',
  	type: 'vec2',
  	inputs: [
  		{ name: 'N', type: 'vec3' },
  		{ name: 'V', type: 'vec3' },
  		{ name: 'roughness', type: 'float' }
  	]
  } );

  const LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn( ( { f } ) => {

  	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
  	// An approximation of the form factor of a horizon-clipped rectangle.

  	const l = f.length();

  	return max$1( l.mul( l ).add( f.z ).div( l.add( 1.0 ) ), 0 );

  } ).setLayout( {
  	name: 'LTC_ClippedSphereFormFactor',
  	type: 'float',
  	inputs: [
  		{ name: 'f', type: 'vec3' }
  	]
  } );

  const LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn( ( { v1, v2 } ) => {

  	const x = v1.dot( v2 );
  	const y = x.abs().toVar();

  	// rational polynomial approximation to theta / sin( theta ) / 2PI
  	const a = y.mul( 0.0145206 ).add( 0.4965155 ).mul( y ).add( 0.8543985 ).toVar();
  	const b = y.add( 4.1616724 ).mul( y ).add( 3.4175940 ).toVar();
  	const v = a.div( b );

  	const theta_sintheta = x.greaterThan( 0.0 ).select( v, max$1( x.mul( x ).oneMinus(), 1e-7 ).inverseSqrt().mul( 0.5 ).sub( v ) );

  	return v1.cross( v2 ).mul( theta_sintheta );

  } ).setLayout( {
  	name: 'LTC_EdgeVectorFormFactor',
  	type: 'vec3',
  	inputs: [
  		{ name: 'v1', type: 'vec3' },
  		{ name: 'v2', type: 'vec3' }
  	]
  } );

  const LTC_Evaluate = /*@__PURE__*/ Fn( ( { N, V, P, mInv, p0, p1, p2, p3 } ) => {

  	// bail if point is on back side of plane of light
  	// assumes ccw winding order of light vertices
  	const v1 = p1.sub( p0 ).toVar();
  	const v2 = p3.sub( p0 ).toVar();

  	const lightNormal = v1.cross( v2 );
  	const result = vec3().toVar();

  	If( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {

  		// construct orthonormal basis around N
  		const T1 = V.sub( N.mul( V.dot( N ) ) ).normalize();
  		const T2 = N.cross( T1 ).negate(); // negated from paper; possibly due to a different handedness of world coordinate system

  		// compute transform
  		const mat = mInv.mul( mat3( T1, T2, N ).transpose() ).toVar();

  		// transform rect
  		// & project rect onto sphere
  		const coords0 = mat.mul( p0.sub( P ) ).normalize().toVar();
  		const coords1 = mat.mul( p1.sub( P ) ).normalize().toVar();
  		const coords2 = mat.mul( p2.sub( P ) ).normalize().toVar();
  		const coords3 = mat.mul( p3.sub( P ) ).normalize().toVar();

  		// calculate vector form factor
  		const vectorFormFactor = vec3( 0 ).toVar();
  		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );
  		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );
  		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );
  		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );

  		// adjust for horizon clipping
  		result.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor } ) ) );

  	} );

  	return result;

  } ).setLayout( {
  	name: 'LTC_Evaluate',
  	type: 'vec3',
  	inputs: [
  		{ name: 'N', type: 'vec3' },
  		{ name: 'V', type: 'vec3' },
  		{ name: 'P', type: 'vec3' },
  		{ name: 'mInv', type: 'mat3' },
  		{ name: 'p0', type: 'vec3' },
  		{ name: 'p1', type: 'vec3' },
  		{ name: 'p2', type: 'vec3' },
  		{ name: 'p3', type: 'vec3' }
  	]
  } );

  // Mipped Bicubic Texture Filtering by N8
  // https://www.shadertoy.com/view/Dl2SDW

  const bC = 1.0 / 6.0;

  const w0 = ( a ) => mul( bC, mul( a, mul( a, a.negate().add( 3.0 ) ).sub( 3.0 ) ).add( 1.0 ) );

  const w1 = ( a ) => mul( bC, mul( a, mul( a, mul( 3.0, a ).sub( 6.0 ) ) ).add( 4.0 ) );

  const w2 = ( a ) => mul( bC, mul( a, mul( a, mul( - 3.0, a ).add( 3.0 ) ).add( 3.0 ) ).add( 1.0 ) );

  const w3 = ( a ) => mul( bC, pow( a, 3 ) );

  const g0 = ( a ) => w0( a ).add( w1( a ) );

  const g1 = ( a ) => w2( a ).add( w3( a ) );

  // h0 and h1 are the two offset functions
  const h0 = ( a ) => add( - 1.0, w1( a ).div( w0( a ).add( w1( a ) ) ) );

  const h1 = ( a ) => add( 1.0, w3( a ).div( w2( a ).add( w3( a ) ) ) );

  const bicubic = ( textureNode, texelSize, lod ) => {

  	const uv = textureNode.uvNode;
  	const uvScaled = mul( uv, texelSize.zw ).add( 0.5 );

  	const iuv = floor( uvScaled );
  	const fuv = fract( uvScaled );

  	const g0x = g0( fuv.x );
  	const g1x = g1( fuv.x );
  	const h0x = h0( fuv.x );
  	const h1x = h1( fuv.x );
  	const h0y = h0( fuv.y );
  	const h1y = h1( fuv.y );

  	const p0 = vec2( iuv.x.add( h0x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
  	const p1 = vec2( iuv.x.add( h1x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
  	const p2 = vec2( iuv.x.add( h0x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );
  	const p3 = vec2( iuv.x.add( h1x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );

  	const a = g0( fuv.y ).mul( add( g0x.mul( textureNode.uv( p0 ).level( lod ) ), g1x.mul( textureNode.uv( p1 ).level( lod ) ) ) );
  	const b = g1( fuv.y ).mul( add( g0x.mul( textureNode.uv( p2 ).level( lod ) ), g1x.mul( textureNode.uv( p3 ).level( lod ) ) ) );

  	return a.add( b );

  };

  const textureBicubic = /*@__PURE__*/ Fn( ( [ textureNode, lodNode = float( 3 ) ] ) => {

  	const fLodSize = vec2( textureNode.size( int( lodNode ) ) );
  	const cLodSize = vec2( textureNode.size( int( lodNode.add( 1.0 ) ) ) );
  	const fLodSizeInv = div( 1.0, fLodSize );
  	const cLodSizeInv = div( 1.0, cLodSize );
  	const fSample = bicubic( textureNode, vec4( fLodSizeInv, fLodSize ), floor( lodNode ) );
  	const cSample = bicubic( textureNode, vec4( cLodSizeInv, cLodSize ), ceil( lodNode ) );

  	return fract( lodNode ).mix( fSample, cSample );

  } );

  //
  // Transmission
  //

  const getVolumeTransmissionRay = /*@__PURE__*/ Fn( ( [ n, v, thickness, ior, modelMatrix ] ) => {

  	// Direction of refracted light.
  	const refractionVector = vec3( refract( v.negate(), normalize( n ), div( 1.0, ior ) ) );

  	// Compute rotation-independant scaling of the model matrix.
  	const modelScale = vec3(
  		length( modelMatrix[ 0 ].xyz ),
  		length( modelMatrix[ 1 ].xyz ),
  		length( modelMatrix[ 2 ].xyz )
  	);

  	// The thickness is specified in local space.
  	return normalize( refractionVector ).mul( thickness.mul( modelScale ) );

  } ).setLayout( {
  	name: 'getVolumeTransmissionRay',
  	type: 'vec3',
  	inputs: [
  		{ name: 'n', type: 'vec3' },
  		{ name: 'v', type: 'vec3' },
  		{ name: 'thickness', type: 'float' },
  		{ name: 'ior', type: 'float' },
  		{ name: 'modelMatrix', type: 'mat4' }
  	]
  } );

  const applyIorToRoughness = /*@__PURE__*/ Fn( ( [ roughness, ior ] ) => {

  	// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
  	// an IOR of 1.5 results in the default amount of microfacet refraction.
  	return roughness.mul( clamp( ior.mul( 2.0 ).sub( 2.0 ), 0.0, 1.0 ) );

  } ).setLayout( {
  	name: 'applyIorToRoughness',
  	type: 'float',
  	inputs: [
  		{ name: 'roughness', type: 'float' },
  		{ name: 'ior', type: 'float' }
  	]
  } );

  const singleViewportMipTexture = /*@__PURE__*/ viewportMipTexture();

  const getTransmissionSample = /*@__PURE__*/ Fn( ( [ fragCoord, roughness, ior ] ) => {

  	const transmissionSample = singleViewportMipTexture.uv( fragCoord );
  	//const transmissionSample = viewportMipTexture( fragCoord );

  	const lod = log2( float( screenSize.x ) ).mul( applyIorToRoughness( roughness, ior ) );

  	return textureBicubic( transmissionSample, lod );

  } );

  const volumeAttenuation = /*@__PURE__*/ Fn( ( [ transmissionDistance, attenuationColor, attenuationDistance ] ) => {

  	If( attenuationDistance.notEqual( 0 ), () => {

  		// Compute light attenuation using Beer's law.
  		const attenuationCoefficient = log( attenuationColor ).negate().div( attenuationDistance );
  		const transmittance = exp( attenuationCoefficient.negate().mul( transmissionDistance ) );

  		return transmittance;

  	} );

  	// Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.
  	return vec3( 1.0 );

  } ).setLayout( {
  	name: 'volumeAttenuation',
  	type: 'vec3',
  	inputs: [
  		{ name: 'transmissionDistance', type: 'float' },
  		{ name: 'attenuationColor', type: 'vec3' },
  		{ name: 'attenuationDistance', type: 'float' }
  	]
  } );

  const getIBLVolumeRefraction = /*@__PURE__*/ Fn( ( [ n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion ] ) => {

  	let transmittedLight, transmittance;

  	if ( dispersion ) {

  		transmittedLight = vec4().toVar();
  		transmittance = vec3().toVar();

  		const halfSpread = ior.sub( 1.0 ).mul( dispersion.mul( 0.025 ) );
  		const iors = vec3( ior.sub( halfSpread ), ior, ior.add( halfSpread ) );

  		Loop( { start: 0, end: 3 }, ( { i } ) => {

  			const ior = iors.element( i );

  			const transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
  			const refractedRayExit = position.add( transmissionRay );

  			// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
  			const ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );
  			const refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();
  			refractionCoords.addAssign( 1.0 );
  			refractionCoords.divAssign( 2.0 );
  			refractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu

  			// Sample framebuffer to get pixel the refracted ray hits.
  			const transmissionSample = getTransmissionSample( refractionCoords, roughness, ior );

  			transmittedLight.element( i ).assign( transmissionSample.element( i ) );
  			transmittedLight.a.addAssign( transmissionSample.a );

  			transmittance.element( i ).assign( diffuseColor.element( i ).mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ).element( i ) ) );

  		} );

  		transmittedLight.a.divAssign( 3.0 );

  	} else {

  		const transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
  		const refractedRayExit = position.add( transmissionRay );

  		// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
  		const ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );
  		const refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();
  		refractionCoords.addAssign( 1.0 );
  		refractionCoords.divAssign( 2.0 );
  		refractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu

  		// Sample framebuffer to get pixel the refracted ray hits.
  		transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
  		transmittance = diffuseColor.mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ) );

  	}

  	const attenuatedColor = transmittance.rgb.mul( transmittedLight.rgb );
  	const dotNV = n.dot( v ).clamp();

  	// Get the specular component.
  	const F = vec3( EnvironmentBRDF( { // n, v, specularColor, specularF90, roughness
  		dotNV,
  		specularColor,
  		specularF90,
  		roughness
  	} ) );

  	// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job
  	// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.
  	const transmittanceFactor = transmittance.r.add( transmittance.g, transmittance.b ).div( 3.0 );

  	return vec4( F.oneMinus().mul( attenuatedColor ), transmittedLight.a.oneMinus().mul( transmittanceFactor ).oneMinus() );

  } );

  //
  // Iridescence
  //

  // XYZ to linear-sRGB color space
  const XYZ_TO_REC709 = /*@__PURE__*/ mat3(
  	3.2404542, - 0.9692660, 0.0556434,
  	- 1.5371385, 1.8760108, - 0.2040259,
  	- 0.4985314, 0.0415560, 1.0572252
  );

  // Assume air interface for top
  // Note: We don't handle the case fresnel0 == 1
  const Fresnel0ToIor = ( fresnel0 ) => {

  	const sqrtF0 = fresnel0.sqrt();
  	return vec3( 1.0 ).add( sqrtF0 ).div( vec3( 1.0 ).sub( sqrtF0 ) );

  };

  // ior is a value between 1.0 and 3.0. 1.0 is air interface
  const IorToFresnel0 = ( transmittedIor, incidentIor ) => {

  	return transmittedIor.sub( incidentIor ).div( transmittedIor.add( incidentIor ) ).pow2();

  };

  // Fresnel equations for dielectric/dielectric interfaces.
  // Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
  // Evaluation XYZ sensitivity curves in Fourier space
  const evalSensitivity = ( OPD, shift ) => {

  	const phase = OPD.mul( 2.0 * Math.PI * 1.0e-9 );
  	const val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
  	const pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
  	const VAR = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );

  	const x = float( 9.7470e-14 * Math.sqrt( 2.0 * Math.PI * 4.5282e+09 ) ).mul( phase.mul( 2.2399e+06 ).add( shift.x ).cos() ).mul( phase.pow2().mul( - 4.5282e+09 ).exp() );

  	let xyz = val.mul( VAR.mul( 2.0 * Math.PI ).sqrt() ).mul( pos.mul( phase ).add( shift ).cos() ).mul( phase.pow2().negate().mul( VAR ).exp() );
  	xyz = vec3( xyz.x.add( x ), xyz.y, xyz.z ).div( 1.0685e-7 );

  	const rgb = XYZ_TO_REC709.mul( xyz );

  	return rgb;

  };

  const evalIridescence = /*@__PURE__*/ Fn( ( { outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 } ) => {

  	// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
  	const iridescenceIOR = mix$2( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
  	// Evaluate the cosTheta on the base layer (Snell law)
  	const sinTheta2Sq = outsideIOR.div( iridescenceIOR ).pow2().mul( float( 1 ).sub( cosTheta1.pow2() ) );

  	// Handle TIR:
  	const cosTheta2Sq = float( 1 ).sub( sinTheta2Sq );
  	/*if ( cosTheta2Sq < 0.0 ) {

  			return vec3( 1.0 );

  	}*/

  	const cosTheta2 = cosTheta2Sq.sqrt();

  	// First interface
  	const R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
  	const R12 = F_Schlick( { f0: R0, f90: 1.0, dotVH: cosTheta1 } );
  	//const R21 = R12;
  	const T121 = R12.oneMinus();
  	const phi12 = iridescenceIOR.lessThan( outsideIOR ).select( Math.PI, 0.0 );
  	const phi21 = float( Math.PI ).sub( phi12 );

  	// Second interface
  	const baseIOR = Fresnel0ToIor( baseF0.clamp( 0.0, 0.9999 ) ); // guard against 1.0
  	const R1 = IorToFresnel0( baseIOR, iridescenceIOR.toVec3() );
  	const R23 = F_Schlick( { f0: R1, f90: 1.0, dotVH: cosTheta2 } );
  	const phi23 = vec3(
  		baseIOR.x.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),
  		baseIOR.y.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),
  		baseIOR.z.lessThan( iridescenceIOR ).select( Math.PI, 0.0 )
  	);

  	// Phase shift
  	const OPD = iridescenceIOR.mul( thinFilmThickness, cosTheta2, 2.0 );
  	const phi = vec3( phi21 ).add( phi23 );

  	// Compound terms
  	const R123 = R12.mul( R23 ).clamp( 1e-5, 0.9999 );
  	const r123 = R123.sqrt();
  	const Rs = T121.pow2().mul( R23 ).div( vec3( 1.0 ).sub( R123 ) );

  	// Reflectance term for m = 0 (DC term amplitude)
  	const C0 = R12.add( Rs );
  	let I = C0;

  	// Reflectance term for m > 0 (pairs of diracs)
  	let Cm = Rs.sub( T121 );
  	for ( let m = 1; m <= 2; ++ m ) {

  		Cm = Cm.mul( r123 );
  		const Sm = evalSensitivity( float( m ).mul( OPD ), float( m ).mul( phi ) ).mul( 2.0 );
  		I = I.add( Cm.mul( Sm ) );

  	}

  	// Since out of gamut colors might be produced, negative color values are clamped to 0.
  	return I.max( vec3( 0.0 ) );

  } ).setLayout( {
  	name: 'evalIridescence',
  	type: 'vec3',
  	inputs: [
  		{ name: 'outsideIOR', type: 'float' },
  		{ name: 'eta2', type: 'float' },
  		{ name: 'cosTheta1', type: 'float' },
  		{ name: 'thinFilmThickness', type: 'float' },
  		{ name: 'baseF0', type: 'vec3' }
  	]
  } );

  //
  //	Sheen
  //

  // This is a curve-fit approxmation to the "Charlie sheen" BRDF integrated over the hemisphere from
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
  // in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
  const IBLSheenBRDF = /*@__PURE__*/ Fn( ( { normal, viewDir, roughness } ) => {

  	const dotNV = normal.dot( viewDir ).saturate();

  	const r2 = roughness.pow2();

  	const a = select(
  		roughness.lessThan( 0.25 ),
  		float( - 339.2 ).mul( r2 ).add( float( 161.4 ).mul( roughness ) ).sub( 25.9 ),
  		float( - 8.48 ).mul( r2 ).add( float( 14.3 ).mul( roughness ) ).sub( 9.95 )
  	);

  	const b = select(
  		roughness.lessThan( 0.25 ),
  		float( 44.0 ).mul( r2 ).sub( float( 23.7 ).mul( roughness ) ).add( 3.26 ),
  		float( 1.97 ).mul( r2 ).sub( float( 3.27 ).mul( roughness ) ).add( 0.72 )
  	);

  	const DG = select( roughness.lessThan( 0.25 ), 0.0, float( 0.1 ).mul( roughness ).sub( 0.025 ) ).add( a.mul( dotNV ).add( b ).exp() );

  	return DG.mul( 1.0 / Math.PI ).saturate();

  } );

  const clearcoatF0 = vec3( 0.04 );
  const clearcoatF90 = float( 1 );

  //

  class PhysicalLightingModel extends LightingModel {

  	constructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false ) {

  		super();

  		this.clearcoat = clearcoat;
  		this.sheen = sheen;
  		this.iridescence = iridescence;
  		this.anisotropy = anisotropy;
  		this.transmission = transmission;
  		this.dispersion = dispersion;

  		this.clearcoatRadiance = null;
  		this.clearcoatSpecularDirect = null;
  		this.clearcoatSpecularIndirect = null;
  		this.sheenSpecularDirect = null;
  		this.sheenSpecularIndirect = null;
  		this.iridescenceFresnel = null;
  		this.iridescenceF0 = null;

  	}

  	start( context ) {

  		if ( this.clearcoat === true ) {

  			this.clearcoatRadiance = vec3().toVar( 'clearcoatRadiance' );
  			this.clearcoatSpecularDirect = vec3().toVar( 'clearcoatSpecularDirect' );
  			this.clearcoatSpecularIndirect = vec3().toVar( 'clearcoatSpecularIndirect' );

  		}

  		if ( this.sheen === true ) {

  			this.sheenSpecularDirect = vec3().toVar( 'sheenSpecularDirect' );
  			this.sheenSpecularIndirect = vec3().toVar( 'sheenSpecularIndirect' );

  		}

  		if ( this.iridescence === true ) {

  			const dotNVi = transformedNormalView.dot( positionViewDirection ).clamp();

  			this.iridescenceFresnel = evalIridescence( {
  				outsideIOR: float( 1.0 ),
  				eta2: iridescenceIOR,
  				cosTheta1: dotNVi,
  				thinFilmThickness: iridescenceThickness,
  				baseF0: specularColor
  			} );

  			this.iridescenceF0 = Schlick_to_F0( { f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi } );

  		}

  		if ( this.transmission === true ) {

  			const position = positionWorld;
  			const v = cameraPosition.sub( positionWorld ).normalize(); // TODO: Create Node for this, same issue in MaterialX
  			const n = transformedNormalWorld;

  			context.backdrop = getIBLVolumeRefraction(
  				n,
  				v,
  				roughness,
  				diffuseColor,
  				specularColor,
  				specularF90, // specularF90
  				position, // positionWorld
  				modelWorldMatrix, // modelMatrix
  				cameraViewMatrix, // viewMatrix
  				cameraProjectionMatrix, // projMatrix
  				ior,
  				thickness,
  				attenuationColor,
  				attenuationDistance,
  				this.dispersion ? dispersion : null
  			);

  			context.backdropAlpha = transmission;

  			diffuseColor.a.mulAssign( mix$2( 1, context.backdrop.a, transmission ) );

  		}

  	}

  	// Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  	// Approximates multiscattering in order to preserve energy.
  	// http://www.jcgt.org/published/0008/01/03/

  	computeMultiscattering( singleScatter, multiScatter, specularF90 ) {

  		const dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

  		const fab = DFGApprox( { roughness, dotNV } );

  		const Fr = this.iridescenceF0 ? iridescence.mix( specularColor, this.iridescenceF0 ) : specularColor;

  		const FssEss = Fr.mul( fab.x ).add( specularF90.mul( fab.y ) );

  		const Ess = fab.x.add( fab.y );
  		const Ems = Ess.oneMinus();

  		const Favg = specularColor.add( specularColor.oneMinus().mul( 0.047619 ) ); // 1/21
  		const Fms = FssEss.mul( Favg ).div( Ems.mul( Favg ).oneMinus() );

  		singleScatter.addAssign( FssEss );
  		multiScatter.addAssign( Fms.mul( Ems ) );

  	}

  	direct( { lightDirection, lightColor, reflectedLight } ) {

  		const dotNL = transformedNormalView.dot( lightDirection ).clamp();
  		const irradiance = dotNL.mul( lightColor );

  		if ( this.sheen === true ) {

  			this.sheenSpecularDirect.addAssign( irradiance.mul( BRDF_Sheen( { lightDirection } ) ) );

  		}

  		if ( this.clearcoat === true ) {

  			const dotNLcc = transformedClearcoatNormalView.dot( lightDirection ).clamp();
  			const ccIrradiance = dotNLcc.mul( lightColor );

  			this.clearcoatSpecularDirect.addAssign( ccIrradiance.mul( BRDF_GGX( { lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView } ) ) );

  		}

  		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

  		reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_GGX( { lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy } ) ) );

  	}

  	directRectArea( { lightColor, lightPosition, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 } ) {

  		const p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction
  		const p1 = lightPosition.sub( halfWidth ).sub( halfHeight );
  		const p2 = lightPosition.sub( halfWidth ).add( halfHeight );
  		const p3 = lightPosition.add( halfWidth ).add( halfHeight );

  		const N = transformedNormalView;
  		const V = positionViewDirection;
  		const P = positionView.toVar();

  		const uv = LTC_Uv( { N, V, roughness } );

  		const t1 = ltc_1.uv( uv ).toVar();
  		const t2 = ltc_2.uv( uv ).toVar();

  		const mInv = mat3(
  			vec3( t1.x, 0, t1.y ),
  			vec3( 0, 1, 0 ),
  			vec3( t1.z, 0, t1.w )
  		).toVar();

  		// LTC Fresnel Approximation by Stephen Hill
  		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
  		const fresnel = specularColor.mul( t2.x ).add( specularColor.oneMinus().mul( t2.y ) ).toVar();

  		reflectedLight.directSpecular.addAssign( lightColor.mul( fresnel ).mul( LTC_Evaluate( { N, V, P, mInv, p0, p1, p2, p3 } ) ) );

  		reflectedLight.directDiffuse.addAssign( lightColor.mul( diffuseColor ).mul( LTC_Evaluate( { N, V, P, mInv: mat3( 1, 0, 0, 0, 1, 0, 0, 0, 1 ), p0, p1, p2, p3 } ) ) );

  	}

  	indirect( context, stack, builder ) {

  		this.indirectDiffuse( context, stack, builder );
  		this.indirectSpecular( context, stack, builder );
  		this.ambientOcclusion( context, stack, builder );

  	}

  	indirectDiffuse( { irradiance, reflectedLight } ) {

  		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

  	}

  	indirectSpecular( { radiance, iblIrradiance, reflectedLight } ) {

  		if ( this.sheen === true ) {

  			this.sheenSpecularIndirect.addAssign( iblIrradiance.mul(
  				sheen,
  				IBLSheenBRDF( {
  					normal: transformedNormalView,
  					viewDir: positionViewDirection,
  					roughness: sheenRoughness
  				} )
  			) );

  		}

  		if ( this.clearcoat === true ) {

  			const dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();

  			const clearcoatEnv = EnvironmentBRDF( {
  				dotNV: dotNVcc,
  				specularColor: clearcoatF0,
  				specularF90: clearcoatF90,
  				roughness: clearcoatRoughness
  			} );

  			this.clearcoatSpecularIndirect.addAssign( this.clearcoatRadiance.mul( clearcoatEnv ) );

  		}

  		// Both indirect specular and indirect diffuse light accumulate here

  		const singleScattering = vec3().toVar( 'singleScattering' );
  		const multiScattering = vec3().toVar( 'multiScattering' );
  		const cosineWeightedIrradiance = iblIrradiance.mul( 1 / Math.PI );

  		this.computeMultiscattering( singleScattering, multiScattering, specularF90 );

  		const totalScattering = singleScattering.add( multiScattering );

  		const diffuse = diffuseColor.mul( totalScattering.r.max( totalScattering.g ).max( totalScattering.b ).oneMinus() );

  		reflectedLight.indirectSpecular.addAssign( radiance.mul( singleScattering ) );
  		reflectedLight.indirectSpecular.addAssign( multiScattering.mul( cosineWeightedIrradiance ) );

  		reflectedLight.indirectDiffuse.addAssign( diffuse.mul( cosineWeightedIrradiance ) );

  	}

  	ambientOcclusion( { ambientOcclusion, reflectedLight } ) {

  		const dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

  		const aoNV = dotNV.add( ambientOcclusion );
  		const aoExp = roughness.mul( - 16.0 ).oneMinus().negate().exp2();

  		const aoNode = ambientOcclusion.sub( aoNV.pow( aoExp ).oneMinus() ).clamp();

  		if ( this.clearcoat === true ) {

  			this.clearcoatSpecularIndirect.mulAssign( ambientOcclusion );

  		}

  		if ( this.sheen === true ) {

  			this.sheenSpecularIndirect.mulAssign( ambientOcclusion );

  		}

  		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );
  		reflectedLight.indirectSpecular.mulAssign( aoNode );

  	}

  	finish( context ) {

  		const { outgoingLight } = context;

  		if ( this.clearcoat === true ) {

  			const dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();

  			const Fcc = F_Schlick( {
  				dotVH: dotNVcc,
  				f0: clearcoatF0,
  				f90: clearcoatF90
  			} );

  			const clearcoatLight = outgoingLight.mul( clearcoat.mul( Fcc ).oneMinus() ).add( this.clearcoatSpecularDirect.add( this.clearcoatSpecularIndirect ).mul( clearcoat ) );

  			outgoingLight.assign( clearcoatLight );

  		}

  		if ( this.sheen === true ) {

  			const sheenEnergyComp = sheen.r.max( sheen.g ).max( sheen.b ).mul( 0.157 ).oneMinus();
  			const sheenLight = outgoingLight.mul( sheenEnergyComp ).add( this.sheenSpecularDirect, this.sheenSpecularIndirect );

  			outgoingLight.assign( sheenLight );

  		}

  	}

  }

  // These defines must match with PMREMGenerator

  const cubeUV_r0 = /*@__PURE__*/ float( 1.0 );
  const cubeUV_m0 = /*@__PURE__*/ float( - 2.0 );
  const cubeUV_r1 = /*@__PURE__*/ float( 0.8 );
  const cubeUV_m1 = /*@__PURE__*/ float( - 1.0 );
  const cubeUV_r4 = /*@__PURE__*/ float( 0.4 );
  const cubeUV_m4 = /*@__PURE__*/ float( 2.0 );
  const cubeUV_r5 = /*@__PURE__*/ float( 0.305 );
  const cubeUV_m5 = /*@__PURE__*/ float( 3.0 );
  const cubeUV_r6 = /*@__PURE__*/ float( 0.21 );
  const cubeUV_m6 = /*@__PURE__*/ float( 4.0 );

  const cubeUV_minMipLevel = /*@__PURE__*/ float( 4.0 );
  const cubeUV_minTileSize = /*@__PURE__*/ float( 16.0 );

  // These shader functions convert between the UV coordinates of a single face of
  // a cubemap, the 0-5 integer index of a cube face, and the direction vector for
  // sampling a textureCube (not generally normalized ).

  const getFace = /*@__PURE__*/ Fn( ( [ direction ] ) => {

  	const absDirection = vec3( abs( direction ) ).toVar();
  	const face = float( - 1.0 ).toVar();

  	If( absDirection.x.greaterThan( absDirection.z ), () => {

  		If( absDirection.x.greaterThan( absDirection.y ), () => {

  			face.assign( select( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );

  		} ).Else( () => {

  			face.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );

  		} );

  	} ).Else( () => {

  		If( absDirection.z.greaterThan( absDirection.y ), () => {

  			face.assign( select( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );

  		} ).Else( () => {

  			face.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );

  		} );

  	} );

  	return face;

  } ).setLayout( {
  	name: 'getFace',
  	type: 'float',
  	inputs: [
  		{ name: 'direction', type: 'vec3' }
  	]
  } );

  // RH coordinate system; PMREM face-indexing convention
  const getUV = /*@__PURE__*/ Fn( ( [ direction, face ] ) => {

  	const uv = vec2().toVar();

  	If( face.equal( 0.0 ), () => {

  		uv.assign( vec2( direction.z, direction.y ).div( abs( direction.x ) ) ); // pos x

  	} ).ElseIf( face.equal( 1.0 ), () => {

  		uv.assign( vec2( direction.x.negate(), direction.z.negate() ).div( abs( direction.y ) ) ); // pos y

  	} ).ElseIf( face.equal( 2.0 ), () => {

  		uv.assign( vec2( direction.x.negate(), direction.y ).div( abs( direction.z ) ) ); // pos z

  	} ).ElseIf( face.equal( 3.0 ), () => {

  		uv.assign( vec2( direction.z.negate(), direction.y ).div( abs( direction.x ) ) ); // neg x

  	} ).ElseIf( face.equal( 4.0 ), () => {

  		uv.assign( vec2( direction.x.negate(), direction.z ).div( abs( direction.y ) ) ); // neg y

  	} ).Else( () => {

  		uv.assign( vec2( direction.x, direction.y ).div( abs( direction.z ) ) ); // neg z

  	} );

  	return mul( 0.5, uv.add( 1.0 ) );

  } ).setLayout( {
  	name: 'getUV',
  	type: 'vec2',
  	inputs: [
  		{ name: 'direction', type: 'vec3' },
  		{ name: 'face', type: 'float' }
  	]
  } );

  const roughnessToMip = /*@__PURE__*/ Fn( ( [ roughness ] ) => {

  	const mip = float( 0.0 ).toVar();

  	If( roughness.greaterThanEqual( cubeUV_r1 ), () => {

  		mip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );

  	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r4 ), () => {

  		mip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );

  	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r5 ), () => {

  		mip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );

  	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r6 ), () => {

  		mip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );

  	} ).Else( () => {

  		mip.assign( float( - 2.0 ).mul( log2( mul( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25

  	} );

  	return mip;

  } ).setLayout( {
  	name: 'roughnessToMip',
  	type: 'float',
  	inputs: [
  		{ name: 'roughness', type: 'float' }
  	]
  } );

  // RH coordinate system; PMREM face-indexing convention
  const getDirection = /*@__PURE__*/ Fn( ( [ uv_immutable, face ] ) => {

  	const uv = uv_immutable.toVar();
  	uv.assign( mul( 2.0, uv ).sub( 1.0 ) );
  	const direction = vec3( uv, 1.0 ).toVar();

  	If( face.equal( 0.0 ), () => {

  		direction.assign( direction.zyx ); // ( 1, v, u ) pos x

  	} ).ElseIf( face.equal( 1.0 ), () => {

  		direction.assign( direction.xzy );
  		direction.xz.mulAssign( - 1.0 ); // ( -u, 1, -v ) pos y

  	} ).ElseIf( face.equal( 2.0 ), () => {

  		direction.x.mulAssign( - 1.0 ); // ( -u, v, 1 ) pos z

  	} ).ElseIf( face.equal( 3.0 ), () => {

  		direction.assign( direction.zyx );
  		direction.xz.mulAssign( - 1.0 ); // ( -1, v, -u ) neg x

  	} ).ElseIf( face.equal( 4.0 ), () => {

  		direction.assign( direction.xzy );
  		direction.xy.mulAssign( - 1.0 ); // ( -u, -1, v ) neg y

  	} ).ElseIf( face.equal( 5.0 ), () => {

  		direction.z.mulAssign( - 1.0 ); // ( u, v, -1 ) neg zS

  	} );

  	return direction;

  } ).setLayout( {
  	name: 'getDirection',
  	type: 'vec3',
  	inputs: [
  		{ name: 'uv', type: 'vec2' },
  		{ name: 'face', type: 'float' }
  	]
  } );

  //

  const textureCubeUV = /*@__PURE__*/ Fn( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {

  	const roughness = float( roughness_immutable );
  	const sampleDir = vec3( sampleDir_immutable );

  	const mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
  	const mipF = fract( mip );
  	const mipInt = floor( mip );
  	const color0 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();

  	If( mipF.notEqual( 0.0 ), () => {

  		const color1 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();

  		color0.assign( mix$2( color0, color1, mipF ) );

  	} );

  	return color0;

  } );

  const bilinearCubeUV = /*@__PURE__*/ Fn( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {

  	const mipInt = float( mipInt_immutable ).toVar();
  	const direction = vec3( direction_immutable );
  	const face = float( getFace( direction ) ).toVar();
  	const filterInt = float( max$1( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();
  	mipInt.assign( max$1( mipInt, cubeUV_minMipLevel ) );
  	const faceSize = float( exp2( mipInt ) ).toVar();
  	const uv = vec2( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();

  	If( face.greaterThan( 2.0 ), () => {

  		uv.y.addAssign( faceSize );
  		face.subAssign( 3.0 );

  	} );

  	uv.x.addAssign( face.mul( faceSize ) );
  	uv.x.addAssign( filterInt.mul( mul( 3.0, cubeUV_minTileSize ) ) );
  	uv.y.addAssign( mul( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );
  	uv.x.mulAssign( CUBEUV_TEXEL_WIDTH );
  	uv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );

  	return envMap.uv( uv ).grad( vec2(), vec2() ); // disable anisotropic filtering

  } );

  const getSample = /*@__PURE__*/ Fn( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {

  	const cosTheta = cos( theta );

  	// Rodrigues' axis-angle rotation
  	const sampleDirection = outputDirection.mul( cosTheta )
  		.add( axis.cross( outputDirection ).mul( sin( theta ) ) )
  		.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );

  	return bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );

  } );

  const blur = /*@__PURE__*/ Fn( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {

  	const axis = vec3( select( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();

  	If( all( axis.equals( vec3( 0.0 ) ) ), () => {

  		axis.assign( vec3( outputDirection.z, 0.0, outputDirection.x.negate() ) );

  	} );

  	axis.assign( normalize( axis ) );

  	const gl_FragColor = vec3().toVar();
  	gl_FragColor.addAssign( weights.element( int( 0 ) ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );

  	Loop( { start: int( 1 ), end: n }, ( { i } ) => {

  		If( i.greaterThanEqual( samples ), () => {

  			Break();

  		} );

  		const theta = float( dTheta.mul( float( i ) ) ).toVar();
  		gl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( - 1.0 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );
  		gl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );

  	} );

  	return vec4( gl_FragColor, 1 );

  } );

  let _generator = null;

  const _cache = new WeakMap();

  function _generateCubeUVSize( imageHeight ) {

  	const maxMip = Math.log2( imageHeight ) - 2;

  	const texelHeight = 1.0 / imageHeight;

  	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

  	return { texelWidth, texelHeight, maxMip };

  }

  function _getPMREMFromTexture( texture ) {

  	let cacheTexture = _cache.get( texture );

  	const pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : - 1;

  	if ( pmremVersion !== texture.pmremVersion ) {

  		const image = texture.image;

  		if ( texture.isCubeTexture ) {

  			if ( isCubeMapReady( image ) ) {

  				cacheTexture = _generator.fromCubemap( texture, cacheTexture );

  			} else {

  				return null;

  			}


  		} else {

  			if ( isEquirectangularMapReady( image ) ) {

  				cacheTexture = _generator.fromEquirectangular( texture, cacheTexture );

  			} else {

  				return null;

  			}

  		}

  		cacheTexture.pmremVersion = texture.pmremVersion;

  		_cache.set( texture, cacheTexture );

  	}

  	return cacheTexture.texture;

  }

  class PMREMNode extends TempNode {

  	static get type() {

  		return 'PMREMNode';

  	}

  	constructor( value, uvNode = null, levelNode = null ) {

  		super( 'vec3' );

  		this._value = value;
  		this._pmrem = null;

  		this.uvNode = uvNode;
  		this.levelNode = levelNode;

  		this._generator = null;

  		const defaultTexture = new Texture();
  		defaultTexture.isRenderTargetTexture = true;

  		this._texture = texture( defaultTexture );

  		this._width = uniform( 0 );
  		this._height = uniform( 0 );
  		this._maxMip = uniform( 0 );

  		this.updateBeforeType = NodeUpdateType.RENDER;

  	}

  	set value( value ) {

  		this._value = value;
  		this._pmrem = null;

  	}

  	get value() {

  		return this._value;

  	}

  	updateFromTexture( texture ) {

  		const cubeUVSize = _generateCubeUVSize( texture.image.height );

  		this._texture.value = texture;
  		this._width.value = cubeUVSize.texelWidth;
  		this._height.value = cubeUVSize.texelHeight;
  		this._maxMip.value = cubeUVSize.maxMip;

  	}

  	updateBefore() {

  		let pmrem = this._pmrem;

  		const pmremVersion = pmrem ? pmrem.pmremVersion : - 1;
  		const texture = this._value;

  		if ( pmremVersion !== texture.pmremVersion ) {

  			if ( texture.isPMREMTexture === true ) {

  				pmrem = texture;

  			} else {

  				pmrem = _getPMREMFromTexture( texture );

  			}

  			if ( pmrem !== null ) {

  				this._pmrem = pmrem;

  				this.updateFromTexture( pmrem );

  			}

  		}

  	}

  	setup( builder ) {

  		if ( _generator === null ) {

  			_generator = builder.createPMREMGenerator();

  		}

  		//

  		this.updateBefore( builder );

  		//

  		let uvNode = this.uvNode;

  		if ( uvNode === null && builder.context.getUV ) {

  			uvNode = builder.context.getUV( this );

  		}

  		//

  		const texture = this.value;

  		if ( builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true ) {

  			uvNode = vec3( uvNode.x.negate(), uvNode.yz );

  		}

  		//

  		let levelNode = this.levelNode;

  		if ( levelNode === null && builder.context.getTextureLevel ) {

  			levelNode = builder.context.getTextureLevel( this );

  		}

  		//

  		return textureCubeUV( this._texture, uvNode, levelNode, this._width, this._height, this._maxMip );

  	}

  }

  function isCubeMapReady( image ) {

  	if ( image === null || image === undefined ) return false;

  	let count = 0;
  	const length = 6;

  	for ( let i = 0; i < length; i ++ ) {

  		if ( image[ i ] !== undefined ) count ++;

  	}

  	return count === length;


  }

  function isEquirectangularMapReady( image ) {

  	if ( image === null || image === undefined ) return false;

  	return image.height > 0;

  }

  const pmremTexture = /*@__PURE__*/ nodeProxy( PMREMNode );

  const _envNodeCache = new WeakMap();

  class EnvironmentNode extends LightingNode {

  	static get type() {

  		return 'EnvironmentNode';

  	}

  	constructor( envNode = null ) {

  		super();

  		this.envNode = envNode;

  	}

  	setup( builder ) {

  		const { material } = builder;

  		let envNode = this.envNode;

  		if ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {

  			const value = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];

  			let cacheEnvNode = _envNodeCache.get( value );

  			if ( cacheEnvNode === undefined ) {

  				cacheEnvNode = pmremTexture( value );

  				_envNodeCache.set( value, cacheEnvNode );

  			}

  			envNode	= cacheEnvNode;

  		}

  		//

  		const envMap = material.envMap;
  		const intensity = envMap ? reference( 'envMapIntensity', 'float', builder.material ) : reference( 'environmentIntensity', 'float', builder.scene ); // @TODO: Add materialEnvIntensity in MaterialNode

  		const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;
  		const radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;

  		const radiance = envNode.context( createRadianceContext( roughness, radianceNormalView ) ).mul( intensity );
  		const irradiance = envNode.context( createIrradianceContext( transformedNormalWorld ) ).mul( Math.PI ).mul( intensity );

  		const isolateRadiance = cache( radiance );
  		const isolateIrradiance = cache( irradiance );

  		//

  		builder.context.radiance.addAssign( isolateRadiance );

  		builder.context.iblIrradiance.addAssign( isolateIrradiance );

  		//

  		const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;

  		if ( clearcoatRadiance ) {

  			const clearcoatRadianceContext = envNode.context( createRadianceContext( clearcoatRoughness, transformedClearcoatNormalView ) ).mul( intensity );
  			const isolateClearcoatRadiance = cache( clearcoatRadianceContext );

  			clearcoatRadiance.addAssign( isolateClearcoatRadiance );

  		}

  	}

  }

  const createRadianceContext = ( roughnessNode, normalViewNode ) => {

  	let reflectVec = null;

  	return {
  		getUV: () => {

  			if ( reflectVec === null ) {

  				reflectVec = positionViewDirection.negate().reflect( normalViewNode );

  				// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
  				reflectVec = roughnessNode.mul( roughnessNode ).mix( reflectVec, normalViewNode ).normalize();

  				reflectVec = reflectVec.transformDirection( cameraViewMatrix );

  			}

  			return reflectVec;

  		},
  		getTextureLevel: () => {

  			return roughnessNode;

  		}
  	};

  };

  const createIrradianceContext = ( normalWorldNode ) => {

  	return {
  		getUV: () => {

  			return normalWorldNode;

  		},
  		getTextureLevel: () => {

  			return float( 1.0 );

  		}
  	};

  };

  const _defaultValues$6 = /*@__PURE__*/ new MeshStandardMaterial();

  class MeshStandardNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshStandardNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.isMeshStandardNodeMaterial = true;

  		this.lights = true;

  		this.emissiveNode = null;

  		this.metalnessNode = null;
  		this.roughnessNode = null;

  		this.setDefaultValues( _defaultValues$6 );

  		this.setValues( parameters );

  	}

  	setupEnvironment( builder ) {

  		let envNode = super.setupEnvironment( builder );

  		if ( envNode === null && builder.environmentNode ) {

  			envNode = builder.environmentNode;

  		}

  		return envNode ? new EnvironmentNode( envNode ) : null;

  	}

  	setupLightingModel( /*builder*/ ) {

  		return new PhysicalLightingModel();

  	}

  	setupSpecular() {

  		const specularColorNode = mix$2( vec3( 0.04 ), diffuseColor.rgb, metalness );

  		specularColor.assign( specularColorNode );
  		specularF90.assign( 1.0 );

  	}

  	setupVariants() {

  		// METALNESS

  		const metalnessNode = this.metalnessNode ? float( this.metalnessNode ) : materialMetalness;

  		metalness.assign( metalnessNode );

  		// ROUGHNESS

  		let roughnessNode = this.roughnessNode ? float( this.roughnessNode ) : materialRoughness;
  		roughnessNode = getRoughness( { roughness: roughnessNode } );

  		roughness.assign( roughnessNode );

  		// SPECULAR COLOR

  		this.setupSpecular();

  		// DIFFUSE COLOR

  		diffuseColor.assign( vec4( diffuseColor.rgb.mul( metalnessNode.oneMinus() ), diffuseColor.a ) );

  	}

  	copy( source ) {

  		this.emissiveNode = source.emissiveNode;

  		this.metalnessNode = source.metalnessNode;
  		this.roughnessNode = source.roughnessNode;

  		return super.copy( source );

  	}

  }

  const _defaultValues$5 = /*@__PURE__*/ new MeshPhysicalMaterial();

  class MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {

  	static get type() {

  		return 'MeshPhysicalNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.isMeshPhysicalNodeMaterial = true;

  		this.clearcoatNode = null;
  		this.clearcoatRoughnessNode = null;
  		this.clearcoatNormalNode = null;

  		this.sheenNode = null;
  		this.sheenRoughnessNode = null;

  		this.iridescenceNode = null;
  		this.iridescenceIORNode = null;
  		this.iridescenceThicknessNode = null;

  		this.specularIntensityNode = null;
  		this.specularColorNode = null;

  		this.iorNode = null;
  		this.transmissionNode = null;
  		this.thicknessNode = null;
  		this.attenuationDistanceNode = null;
  		this.attenuationColorNode = null;
  		this.dispersionNode = null;

  		this.anisotropyNode = null;

  		this.setDefaultValues( _defaultValues$5 );

  		this.setValues( parameters );

  	}

  	get useClearcoat() {

  		return this.clearcoat > 0 || this.clearcoatNode !== null;

  	}

  	get useIridescence() {

  		return this.iridescence > 0 || this.iridescenceNode !== null;

  	}

  	get useSheen() {

  		return this.sheen > 0 || this.sheenNode !== null;

  	}

  	get useAnisotropy() {

  		return this.anisotropy > 0 || this.anisotropyNode !== null;

  	}

  	get useTransmission() {

  		return this.transmission > 0 || this.transmissionNode !== null;

  	}

  	get useDispersion() {

  		return this.dispersion > 0 || this.dispersionNode !== null;

  	}

  	setupSpecular() {

  		const iorNode = this.iorNode ? float( this.iorNode ) : materialIOR;

  		ior.assign( iorNode );
  		specularColor.assign( mix$2( min$1( pow2( ior.sub( 1.0 ).div( ior.add( 1.0 ) ) ).mul( materialSpecularColor ), vec3( 1.0 ) ).mul( materialSpecularIntensity ), diffuseColor.rgb, metalness ) );
  		specularF90.assign( mix$2( materialSpecularIntensity, 1.0, metalness ) );

  	}

  	setupLightingModel( /*builder*/ ) {

  		return new PhysicalLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion );

  	}

  	setupVariants( builder ) {

  		super.setupVariants( builder );

  		// CLEARCOAT

  		if ( this.useClearcoat ) {

  			const clearcoatNode = this.clearcoatNode ? float( this.clearcoatNode ) : materialClearcoat;
  			const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float( this.clearcoatRoughnessNode ) : materialClearcoatRoughness;

  			clearcoat.assign( clearcoatNode );
  			clearcoatRoughness.assign( getRoughness( { roughness: clearcoatRoughnessNode } ) );

  		}

  		// SHEEN

  		if ( this.useSheen ) {

  			const sheenNode = this.sheenNode ? vec3( this.sheenNode ) : materialSheen;
  			const sheenRoughnessNode = this.sheenRoughnessNode ? float( this.sheenRoughnessNode ) : materialSheenRoughness;

  			sheen.assign( sheenNode );
  			sheenRoughness.assign( sheenRoughnessNode );

  		}

  		// IRIDESCENCE

  		if ( this.useIridescence ) {

  			const iridescenceNode = this.iridescenceNode ? float( this.iridescenceNode ) : materialIridescence;
  			const iridescenceIORNode = this.iridescenceIORNode ? float( this.iridescenceIORNode ) : materialIridescenceIOR;
  			const iridescenceThicknessNode = this.iridescenceThicknessNode ? float( this.iridescenceThicknessNode ) : materialIridescenceThickness;

  			iridescence.assign( iridescenceNode );
  			iridescenceIOR.assign( iridescenceIORNode );
  			iridescenceThickness.assign( iridescenceThicknessNode );

  		}

  		// ANISOTROPY

  		if ( this.useAnisotropy ) {

  			const anisotropyV = ( this.anisotropyNode ? vec2( this.anisotropyNode ) : materialAnisotropy ).toVar();

  			anisotropy.assign( anisotropyV.length() );

  			If( anisotropy.equal( 0.0 ), () => {

  				anisotropyV.assign( vec2( 1.0, 0.0 ) );

  			} ).Else( () => {

  				anisotropyV.divAssign( vec2( anisotropy ) );
  				anisotropy.assign( anisotropy.saturate() );

  			} );

  			// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.
  			alphaT.assign( anisotropy.pow2().mix( roughness.pow2(), 1.0 ) );

  			anisotropyT.assign( TBNViewMatrix[ 0 ].mul( anisotropyV.x ).add( TBNViewMatrix[ 1 ].mul( anisotropyV.y ) ) );
  			anisotropyB.assign( TBNViewMatrix[ 1 ].mul( anisotropyV.x ).sub( TBNViewMatrix[ 0 ].mul( anisotropyV.y ) ) );

  		}

  		// TRANSMISSION

  		if ( this.useTransmission ) {

  			const transmissionNode = this.transmissionNode ? float( this.transmissionNode ) : materialTransmission;
  			const thicknessNode = this.thicknessNode ? float( this.thicknessNode ) : materialThickness;
  			const attenuationDistanceNode = this.attenuationDistanceNode ? float( this.attenuationDistanceNode ) : materialAttenuationDistance;
  			const attenuationColorNode = this.attenuationColorNode ? vec3( this.attenuationColorNode ) : materialAttenuationColor;

  			transmission.assign( transmissionNode );
  			thickness.assign( thicknessNode );
  			attenuationDistance.assign( attenuationDistanceNode );
  			attenuationColor.assign( attenuationColorNode );

  			if ( this.useDispersion ) {

  				const dispersionNode = this.dispersionNode ? float( this.dispersionNode ) : materialDispersion;

  				dispersion.assign( dispersionNode );

  			}

  		}

  	}

  	setupClearcoatNormal() {

  		return this.clearcoatNormalNode ? vec3( this.clearcoatNormalNode ) : materialClearcoatNormal;

  	}

  	setup( builder ) {

  		builder.context.setupClearcoatNormal = () => this.setupClearcoatNormal( builder );

  		super.setup( builder );

  	}

  	copy( source ) {

  		this.clearcoatNode = source.clearcoatNode;
  		this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
  		this.clearcoatNormalNode = source.clearcoatNormalNode;

  		this.sheenNode = source.sheenNode;
  		this.sheenRoughnessNode = source.sheenRoughnessNode;

  		this.iridescenceNode = source.iridescenceNode;
  		this.iridescenceIORNode = source.iridescenceIORNode;
  		this.iridescenceThicknessNode = source.iridescenceThicknessNode;

  		this.specularIntensityNode = source.specularIntensityNode;
  		this.specularColorNode = source.specularColorNode;

  		this.transmissionNode = source.transmissionNode;
  		this.thicknessNode = source.thicknessNode;
  		this.attenuationDistanceNode = source.attenuationDistanceNode;
  		this.attenuationColorNode = source.attenuationColorNode;
  		this.dispersionNode = source.dispersionNode;

  		this.anisotropyNode = source.anisotropyNode;

  		return super.copy( source );

  	}

  }

  const getGradientIrradiance = /*@__PURE__*/ Fn( ( { normal, lightDirection, builder } ) => {

  	// dotNL will be from -1.0 to 1.0
  	const dotNL = normal.dot( lightDirection );
  	const coord = vec2( dotNL.mul( 0.5 ).add( 0.5 ), 0.0 );

  	if ( builder.material.gradientMap ) {

  		const gradientMap = materialReference( 'gradientMap', 'texture' ).context( { getUV: () => coord } );

  		return vec3( gradientMap.r );

  	} else {

  		const fw = coord.fwidth().mul( 0.5 );

  		return mix$2( vec3( 0.7 ), vec3( 1.0 ), smoothstep( float( 0.7 ).sub( fw.x ), float( 0.7 ).add( fw.x ), coord.x ) );

  	}

  } );

  class ToonLightingModel extends LightingModel {

  	direct( { lightDirection, lightColor, reflectedLight }, stack, builder ) {

  		const irradiance = getGradientIrradiance( { normal: normalGeometry, lightDirection, builder } ).mul( lightColor );

  		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

  	}

  	indirect( { ambientOcclusion, irradiance, reflectedLight } ) {

  		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

  		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

  	}

  }

  const _defaultValues$4 = /*@__PURE__*/ new MeshToonMaterial();

  class MeshToonNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshToonNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.isMeshToonNodeMaterial = true;

  		this.lights = true;

  		this.setDefaultValues( _defaultValues$4 );

  		this.setValues( parameters );

  	}

  	setupLightingModel( /*builder*/ ) {

  		return new ToonLightingModel();

  	}

  }

  class MatcapUVNode extends TempNode {

  	static get type() {

  		return 'MatcapUVNode';

  	}

  	constructor() {

  		super( 'vec2' );

  	}

  	setup() {

  		const x = vec3( positionViewDirection.z, 0, positionViewDirection.x.negate() ).normalize();
  		const y = positionViewDirection.cross( x );

  		return vec2( x.dot( transformedNormalView ), y.dot( transformedNormalView ) ).mul( 0.495 ).add( 0.5 ); // 0.495 to remove artifacts caused by undersized matcap disks

  	}

  }

  const matcapUV = /*@__PURE__*/ nodeImmutable( MatcapUVNode );

  const _defaultValues$3 = /*@__PURE__*/ new MeshMatcapMaterial();

  class MeshMatcapNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'MeshMatcapNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.lights = false;

  		this.isMeshMatcapNodeMaterial = true;

  		this.setDefaultValues( _defaultValues$3 );

  		this.setValues( parameters );

  	}

  	setupVariants( builder ) {

  		const uv = matcapUV;

  		let matcapColor;

  		if ( builder.material.matcap ) {

  			matcapColor = materialReference( 'matcap', 'texture' ).context( { getUV: () => uv } );

  		} else {

  			matcapColor = vec3( mix$2( 0.2, 0.8, uv.y ) ); // default if matcap is missing

  		}

  		diffuseColor.rgb.mulAssign( matcapColor.rgb );

  	}

  }

  const _defaultValues$2 = /*@__PURE__*/ new PointsMaterial();

  class PointsNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'PointsNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.isPointsNodeMaterial = true;

  		this.lights = false;
  		this.transparent = true;

  		this.sizeNode = null;

  		this.setDefaultValues( _defaultValues$2 );

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		this.sizeNode = source.sizeNode;

  		return super.copy( source );

  	}

  }

  class RotateNode extends TempNode {

  	static get type() {

  		return 'RotateNode';

  	}

  	constructor( positionNode, rotationNode ) {

  		super();

  		this.positionNode = positionNode;
  		this.rotationNode = rotationNode;

  	}

  	getNodeType( builder ) {

  		return this.positionNode.getNodeType( builder );

  	}

  	setup( builder ) {

  		const { rotationNode, positionNode } = this;

  		const nodeType = this.getNodeType( builder );

  		if ( nodeType === 'vec2' ) {

  			const cosAngle = rotationNode.cos();
  			const sinAngle = rotationNode.sin();

  			const rotationMatrix = mat2(
  				cosAngle, sinAngle,
  				sinAngle.negate(), cosAngle
  			);

  			return rotationMatrix.mul( positionNode );

  		} else {

  			const rotation = rotationNode;
  			const rotationXMatrix = mat4( vec4( 1.0, 0.0, 0.0, 0.0 ), vec4( 0.0, cos( rotation.x ), sin( rotation.x ).negate(), 0.0 ), vec4( 0.0, sin( rotation.x ), cos( rotation.x ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );
  			const rotationYMatrix = mat4( vec4( cos( rotation.y ), 0.0, sin( rotation.y ), 0.0 ), vec4( 0.0, 1.0, 0.0, 0.0 ), vec4( sin( rotation.y ).negate(), 0.0, cos( rotation.y ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );
  			const rotationZMatrix = mat4( vec4( cos( rotation.z ), sin( rotation.z ).negate(), 0.0, 0.0 ), vec4( sin( rotation.z ), cos( rotation.z ), 0.0, 0.0 ), vec4( 0.0, 0.0, 1.0, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );

  			return rotationXMatrix.mul( rotationYMatrix ).mul( rotationZMatrix ).mul( vec4( positionNode, 1.0 ) ).xyz;

  		}

  	}

  }

  const rotate = /*@__PURE__*/ nodeProxy( RotateNode );

  const _defaultValues$1 = /*@__PURE__*/ new SpriteMaterial();

  class SpriteNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'SpriteNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.isSpriteNodeMaterial = true;

  		this.lights = false;
  		this._useSizeAttenuation = true;

  		this.positionNode = null;
  		this.rotationNode = null;
  		this.scaleNode = null;

  		this.setDefaultValues( _defaultValues$1 );

  		this.setValues( parameters );

  	}

  	setupPosition( { object, camera, context } ) {

  		const sizeAttenuation = this.sizeAttenuation;

  		// < VERTEX STAGE >

  		const { positionNode, rotationNode, scaleNode } = this;

  		const vertex = positionLocal;

  		let mvPosition = modelViewMatrix.mul( vec3( positionNode || 0 ) );

  		let scale = vec2( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );

  		if ( scaleNode !== null ) {

  			scale = scale.mul( scaleNode );

  		}


  		if ( ! sizeAttenuation && camera.isPerspectiveCamera ) {

  			scale = scale.mul( mvPosition.z.negate() );

  		}

  		let alignedPosition = vertex.xy;

  		if ( object.center && object.center.isVector2 === true ) {

  			const center = reference$1( 'center', 'vec2' );

  			alignedPosition = alignedPosition.sub( center.sub( 0.5 ) );

  		}

  		alignedPosition = alignedPosition.mul( scale );

  		const rotation = float( rotationNode || materialRotation );

  		const rotatedPosition = rotate( alignedPosition, rotation );

  		mvPosition = vec4( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );

  		const modelViewProjection = cameraProjectionMatrix.mul( mvPosition );

  		context.vertex = vertex;

  		return modelViewProjection;

  	}

  	copy( source ) {

  		this.positionNode = source.positionNode;
  		this.rotationNode = source.rotationNode;
  		this.scaleNode = source.scaleNode;

  		return super.copy( source );

  	}

  	get sizeAttenuation() {

  		return this._useSizeAttenuation;

  	}

  	set sizeAttenuation( value ) {

  		if ( this._useSizeAttenuation !== value ) {

  			this._useSizeAttenuation = value;
  			this.needsUpdate = true;

  		}

  	}

  }

  class ShadowMaskModel extends LightingModel {

  	constructor() {

  		super();

  		this.shadowNode = float( 1 ).toVar( 'shadowMask' );

  	}

  	direct( { shadowMask } ) {

  		this.shadowNode.mulAssign( shadowMask );

  	}

  	finish( context ) {

  		diffuseColor.a.mulAssign( this.shadowNode.oneMinus() );

  		context.outgoingLight.rgb.assign( diffuseColor.rgb ); // TODO: Optimize LightsNode to avoid this assignment

  	}

  }

  const _defaultValues = /*@__PURE__*/ new ShadowMaterial();

  class ShadowNodeMaterial extends NodeMaterial {

  	static get type() {

  		return 'ShadowNodeMaterial';

  	}

  	constructor( parameters ) {

  		super();

  		this.isShadowNodeMaterial = true;

  		this.lights = true;

  		this.setDefaultValues( _defaultValues );

  		this.setValues( parameters );

  	}

  	setupLightingModel( /*builder*/ ) {

  		return new ShadowMaskModel();

  	}

  }

  Fn( ( { texture, uv } ) => {

  	const epsilon = 0.0001;

  	const ret = vec3().toVar();

  	If( uv.x.lessThan( epsilon ), () => {

  		ret.assign( vec3( 1, 0, 0 ) );

  	} ).ElseIf( uv.y.lessThan( epsilon ), () => {

  		ret.assign( vec3( 0, 1, 0 ) );

  	} ).ElseIf( uv.z.lessThan( epsilon ), () => {

  		ret.assign( vec3( 0, 0, 1 ) );

  	} ).ElseIf( uv.x.greaterThan( 1 - epsilon ), () => {

  		ret.assign( vec3( - 1, 0, 0 ) );

  	} ).ElseIf( uv.y.greaterThan( 1 - epsilon ), () => {

  		ret.assign( vec3( 0, - 1, 0 ) );

  	} ).ElseIf( uv.z.greaterThan( 1 - epsilon ), () => {

  		ret.assign( vec3( 0, 0, - 1 ) );

  	} ).Else( () => {

  		const step = 0.01;

  		const x = texture.uv( uv.add( vec3( - step, 0.0, 0.0 ) ) ).r.sub( texture.uv( uv.add( vec3( step, 0.0, 0.0 ) ) ).r );
  		const y = texture.uv( uv.add( vec3( 0.0, - step, 0.0 ) ) ).r.sub( texture.uv( uv.add( vec3( 0.0, step, 0.0 ) ) ).r );
  		const z = texture.uv( uv.add( vec3( 0.0, 0.0, - step ) ) ).r.sub( texture.uv( uv.add( vec3( 0.0, 0.0, step ) ) ).r );

  		ret.assign( vec3( x, y, z ) );

  	} );

  	return ret.normalize();

  } );

  class Animation {

  	constructor( nodes, info ) {

  		this.nodes = nodes;
  		this.info = info;

  		this.animationLoop = null;
  		this.requestId = null;

  		this._init();

  	}

  	_init() {

  		const update = ( time, frame ) => {

  			this.requestId = self.requestAnimationFrame( update );

  			if ( this.info.autoReset === true ) this.info.reset();

  			this.nodes.nodeFrame.update();

  			this.info.frame = this.nodes.nodeFrame.frameId;

  			if ( this.animationLoop !== null ) this.animationLoop( time, frame );

  		};

  		update();

  	}

  	dispose() {

  		self.cancelAnimationFrame( this.requestId );
  		this.requestId = null;

  	}

  	setAnimationLoop( callback ) {

  		this.animationLoop = callback;

  	}

  }

  class ChainMap {

  	constructor() {

  		this.weakMap = new WeakMap();

  	}

  	get( keys ) {

  		let map = this.weakMap;

  		for ( let i = 0; i < keys.length; i ++ ) {

  			map = map.get( keys[ i ] );

  			if ( map === undefined ) return undefined;

  		}

  		return map.get( keys[ keys.length - 1 ] );

  	}

  	set( keys, value ) {

  		let map = this.weakMap;

  		for ( let i = 0; i < keys.length; i ++ ) {

  			const key = keys[ i ];

  			if ( map.has( key ) === false ) map.set( key, new WeakMap() );

  			map = map.get( key );

  		}

  		return map.set( keys[ keys.length - 1 ], value );

  	}

  	delete( keys ) {

  		let map = this.weakMap;

  		for ( let i = 0; i < keys.length; i ++ ) {

  			map = map.get( keys[ i ] );

  			if ( map === undefined ) return false;

  		}

  		return map.delete( keys[ keys.length - 1 ] );

  	}

  }

  const _plane$1 = /*@__PURE__*/ new Plane();

  class ClippingContext {

  	constructor() {

  		this.version = 0;

  		this.globalClippingCount = 0;

  		this.localClippingCount = 0;
  		this.localClippingEnabled = false;
  		this.localClipIntersection = false;

  		this.planes = [];

  		this.parentVersion = 0;
  		this.viewNormalMatrix = new Matrix3();
  		this.cacheKey = 0;

  	}

  	projectPlanes( source, offset ) {

  		const l = source.length;
  		const planes = this.planes;

  		for ( let i = 0; i < l; i ++ ) {

  			_plane$1.copy( source[ i ] ).applyMatrix4( this.viewMatrix, this.viewNormalMatrix );

  			const v = planes[ offset + i ];
  			const normal = _plane$1.normal;

  			v.x = - normal.x;
  			v.y = - normal.y;
  			v.z = - normal.z;
  			v.w = _plane$1.constant;

  		}

  	}

  	updateGlobal( renderer, camera ) {

  		const rendererClippingPlanes = renderer.clippingPlanes;
  		this.viewMatrix = camera.matrixWorldInverse;

  		this.viewNormalMatrix.getNormalMatrix( this.viewMatrix );

  		let update = false;

  		if ( Array.isArray( rendererClippingPlanes ) && rendererClippingPlanes.length !== 0 ) {

  			const l = rendererClippingPlanes.length;

  			if ( l !== this.globalClippingCount ) {

  				const planes = [];

  				for ( let i = 0; i < l; i ++ ) {

  					planes.push( new Vector4() );

  				}

  				this.globalClippingCount = l;
  				this.planes = planes;

  				update = true;

  			}

  			this.projectPlanes( rendererClippingPlanes, 0 );

  		} else if ( this.globalClippingCount !== 0 ) {

  			this.globalClippingCount = 0;
  			this.planes = [];
  			update = true;

  		}

  		if ( renderer.localClippingEnabled !== this.localClippingEnabled ) {

  			this.localClippingEnabled = renderer.localClippingEnabled;
  			update = true;

  		}

  		if ( update ) {

  			this.version ++;
  			this.cacheKey = hash$1( this.globalClippingCount, this.localClippingEnabled === true ? 1 : 0 );

  		}

  	}

  	update( parent, material ) {

  		let update = false;

  		if ( this !== parent && parent.version !== this.parentVersion ) {

  			this.globalClippingCount = material.isShadowNodeMaterial ? 0 : parent.globalClippingCount;
  			this.localClippingEnabled = parent.localClippingEnabled;
  			this.planes = Array.from( parent.planes );
  			this.parentVersion = parent.version;
  			this.viewMatrix = parent.viewMatrix;
  			this.viewNormalMatrix = parent.viewNormalMatrix;

  			update = true;

  		}

  		if ( this.localClippingEnabled ) {

  			const localClippingPlanes = material.clippingPlanes;

  			if ( ( Array.isArray( localClippingPlanes ) && localClippingPlanes.length !== 0 ) ) {

  				const l = localClippingPlanes.length;
  				const planes = this.planes;
  				const offset = this.globalClippingCount;

  				if ( update || l !== this.localClippingCount ) {

  					planes.length = offset + l;

  					for ( let i = 0; i < l; i ++ ) {

  						planes[ offset + i ] = new Vector4();

  					}

  					this.localClippingCount = l;
  					update = true;

  				}

  				this.projectPlanes( localClippingPlanes, offset );


  			} else if ( this.localClippingCount !== 0 ) {

  				this.localClippingCount = 0;
  				update = true;

  			}

  			if ( this.localClipIntersection !== material.clipIntersection ) {

  				this.localClipIntersection = material.clipIntersection;
  				update = true;

  			}

  		}

  		if ( update ) {

  			this.version += parent.version;
  			this.cacheKey = hash$1( parent.cacheKey, this.localClippingCount, this.localClipIntersection === true ? 1 : 0 );

  		}

  	}

  }

  let _id$7 = 0;

  function getKeys( obj ) {

  	const keys = Object.keys( obj );

  	let proto = Object.getPrototypeOf( obj );

  	while ( proto ) {

  		const descriptors = Object.getOwnPropertyDescriptors( proto );

  		for ( const key in descriptors ) {

  			if ( descriptors[ key ] !== undefined ) {

  				const descriptor = descriptors[ key ];

  				if ( descriptor && typeof descriptor.get === 'function' ) {

  					keys.push( key );

  				}

  			}

  		}

  		proto = Object.getPrototypeOf( proto );

  	}

  	return keys;

  }

  class RenderObject {

  	constructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext ) {

  		this._nodes = nodes;
  		this._geometries = geometries;

  		this.id = _id$7 ++;

  		this.renderer = renderer;
  		this.object = object;
  		this.material = material;
  		this.scene = scene;
  		this.camera = camera;
  		this.lightsNode = lightsNode;
  		this.context = renderContext;

  		this.geometry = object.geometry;
  		this.version = material.version;

  		this.drawRange = null;

  		this.attributes = null;
  		this.pipeline = null;
  		this.vertexBuffers = null;
  		this.drawParams = null;

  		this.bundle = null;

  		this.updateClipping( renderContext.clippingContext );

  		this.clippingContextVersion = this.clippingContext.version;

  		this.initialNodesCacheKey = this.getDynamicCacheKey();
  		this.initialCacheKey = this.getCacheKey();

  		this._nodeBuilderState = null;
  		this._bindings = null;
  		this._monitor = null;

  		this.onDispose = null;

  		this.isRenderObject = true;

  		this.onMaterialDispose = () => {

  			this.dispose();

  		};

  		this.material.addEventListener( 'dispose', this.onMaterialDispose );

  	}

  	updateClipping( parent ) {

  		const material = this.material;

  		let clippingContext = this.clippingContext;

  		if ( Array.isArray( material.clippingPlanes ) ) {

  			if ( clippingContext === parent || ! clippingContext ) {

  				clippingContext = new ClippingContext();
  				this.clippingContext = clippingContext;

  			}

  			clippingContext.update( parent, material );

  		} else if ( this.clippingContext !== parent ) {

  			this.clippingContext = parent;

  		}

  	}

  	get clippingNeedsUpdate() {

  		if ( this.clippingContext.version === this.clippingContextVersion ) return false;

  		this.clippingContextVersion = this.clippingContext.version;

  		return true;

  	}

  	getNodeBuilderState() {

  		return this._nodeBuilderState || ( this._nodeBuilderState = this._nodes.getForRender( this ) );

  	}

  	getMonitor() {

  		return this._monitor || ( this._monitor = this.getNodeBuilderState().monitor );

  	}

  	getBindings() {

  		return this._bindings || ( this._bindings = this.getNodeBuilderState().createBindings() );

  	}

  	getIndex() {

  		return this._geometries.getIndex( this );

  	}

  	getChainArray() {

  		return [ this.object, this.material, this.context, this.lightsNode ];

  	}

  	getAttributes() {

  		if ( this.attributes !== null ) return this.attributes;

  		const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
  		const geometry = this.geometry;

  		const attributes = [];
  		const vertexBuffers = new Set();

  		for ( const nodeAttribute of nodeAttributes ) {

  			const attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute( nodeAttribute.name );

  			if ( attribute === undefined ) continue;

  			attributes.push( attribute );

  			const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
  			vertexBuffers.add( bufferAttribute );

  		}

  		this.attributes = attributes;
  		this.vertexBuffers = Array.from( vertexBuffers.values() );

  		return attributes;

  	}

  	getVertexBuffers() {

  		if ( this.vertexBuffers === null ) this.getAttributes();

  		return this.vertexBuffers;

  	}

  	getDrawParameters() {

  		const { object, material, geometry, group, drawRange } = this;

  		const drawParams = this.drawParams || ( this.drawParams = {
  			vertexCount: 0,
  			firstVertex: 0,
  			instanceCount: 0,
  			firstInstance: 0
  		} );

  		const index = this.getIndex();
  		const hasIndex = ( index !== null );
  		const instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );

  		if ( instanceCount === 0 ) return null;

  		drawParams.instanceCount = instanceCount;

  		if ( object.isBatchedMesh === true ) return drawParams;

  		let rangeFactor = 1;

  		if ( material.wireframe === true && ! object.isPoints && ! object.isLineSegments && ! object.isLine && ! object.isLineLoop ) {

  			rangeFactor = 2;

  		}

  		let firstVertex = drawRange.start * rangeFactor;
  		let lastVertex = ( drawRange.start + drawRange.count ) * rangeFactor;

  		if ( group !== null ) {

  			firstVertex = Math.max( firstVertex, group.start * rangeFactor );
  			lastVertex = Math.min( lastVertex, ( group.start + group.count ) * rangeFactor );

  		}

  		const itemCount = hasIndex === true ? index.count : geometry.attributes.position.count;

  		firstVertex = Math.max( firstVertex, 0 );
  		lastVertex = Math.min( lastVertex, itemCount );

  		const count = lastVertex - firstVertex;

  		if ( count < 0 || count === Infinity ) return null;

  		drawParams.vertexCount = count;
  		drawParams.firstVertex = firstVertex;

  		return drawParams;

  	}

  	getGeometryCacheKey() {

  		const { geometry } = this;

  		let cacheKey = '';

  		for ( const name of Object.keys( geometry.attributes ).sort() ) {

  			const attribute = geometry.attributes[ name ];

  			cacheKey += name + ',';

  			if ( attribute.data ) cacheKey += attribute.data.stride + ',';
  			if ( attribute.offset ) cacheKey += attribute.offset + ',';
  			if ( attribute.itemSize ) cacheKey += attribute.itemSize + ',';
  			if ( attribute.normalized ) cacheKey += 'n,';

  		}

  		if ( geometry.index ) {

  			cacheKey += 'index,';

  		}

  		return cacheKey;

  	}

  	getMaterialCacheKey() {

  		const { object, material } = this;

  		let cacheKey = material.customProgramCacheKey();

  		for ( const property of getKeys( material ) ) {

  			if ( /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test( property ) ) continue;

  			const value = material[ property ];

  			let valueKey;

  			if ( value !== null ) {

  				// some material values require a formatting

  				const type = typeof value;

  				if ( type === 'number' ) {

  					valueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc

  				} else if ( type === 'object' ) {

  					valueKey = '{';

  					if ( value.isTexture ) {

  						valueKey += value.mapping;

  					}

  					valueKey += '}';

  				} else {

  					valueKey = String( value );

  				}

  			} else {

  				valueKey = String( value );

  			}

  			cacheKey += /*property + ':' +*/ valueKey + ',';

  		}

  		cacheKey += this.clippingContext.cacheKey + ',';

  		if ( object.geometry ) {

  			cacheKey += this.getGeometryCacheKey();

  		}

  		if ( object.skeleton ) {

  			cacheKey += object.skeleton.bones.length + ',';

  		}

  		if ( object.morphTargetInfluences ) {

  			cacheKey += object.morphTargetInfluences.length + ',';

  		}

  		if ( object.isBatchedMesh ) {

  			cacheKey += object._matricesTexture.uuid + ',';

  			if ( object._colorsTexture !== null ) {

  				cacheKey += object._colorsTexture.uuid + ',';

  			}

  		}

  		if ( object.count > 1 ) {

  			// TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850

  			cacheKey += object.uuid + ',';

  		}

  		return hashString( cacheKey );

  	}

  	get needsUpdate() {

  		return /*this.object.static !== true &&*/ ( this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate );

  	}

  	getDynamicCacheKey() {

  		// Environment Nodes Cache Key

  		let cacheKey = this._nodes.getCacheKey( this.scene, this.lightsNode );

  		if ( this.object.receiveShadow ) {

  			cacheKey += 1;

  		}

  		return cacheKey;

  	}

  	getCacheKey() {

  		return this.getMaterialCacheKey() + this.getDynamicCacheKey();

  	}

  	dispose() {

  		this.material.removeEventListener( 'dispose', this.onMaterialDispose );

  		this.onDispose();

  	}

  }

  const chainArray = [];

  class RenderObjects {

  	constructor( renderer, nodes, geometries, pipelines, bindings, info ) {

  		this.renderer = renderer;
  		this.nodes = nodes;
  		this.geometries = geometries;
  		this.pipelines = pipelines;
  		this.bindings = bindings;
  		this.info = info;

  		this.chainMaps = {};

  	}

  	get( object, material, scene, camera, lightsNode, renderContext, passId ) {

  		const chainMap = this.getChainMap( passId );

  		// reuse chainArray
  		chainArray[ 0 ] = object;
  		chainArray[ 1 ] = material;
  		chainArray[ 2 ] = renderContext;
  		chainArray[ 3 ] = lightsNode;

  		let renderObject = chainMap.get( chainArray );

  		if ( renderObject === undefined ) {

  			renderObject = this.createRenderObject( this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, passId );

  			chainMap.set( chainArray, renderObject );

  		} else {

  			renderObject.updateClipping( renderContext.clippingContext );

  			if ( renderObject.version !== material.version || renderObject.needsUpdate ) {

  				if ( renderObject.initialCacheKey !== renderObject.getCacheKey() ) {

  					renderObject.dispose();

  					renderObject = this.get( object, material, scene, camera, lightsNode, renderContext, passId );

  				} else {

  					renderObject.version = material.version;

  				}

  			}

  		}

  		return renderObject;

  	}

  	getChainMap( passId = 'default' ) {

  		return this.chainMaps[ passId ] || ( this.chainMaps[ passId ] = new ChainMap() );

  	}

  	dispose() {

  		this.chainMaps = {};

  	}

  	createRenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, passId ) {

  		const chainMap = this.getChainMap( passId );

  		const renderObject = new RenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext );

  		renderObject.onDispose = () => {

  			this.pipelines.delete( renderObject );
  			this.bindings.delete( renderObject );
  			this.nodes.delete( renderObject );

  			chainMap.delete( renderObject.getChainArray() );

  		};

  		return renderObject;

  	}


  }

  class DataMap {

  	constructor() {

  		this.data = new WeakMap();

  	}

  	get( object ) {

  		let map = this.data.get( object );

  		if ( map === undefined ) {

  			map = {};
  			this.data.set( object, map );

  		}

  		return map;

  	}

  	delete( object ) {

  		let map;

  		if ( this.data.has( object ) ) {

  			map = this.data.get( object );

  			this.data.delete( object );

  		}

  		return map;

  	}

  	has( object ) {

  		return this.data.has( object );

  	}

  	dispose() {

  		this.data = new WeakMap();

  	}

  }

  const AttributeType = {
  	VERTEX: 1,
  	INDEX: 2,
  	STORAGE: 4
  };

  // size of a chunk in bytes (STD140 layout)

  const GPU_CHUNK_BYTES = 16;

  // @TODO: Move to src/constants.js

  const BlendColorFactor = 211;
  const OneMinusBlendColorFactor = 212;

  class Attributes extends DataMap {

  	constructor( backend ) {

  		super();

  		this.backend = backend;

  	}

  	delete( attribute ) {

  		const attributeData = super.delete( attribute );

  		if ( attributeData !== undefined ) {

  			this.backend.destroyAttribute( attribute );

  		}

  		return attributeData;

  	}

  	update( attribute, type ) {

  		const data = this.get( attribute );

  		if ( data.version === undefined ) {

  			if ( type === AttributeType.VERTEX ) {

  				this.backend.createAttribute( attribute );

  			} else if ( type === AttributeType.INDEX ) {

  				this.backend.createIndexAttribute( attribute );

  			} else if ( type === AttributeType.STORAGE ) {

  				this.backend.createStorageAttribute( attribute );

  			}

  			data.version = this._getBufferAttribute( attribute ).version;

  		} else {

  			const bufferAttribute = this._getBufferAttribute( attribute );

  			if ( data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage ) {

  				this.backend.updateAttribute( attribute );

  				data.version = bufferAttribute.version;

  			}

  		}

  	}

  	_getBufferAttribute( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		return attribute;

  	}

  }

  function arrayNeedsUint32( array ) {

  	// assumes larger values usually on last

  	for ( let i = array.length - 1; i >= 0; -- i ) {

  		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

  	}

  	return false;

  }

  function getWireframeVersion( geometry ) {

  	return ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;

  }

  function getWireframeIndex( geometry ) {

  	const indices = [];

  	const geometryIndex = geometry.index;
  	const geometryPosition = geometry.attributes.position;

  	if ( geometryIndex !== null ) {

  		const array = geometryIndex.array;

  		for ( let i = 0, l = array.length; i < l; i += 3 ) {

  			const a = array[ i + 0 ];
  			const b = array[ i + 1 ];
  			const c = array[ i + 2 ];

  			indices.push( a, b, b, c, c, a );

  		}

  	} else {

  		const array = geometryPosition.array;

  		for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

  			const a = i + 0;
  			const b = i + 1;
  			const c = i + 2;

  			indices.push( a, b, b, c, c, a );

  		}

  	}

  	const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
  	attribute.version = getWireframeVersion( geometry );

  	return attribute;

  }

  class Geometries extends DataMap {

  	constructor( attributes, info ) {

  		super();

  		this.attributes = attributes;
  		this.info = info;

  		this.wireframes = new WeakMap();

  		this.attributeCall = new WeakMap();

  	}

  	has( renderObject ) {

  		const geometry = renderObject.geometry;

  		return super.has( geometry ) && this.get( geometry ).initialized === true;

  	}

  	updateForRender( renderObject ) {

  		if ( this.has( renderObject ) === false ) this.initGeometry( renderObject );

  		this.updateAttributes( renderObject );

  	}

  	initGeometry( renderObject ) {

  		const geometry = renderObject.geometry;
  		const geometryData = this.get( geometry );

  		geometryData.initialized = true;

  		this.info.memory.geometries ++;

  		const onDispose = () => {

  			this.info.memory.geometries --;

  			const index = geometry.index;
  			const geometryAttributes = renderObject.getAttributes();

  			if ( index !== null ) {

  				this.attributes.delete( index );

  			}

  			for ( const geometryAttribute of geometryAttributes ) {

  				this.attributes.delete( geometryAttribute );

  			}

  			const wireframeAttribute = this.wireframes.get( geometry );

  			if ( wireframeAttribute !== undefined ) {

  				this.attributes.delete( wireframeAttribute );

  			}

  			geometry.removeEventListener( 'dispose', onDispose );

  		};

  		geometry.addEventListener( 'dispose', onDispose );

  	}

  	updateAttributes( renderObject ) {

  		const attributes = renderObject.getAttributes();

  		for ( const attribute of attributes ) {

  			if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {

  				this.updateAttribute( attribute, AttributeType.STORAGE );

  			} else {

  				this.updateAttribute( attribute, AttributeType.VERTEX );

  			}

  		}

  		const index = this.getIndex( renderObject );

  		if ( index !== null ) {

  			this.updateAttribute( index, AttributeType.INDEX );

  		}

  	}

  	updateAttribute( attribute, type ) {

  		const callId = this.info.render.calls;

  		if ( ! attribute.isInterleavedBufferAttribute ) {

  			if ( this.attributeCall.get( attribute ) !== callId ) {

  				this.attributes.update( attribute, type );

  				this.attributeCall.set( attribute, callId );

  			}

  		} else {

  			if ( this.attributeCall.get( attribute ) === undefined ) {

  				this.attributes.update( attribute, type );

  				this.attributeCall.set( attribute, callId );

  			} else if ( this.attributeCall.get( attribute.data ) !== callId ) {

  				this.attributes.update( attribute, type );

  				this.attributeCall.set( attribute.data, callId );

  				this.attributeCall.set( attribute, callId );

  			}

  		}

  	}

  	getIndex( renderObject ) {

  		const { geometry, material } = renderObject;

  		let index = geometry.index;

  		if ( material.wireframe === true ) {

  			const wireframes = this.wireframes;

  			let wireframeAttribute = wireframes.get( geometry );

  			if ( wireframeAttribute === undefined ) {

  				wireframeAttribute = getWireframeIndex( geometry );

  				wireframes.set( geometry, wireframeAttribute );

  			} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {

  				this.attributes.delete( wireframeAttribute );

  				wireframeAttribute = getWireframeIndex( geometry );

  				wireframes.set( geometry, wireframeAttribute );

  			}

  			index = wireframeAttribute;

  		}

  		return index;

  	}

  }

  class Info {

  	constructor() {

  		this.autoReset = true;

  		this.frame = 0;
  		this.calls = 0;

  		this.render = {
  			calls: 0,
  			frameCalls: 0,
  			drawCalls: 0,
  			triangles: 0,
  			points: 0,
  			lines: 0,
  			timestamp: 0,
  			previousFrameCalls: 0,
  			timestampCalls: 0
  		};

  		this.compute = {
  			calls: 0,
  			frameCalls: 0,
  			timestamp: 0,
  			previousFrameCalls: 0,
  			timestampCalls: 0
  		};

  		this.memory = {
  			geometries: 0,
  			textures: 0
  		};

  	}

  	update( object, count, instanceCount ) {

  		this.render.drawCalls ++;

  		if ( object.isMesh || object.isSprite ) {

  			this.render.triangles += instanceCount * ( count / 3 );

  		} else if ( object.isPoints ) {

  			this.render.points += instanceCount * count;

  		} else if ( object.isLineSegments ) {

  			this.render.lines += instanceCount * ( count / 2 );

  		} else if ( object.isLine ) {

  			this.render.lines += instanceCount * ( count - 1 );

  		} else {

  			console.error( 'THREE.WebGPUInfo: Unknown object type.' );

  		}

  	}

  	updateTimestamp( type, time ) {

  		if ( this[ type ].timestampCalls === 0 ) {

  			this[ type ].timestamp = 0;

  		}


  		this[ type ].timestamp += time;

  		this[ type ].timestampCalls ++;


  		if ( this[ type ].timestampCalls >= this[ type ].previousFrameCalls ) {

  			this[ type ].timestampCalls = 0;

  		}


  	}

  	reset() {

  		const previousRenderFrameCalls = this.render.frameCalls;
  		this.render.previousFrameCalls = previousRenderFrameCalls;

  		const previousComputeFrameCalls = this.compute.frameCalls;
  		this.compute.previousFrameCalls = previousComputeFrameCalls;


  		this.render.drawCalls = 0;
  		this.render.frameCalls = 0;
  		this.compute.frameCalls = 0;

  		this.render.triangles = 0;
  		this.render.points = 0;
  		this.render.lines = 0;


  	}

  	dispose() {

  		this.reset();

  		this.calls = 0;

  		this.render.calls = 0;
  		this.compute.calls = 0;

  		this.render.timestamp = 0;
  		this.compute.timestamp = 0;
  		this.memory.geometries = 0;
  		this.memory.textures = 0;

  	}

  }

  class Pipeline {

  	constructor( cacheKey ) {

  		this.cacheKey = cacheKey;

  		this.usedTimes = 0;

  	}

  }

  class RenderPipeline extends Pipeline {

  	constructor( cacheKey, vertexProgram, fragmentProgram ) {

  		super( cacheKey );

  		this.vertexProgram = vertexProgram;
  		this.fragmentProgram = fragmentProgram;

  	}

  }

  class ComputePipeline extends Pipeline {

  	constructor( cacheKey, computeProgram ) {

  		super( cacheKey );

  		this.computeProgram = computeProgram;

  		this.isComputePipeline = true;

  	}

  }

  let _id$6 = 0;

  class ProgrammableStage {

  	constructor( code, type, transforms = null, attributes = null ) {

  		this.id = _id$6 ++;

  		this.code = code;
  		this.stage = type;
  		this.transforms = transforms;
  		this.attributes = attributes;

  		this.usedTimes = 0;

  	}

  }

  class Pipelines extends DataMap {

  	constructor( backend, nodes ) {

  		super();

  		this.backend = backend;
  		this.nodes = nodes;

  		this.bindings = null; // set by the bindings

  		this.caches = new Map();
  		this.programs = {
  			vertex: new Map(),
  			fragment: new Map(),
  			compute: new Map()
  		};

  	}

  	getForCompute( computeNode, bindings ) {

  		const { backend } = this;

  		const data = this.get( computeNode );

  		if ( this._needsComputeUpdate( computeNode ) ) {

  			const previousPipeline = data.pipeline;

  			if ( previousPipeline ) {

  				previousPipeline.usedTimes --;
  				previousPipeline.computeProgram.usedTimes --;

  			}

  			// get shader

  			const nodeBuilderState = this.nodes.getForCompute( computeNode );

  			// programmable stage

  			let stageCompute = this.programs.compute.get( nodeBuilderState.computeShader );

  			if ( stageCompute === undefined ) {

  				if ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );

  				stageCompute = new ProgrammableStage( nodeBuilderState.computeShader, 'compute', nodeBuilderState.transforms, nodeBuilderState.nodeAttributes );
  				this.programs.compute.set( nodeBuilderState.computeShader, stageCompute );

  				backend.createProgram( stageCompute );

  			}

  			// determine compute pipeline

  			const cacheKey = this._getComputeCacheKey( computeNode, stageCompute );

  			let pipeline = this.caches.get( cacheKey );

  			if ( pipeline === undefined ) {

  				if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );

  				pipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );

  			}

  			// keep track of all used times

  			pipeline.usedTimes ++;
  			stageCompute.usedTimes ++;

  			//

  			data.version = computeNode.version;
  			data.pipeline = pipeline;

  		}

  		return data.pipeline;

  	}

  	getForRender( renderObject, promises = null ) {

  		const { backend } = this;

  		const data = this.get( renderObject );

  		if ( this._needsRenderUpdate( renderObject ) ) {

  			const previousPipeline = data.pipeline;

  			if ( previousPipeline ) {

  				previousPipeline.usedTimes --;
  				previousPipeline.vertexProgram.usedTimes --;
  				previousPipeline.fragmentProgram.usedTimes --;

  			}

  			// get shader

  			const nodeBuilderState = renderObject.getNodeBuilderState();

  			// programmable stages

  			let stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );

  			if ( stageVertex === undefined ) {

  				if ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );

  				stageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex' );
  				this.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );

  				backend.createProgram( stageVertex );

  			}

  			let stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );

  			if ( stageFragment === undefined ) {

  				if ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );

  				stageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment' );
  				this.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );

  				backend.createProgram( stageFragment );

  			}

  			// determine render pipeline

  			const cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

  			let pipeline = this.caches.get( cacheKey );

  			if ( pipeline === undefined ) {

  				if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );

  				pipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises );

  			} else {

  				renderObject.pipeline = pipeline;

  			}

  			// keep track of all used times

  			pipeline.usedTimes ++;
  			stageVertex.usedTimes ++;
  			stageFragment.usedTimes ++;

  			//

  			data.pipeline = pipeline;

  		}

  		return data.pipeline;

  	}

  	delete( object ) {

  		const pipeline = this.get( object ).pipeline;

  		if ( pipeline ) {

  			// pipeline

  			pipeline.usedTimes --;

  			if ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );

  			// programs

  			if ( pipeline.isComputePipeline ) {

  				pipeline.computeProgram.usedTimes --;

  				if ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );

  			} else {

  				pipeline.fragmentProgram.usedTimes --;
  				pipeline.vertexProgram.usedTimes --;

  				if ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );
  				if ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );

  			}

  		}

  		return super.delete( object );

  	}

  	dispose() {

  		super.dispose();

  		this.caches = new Map();
  		this.programs = {
  			vertex: new Map(),
  			fragment: new Map(),
  			compute: new Map()
  		};

  	}

  	updateForRender( renderObject ) {

  		this.getForRender( renderObject );

  	}

  	_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {

  		// check for existing pipeline

  		cacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );

  		let pipeline = this.caches.get( cacheKey );

  		if ( pipeline === undefined ) {

  			pipeline = new ComputePipeline( cacheKey, stageCompute );

  			this.caches.set( cacheKey, pipeline );

  			this.backend.createComputePipeline( pipeline, bindings );

  		}

  		return pipeline;

  	}

  	_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises ) {

  		// check for existing pipeline

  		cacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

  		let pipeline = this.caches.get( cacheKey );

  		if ( pipeline === undefined ) {

  			pipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );

  			this.caches.set( cacheKey, pipeline );

  			renderObject.pipeline = pipeline;

  			this.backend.createRenderPipeline( renderObject, promises );

  		}

  		return pipeline;

  	}

  	_getComputeCacheKey( computeNode, stageCompute ) {

  		return computeNode.id + ',' + stageCompute.id;

  	}

  	_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {

  		return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey( renderObject );

  	}

  	_releasePipeline( pipeline ) {

  		this.caches.delete( pipeline.cacheKey );

  	}

  	_releaseProgram( program ) {

  		const code = program.code;
  		const stage = program.stage;

  		this.programs[ stage ].delete( code );

  	}

  	_needsComputeUpdate( computeNode ) {

  		const data = this.get( computeNode );

  		return data.pipeline === undefined || data.version !== computeNode.version;

  	}

  	_needsRenderUpdate( renderObject ) {

  		const data = this.get( renderObject );

  		return data.pipeline === undefined || this.backend.needsRenderUpdate( renderObject );

  	}

  }

  class Bindings extends DataMap {

  	constructor( backend, nodes, textures, attributes, pipelines, info ) {

  		super();

  		this.backend = backend;
  		this.textures = textures;
  		this.pipelines = pipelines;
  		this.attributes = attributes;
  		this.nodes = nodes;
  		this.info = info;

  		this.pipelines.bindings = this; // assign bindings to pipelines

  	}

  	getForRender( renderObject ) {

  		const bindings = renderObject.getBindings();

  		for ( const bindGroup of bindings ) {

  			const groupData = this.get( bindGroup );

  			if ( groupData.bindGroup === undefined ) {

  				// each object defines an array of bindings (ubos, textures, samplers etc.)

  				this._init( bindGroup );

  				this.backend.createBindings( bindGroup, bindings );

  				groupData.bindGroup = bindGroup;

  			}

  		}

  		return bindings;

  	}

  	getForCompute( computeNode ) {

  		const bindings = this.nodes.getForCompute( computeNode ).bindings;

  		for ( const bindGroup of bindings ) {

  			const groupData = this.get( bindGroup );

  			if ( groupData.bindGroup === undefined ) {

  				this._init( bindGroup );

  				this.backend.createBindings( bindGroup, bindings );

  				groupData.bindGroup = bindGroup;

  			}

  		}

  		return bindings;

  	}

  	updateForCompute( computeNode ) {

  		this._updateBindings( this.getForCompute( computeNode ) );

  	}

  	updateForRender( renderObject ) {

  		this._updateBindings( this.getForRender( renderObject ) );

  	}

  	_updateBindings( bindings ) {

  		for ( const bindGroup of bindings ) {

  			this._update( bindGroup, bindings );

  		}

  	}

  	_init( bindGroup ) {

  		for ( const binding of bindGroup.bindings ) {

  			if ( binding.isSampledTexture ) {

  				this.textures.updateTexture( binding.texture );

  			} else if ( binding.isStorageBuffer ) {

  				const attribute = binding.attribute;

  				this.attributes.update( attribute, AttributeType.STORAGE );

  			}

  		}

  	}

  	_update( bindGroup, bindings ) {

  		const { backend } = this;

  		let needsBindingsUpdate = false;

  		// iterate over all bindings and check if buffer updates or a new binding group is required

  		for ( const binding of bindGroup.bindings ) {

  			if ( binding.isNodeUniformsGroup ) {

  				const updated = this.nodes.updateGroup( binding );

  				if ( ! updated ) continue;

  			}

  			if ( binding.isUniformBuffer ) {

  				const updated = binding.update();

  				if ( updated ) {

  					backend.updateBinding( binding );

  				}

  			} else if ( binding.isSampler ) {

  				binding.update();

  			} else if ( binding.isSampledTexture ) {

  				if ( binding.needsBindingsUpdate( this.textures.get( binding.texture ).generation ) ) needsBindingsUpdate = true;

  				const updated = binding.update();

  				const texture = binding.texture;

  				if ( updated ) {

  					this.textures.updateTexture( texture );

  				}

  				const textureData = backend.get( texture );

  				if ( backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined ) {

  					// TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend
  					console.error( 'Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate );

  					this.textures.updateTexture( texture );
  					needsBindingsUpdate = true;

  				}

  				if ( texture.isStorageTexture === true ) {

  					const textureData = this.get( texture );

  					if ( binding.store === true ) {

  						textureData.needsMipmap = true;

  					} else if ( texture.generateMipmaps === true && this.textures.needsMipmaps( texture ) && textureData.needsMipmap === true ) {

  						this.backend.generateMipmaps( texture );

  						textureData.needsMipmap = false;

  					}

  				}

  			}

  		}

  		if ( needsBindingsUpdate === true ) {

  			this.backend.updateBindings( bindGroup, bindings );

  		}

  	}

  }

  class NodeAttribute {

  	constructor( name, type, node = null ) {

  		this.isNodeAttribute = true;

  		this.name = name;
  		this.type = type;
  		this.node = node;

  	}

  }

  class NodeUniform {

  	constructor( name, type, node ) {

  		this.isNodeUniform = true;

  		this.name = name;
  		this.type = type;
  		this.node = node.getSelf();

  	}

  	get value() {

  		return this.node.value;

  	}

  	set value( val ) {

  		this.node.value = val;

  	}

  	get id() {

  		return this.node.id;

  	}

  	get groupNode() {

  		return this.node.groupNode;

  	}

  }

  class NodeVar {

  	constructor( name, type ) {

  		this.isNodeVar = true;

  		this.name = name;
  		this.type = type;

  	}

  }

  class NodeVarying extends NodeVar {

  	constructor( name, type ) {

  		super( name, type );

  		this.needsInterpolation = false;

  		this.isNodeVarying = true;

  	}

  }

  class NodeCode {

  	constructor( name, type, code = '' ) {

  		this.name = name;
  		this.type = type;
  		this.code = code;

  		Object.defineProperty( this, 'isNodeCode', { value: true } );

  	}

  }

  let id$1 = 0;

  class NodeCache {

  	constructor( parent = null ) {

  		this.id = id$1 ++;
  		this.nodesData = new WeakMap();

  		this.parent = parent;

  	}

  	getData( node ) {

  		let data = this.nodesData.get( node );

  		if ( data === undefined && this.parent !== null ) {

  			data = this.parent.getData( node );

  		}

  		return data;

  	}

  	setData( node, data ) {

  		this.nodesData.set( node, data );

  	}

  }

  class ParameterNode extends PropertyNode {

  	static get type() {

  		return 'ParameterNode';

  	}

  	constructor( nodeType, name = null ) {

  		super( nodeType, name );

  		this.isParameterNode = true;

  	}

  	getHash() {

  		return this.uuid;

  	}

  	generate() {

  		return this.name;

  	}

  }

  class CodeNode extends Node {

  	static get type() {

  		return 'CodeNode';

  	}

  	constructor( code = '', includes = [], language = '' ) {

  		super( 'code' );

  		this.isCodeNode = true;

  		this.code = code;
  		this.language = language;

  		this.includes = includes;

  	}

  	isGlobal() {

  		return true;

  	}

  	setIncludes( includes ) {

  		this.includes = includes;

  		return this;

  	}

  	getIncludes( /*builder*/ ) {

  		return this.includes;

  	}

  	generate( builder ) {

  		const includes = this.getIncludes( builder );

  		for ( const include of includes ) {

  			include.build( builder );

  		}

  		const nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );
  		nodeCode.code = this.code;

  		return nodeCode.code;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.code = this.code;
  		data.language = this.language;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.code = data.code;
  		this.language = data.language;

  	}

  }

  class FunctionNode extends CodeNode {

  	static get type() {

  		return 'FunctionNode';

  	}

  	constructor( code = '', includes = [], language = '' ) {

  		super( code, includes, language );

  	}

  	getNodeType( builder ) {

  		return this.getNodeFunction( builder ).type;

  	}

  	getInputs( builder ) {

  		return this.getNodeFunction( builder ).inputs;

  	}

  	getNodeFunction( builder ) {

  		const nodeData = builder.getDataFromNode( this );

  		let nodeFunction = nodeData.nodeFunction;

  		if ( nodeFunction === undefined ) {

  			nodeFunction = builder.parser.parseFunction( this.code );

  			nodeData.nodeFunction = nodeFunction;

  		}

  		return nodeFunction;

  	}

  	generate( builder, output ) {

  		super.generate( builder );

  		const nodeFunction = this.getNodeFunction( builder );

  		const name = nodeFunction.name;
  		const type = nodeFunction.type;

  		const nodeCode = builder.getCodeFromNode( this, type );

  		if ( name !== '' ) {

  			// use a custom property name

  			nodeCode.name = name;

  		}

  		const propertyName = builder.getPropertyName( nodeCode );

  		const code = this.getNodeFunction( builder ).getCode( propertyName );

  		nodeCode.code = code + '\n';

  		if ( output === 'property' ) {

  			return propertyName;

  		} else {

  			return builder.format( `${ propertyName }()`, type, output );

  		}

  	}

  }

  class Uniform {

  	constructor( name, value ) {

  		this.name = name;
  		this.value = value;

  		this.boundary = 0; // used to build the uniform buffer according to the STD140 layout
  		this.itemSize = 0;

  		this.offset = 0; // this property is set by WebGPUUniformsGroup and marks the start position in the uniform buffer

  	}

  	setValue( value ) {

  		this.value = value;

  	}

  	getValue() {

  		return this.value;

  	}

  }

  class NumberUniform extends Uniform {

  	constructor( name, value = 0 ) {

  		super( name, value );

  		this.isNumberUniform = true;

  		this.boundary = 4;
  		this.itemSize = 1;

  	}

  }

  class Vector2Uniform extends Uniform {

  	constructor( name, value = new Vector2() ) {

  		super( name, value );

  		this.isVector2Uniform = true;

  		this.boundary = 8;
  		this.itemSize = 2;

  	}

  }

  class Vector3Uniform extends Uniform {

  	constructor( name, value = new Vector3() ) {

  		super( name, value );

  		this.isVector3Uniform = true;

  		this.boundary = 16;
  		this.itemSize = 3;

  	}

  }

  class Vector4Uniform extends Uniform {

  	constructor( name, value = new Vector4() ) {

  		super( name, value );

  		this.isVector4Uniform = true;

  		this.boundary = 16;
  		this.itemSize = 4;

  	}

  }

  class ColorUniform extends Uniform {

  	constructor( name, value = new Color() ) {

  		super( name, value );

  		this.isColorUniform = true;

  		this.boundary = 16;
  		this.itemSize = 3;

  	}

  }

  class Matrix3Uniform extends Uniform {

  	constructor( name, value = new Matrix3() ) {

  		super( name, value );

  		this.isMatrix3Uniform = true;

  		this.boundary = 48;
  		this.itemSize = 12;

  	}

  }

  class Matrix4Uniform extends Uniform {

  	constructor( name, value = new Matrix4() ) {

  		super( name, value );

  		this.isMatrix4Uniform = true;

  		this.boundary = 64;
  		this.itemSize = 16;

  	}

  }

  class NumberNodeUniform extends NumberUniform {

  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		this.nodeUniform = nodeUniform;

  	}

  	getValue() {

  		return this.nodeUniform.value;

  	}

  }

  class Vector2NodeUniform extends Vector2Uniform {

  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		this.nodeUniform = nodeUniform;

  	}

  	getValue() {

  		return this.nodeUniform.value;

  	}

  }

  class Vector3NodeUniform extends Vector3Uniform {

  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		this.nodeUniform = nodeUniform;

  	}

  	getValue() {

  		return this.nodeUniform.value;

  	}

  }

  class Vector4NodeUniform extends Vector4Uniform {

  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		this.nodeUniform = nodeUniform;

  	}

  	getValue() {

  		return this.nodeUniform.value;

  	}

  }

  class ColorNodeUniform extends ColorUniform {

  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		this.nodeUniform = nodeUniform;

  	}

  	getValue() {

  		return this.nodeUniform.value;

  	}

  }

  class Matrix3NodeUniform extends Matrix3Uniform {

  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		this.nodeUniform = nodeUniform;

  	}

  	getValue() {

  		return this.nodeUniform.value;

  	}

  }

  class Matrix4NodeUniform extends Matrix4Uniform {

  	constructor( nodeUniform ) {

  		super( nodeUniform.name, nodeUniform.value );

  		this.nodeUniform = nodeUniform;

  	}

  	getValue() {

  		return this.nodeUniform.value;

  	}

  }

  class StackNode extends Node {

  	static get type() {

  		return 'StackNode';

  	}

  	constructor( parent = null ) {

  		super();

  		this.nodes = [];
  		this.outputNode = null;

  		this.parent = parent;

  		this._currentCond = null;

  		this.isStackNode = true;

  	}

  	getNodeType( builder ) {

  		return this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';

  	}

  	add( node ) {

  		this.nodes.push( node );

  		return this;

  	}

  	If( boolNode, method ) {

  		const methodNode = new ShaderNode( method );
  		this._currentCond = select( boolNode, methodNode );

  		return this.add( this._currentCond );

  	}

  	ElseIf( boolNode, method ) {

  		const methodNode = new ShaderNode( method );
  		const ifNode = select( boolNode, methodNode );

  		this._currentCond.elseNode = ifNode;
  		this._currentCond = ifNode;

  		return this;

  	}

  	Else( method ) {

  		this._currentCond.elseNode = new ShaderNode( method );

  		return this;

  	}

  	build( builder, ...params ) {

  		const previousStack = getCurrentStack();

  		setCurrentStack( this );

  		for ( const node of this.nodes ) {

  			node.build( builder, 'void' );

  		}

  		setCurrentStack( previousStack );

  		return this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );

  	}

  	//

  	else( ...params ) { // @deprecated, r168

  		console.warn( 'TSL.StackNode: .else() has been renamed to .Else().' );
  		return this.Else( ...params );

  	}

  	elseif( ...params ) { // @deprecated, r168

  		console.warn( 'TSL.StackNode: .elseif() has been renamed to .ElseIf().' );
  		return this.ElseIf( ...params );

  	}

  }

  const stack = /*@__PURE__*/ nodeProxy( StackNode );

  const LOD_MIN = 4;

  // The standard deviations (radians) associated with the extra mips. These are
  // chosen to approximate a Trowbridge-Reitz distribution function times the
  // geometric shadowing function. These sigma values squared must match the
  // variance #defines in cube_uv_reflection_fragment.glsl.js.
  const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

  // The maximum length of the blur for loop. Smaller sigmas will use fewer
  // samples and exit early, but not recompile the shader.
  const MAX_SAMPLES = 20;

  const _flatCamera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  const _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );
  const _clearColor$2 = /*@__PURE__*/ new Color();
  let _oldTarget = null;
  let _oldActiveCubeFace = 0;
  let _oldActiveMipmapLevel = 0;

  // Golden Ratio
  const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
  const INV_PHI = 1 / PHI;

  // Vertices of a dodecahedron (except the opposites, which represent the
  // same axis), used as axis directions evenly spread on a sphere.
  const _axisDirections = [
  	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),
  	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
  	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
  	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
  	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
  	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
  	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
  	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
  	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
  	/*@__PURE__*/ new Vector3( 1, 1, 1 )
  ];

  //

  // WebGPU Face indices
  const _faceLib = [
  	3, 1, 5,
  	0, 4, 2
  ];

  const direction = getDirection( uv(), attribute( 'faceIndex' ) ).normalize();
  const outputDirection = vec3( direction.x, direction.y.negate(), direction.z );

  /**
   * This class generates a Prefiltered, Mipmapped Radiance Environment Map
   * (PMREM) from a cubeMap environment texture. This allows different levels of
   * blur to be quickly accessed based on material roughness. It is packed into a
   * special CubeUV format that allows us to perform custom interpolation so that
   * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
   * chain, it only goes down to the LOD_MIN level (above), and then creates extra
   * even more filtered 'mips' at the same LOD_MIN resolution, associated with
   * higher roughness levels. In this way we maintain resolution to smoothly
   * interpolate diffuse lighting while limiting sampling computation.
   *
   * Paper: Fast, Accurate Image-Based Lighting
   * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
  */

  class PMREMGenerator {

  	constructor( renderer ) {

  		this._renderer = renderer;
  		this._pingPongRenderTarget = null;

  		this._lodMax = 0;
  		this._cubeSize = 0;
  		this._lodPlanes = [];
  		this._sizeLods = [];
  		this._sigmas = [];
  		this._lodMeshes = [];

  		this._blurMaterial = null;
  		this._cubemapMaterial = null;
  		this._equirectMaterial = null;
  		this._backgroundBox = null;

  	}

  	/**
  	 * Generates a PMREM from a supplied Scene, which can be faster than using an
  	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
  	 * in radians to be applied to the scene before PMREM generation. Optional near
  	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
  	 * is placed at the origin).
  	 */
  	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

  		_oldTarget = this._renderer.getRenderTarget();
  		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
  		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();

  		this._setSize( 256 );

  		const cubeUVRenderTarget = this._allocateTargets();
  		cubeUVRenderTarget.depthBuffer = true;

  		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

  		if ( sigma > 0 ) {

  			this._blur( cubeUVRenderTarget, 0, 0, sigma );

  		}

  		this._applyPMREM( cubeUVRenderTarget );

  		this._cleanup( cubeUVRenderTarget );

  		return cubeUVRenderTarget;

  	}

  	/**
  	 * Generates a PMREM from an equirectangular texture, which can be either LDR
  	 * or HDR. The ideal input image size is 1k (1024 x 512),
  	 * as this matches best with the 256 x 256 cubemap output.
  	 */
  	fromEquirectangular( equirectangular, renderTarget = null ) {

  		return this._fromTexture( equirectangular, renderTarget );

  	}

  	/**
  	 * Generates a PMREM from an cubemap texture, which can be either LDR
  	 * or HDR. The ideal input cube size is 256 x 256,
  	 * as this matches best with the 256 x 256 cubemap output.
  	 */
  	fromCubemap( cubemap, renderTarget = null ) {

  		return this._fromTexture( cubemap, renderTarget );

  	}

  	/**
  	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */
  	async compileCubemapShader() {

  		if ( this._cubemapMaterial === null ) {

  			this._cubemapMaterial = _getCubemapMaterial();
  			await this._compileMaterial( this._cubemapMaterial );

  		}

  	}

  	/**
  	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */
  	async compileEquirectangularShader() {

  		if ( this._equirectMaterial === null ) {

  			this._equirectMaterial = _getEquirectMaterial();
  			await this._compileMaterial( this._equirectMaterial );

  		}

  	}

  	/**
  	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
  	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
  	 * one of them will cause any others to also become unusable.
  	 */
  	dispose() {

  		this._dispose();

  		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
  		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();
  		if ( this._backgroundBox !== null ) {

  			this._backgroundBox.geometry.dispose();
  			this._backgroundBox.material.dispose();

  		}

  	}

  	// private interface

  	_setSize( cubeSize ) {

  		this._lodMax = Math.floor( Math.log2( cubeSize ) );
  		this._cubeSize = Math.pow( 2, this._lodMax );

  	}

  	_dispose() {

  		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

  		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

  		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

  			this._lodPlanes[ i ].dispose();

  		}

  	}

  	_cleanup( outputTarget ) {

  		this._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );
  		outputTarget.scissorTest = false;
  		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

  	}

  	_fromTexture( texture, renderTarget ) {

  		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

  			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

  		} else { // Equirectangular

  			this._setSize( texture.image.width / 4 );

  		}

  		_oldTarget = this._renderer.getRenderTarget();
  		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
  		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();

  		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
  		this._textureToCubeUV( texture, cubeUVRenderTarget );
  		this._applyPMREM( cubeUVRenderTarget );
  		this._cleanup( cubeUVRenderTarget );

  		return cubeUVRenderTarget;

  	}

  	_allocateTargets() {

  		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
  		const height = 4 * this._cubeSize;

  		const params = {
  			magFilter: LinearFilter,
  			minFilter: LinearFilter,
  			generateMipmaps: false,
  			type: HalfFloatType,
  			format: RGBAFormat,
  			colorSpace: LinearSRGBColorSpace,
  			//depthBuffer: false
  		};

  		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

  		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

  			if ( this._pingPongRenderTarget !== null ) {

  				this._dispose();

  			}

  			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

  			const { _lodMax } = this;
  			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes( _lodMax ) );

  			this._blurMaterial = _getBlurShader( _lodMax, width, height );

  		}

  		return cubeUVRenderTarget;

  	}

  	async _compileMaterial( material ) {

  		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
  		await this._renderer.compile( tmpMesh, _flatCamera );

  	}

  	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

  		const cubeCamera = _cubeCamera;
  		cubeCamera.near = near;
  		cubeCamera.far = far;

  		// px, py, pz, nx, ny, nz
  		const upSign = [ - 1, 1, - 1, - 1, - 1, - 1 ];
  		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];

  		const renderer = this._renderer;

  		const originalAutoClear = renderer.autoClear;

  		renderer.getClearColor( _clearColor$2 );

  		renderer.autoClear = false;

  		let backgroundBox = this._backgroundBox;

  		if ( backgroundBox === null ) {

  			const backgroundMaterial = new MeshBasicMaterial( {
  				name: 'PMREM.Background',
  				side: BackSide,
  				depthWrite: false,
  				depthTest: false
  			} );

  			backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

  		}

  		let useSolidColor = false;
  		const background = scene.background;

  		if ( background ) {

  			if ( background.isColor ) {

  				backgroundBox.material.color.copy( background );
  				scene.background = null;
  				useSolidColor = true;

  			}

  		} else {

  			backgroundBox.material.color.copy( _clearColor$2 );
  			useSolidColor = true;

  		}

  		renderer.setRenderTarget( cubeUVRenderTarget );

  		renderer.clear();

  		if ( useSolidColor ) {

  			renderer.render( backgroundBox, cubeCamera );

  		}

  		for ( let i = 0; i < 6; i ++ ) {

  			const col = i % 3;

  			if ( col === 0 ) {

  				cubeCamera.up.set( 0, upSign[ i ], 0 );
  				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

  			} else if ( col === 1 ) {

  				cubeCamera.up.set( 0, 0, upSign[ i ] );
  				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

  			} else {

  				cubeCamera.up.set( 0, upSign[ i ], 0 );
  				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

  			}

  			const size = this._cubeSize;

  			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

  			renderer.render( scene, cubeCamera );

  		}

  		renderer.autoClear = originalAutoClear;
  		scene.background = background;

  	}

  	_textureToCubeUV( texture, cubeUVRenderTarget ) {

  		const renderer = this._renderer;

  		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

  		if ( isCubeTexture ) {

  			if ( this._cubemapMaterial === null ) {

  				this._cubemapMaterial = _getCubemapMaterial( texture );

  			}

  		} else {

  			if ( this._equirectMaterial === null ) {

  				this._equirectMaterial = _getEquirectMaterial( texture );

  			}

  		}

  		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
  		material.fragmentNode.value = texture;

  		const mesh = this._lodMeshes[ 0 ];
  		mesh.material = material;

  		const size = this._cubeSize;

  		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

  		renderer.setRenderTarget( cubeUVRenderTarget );
  		renderer.render( mesh, _flatCamera );

  	}

  	_applyPMREM( cubeUVRenderTarget ) {

  		const renderer = this._renderer;
  		const autoClear = renderer.autoClear;
  		renderer.autoClear = false;
  		const n = this._lodPlanes.length;

  		for ( let i = 1; i < n; i ++ ) {

  			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

  			const poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];

  			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

  		}

  		renderer.autoClear = autoClear;

  	}

  	/**
  	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
  	 * vertically and horizontally, but this breaks down on a cube. Here we apply
  	 * the blur latitudinally (around the poles), and then longitudinally (towards
  	 * the poles) to approximate the orthogonally-separable blur. It is least
  	 * accurate at the poles, but still does a decent job.
  	 */
  	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

  		const pingPongRenderTarget = this._pingPongRenderTarget;

  		this._halfBlur(
  			cubeUVRenderTarget,
  			pingPongRenderTarget,
  			lodIn,
  			lodOut,
  			sigma,
  			'latitudinal',
  			poleAxis );

  		this._halfBlur(
  			pingPongRenderTarget,
  			cubeUVRenderTarget,
  			lodOut,
  			lodOut,
  			sigma,
  			'longitudinal',
  			poleAxis );

  	}

  	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

  		const renderer = this._renderer;
  		const blurMaterial = this._blurMaterial;

  		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

  			console.error( 'blur direction must be either latitudinal or longitudinal!' );

  		}

  		// Number of standard deviations at which to cut off the discrete approximation.
  		const STANDARD_DEVIATIONS = 3;

  		const blurMesh = this._lodMeshes[ lodOut ];
  		blurMesh.material = blurMaterial;

  		const blurUniforms = blurMaterial.uniforms;

  		const pixels = this._sizeLods[ lodIn ] - 1;
  		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
  		const sigmaPixels = sigmaRadians / radiansPerPixel;
  		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

  		if ( samples > MAX_SAMPLES ) {

  			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

  		}

  		const weights = [];
  		let sum = 0;

  		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

  			const x = i / sigmaPixels;
  			const weight = Math.exp( - x * x / 2 );
  			weights.push( weight );

  			if ( i === 0 ) {

  				sum += weight;

  			} else if ( i < samples ) {

  				sum += 2 * weight;

  			}

  		}

  		for ( let i = 0; i < weights.length; i ++ ) {

  			weights[ i ] = weights[ i ] / sum;

  		}

  		targetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;

  		blurUniforms.envMap.value = targetIn.texture;
  		blurUniforms.samples.value = samples;
  		blurUniforms.weights.array = weights;
  		blurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;

  		if ( poleAxis ) {

  			blurUniforms.poleAxis.value = poleAxis;

  		}

  		const { _lodMax } = this;
  		blurUniforms.dTheta.value = radiansPerPixel;
  		blurUniforms.mipInt.value = _lodMax - lodIn;

  		const outputSize = this._sizeLods[ lodOut ];
  		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
  		const y = 4 * ( this._cubeSize - outputSize );

  		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
  		renderer.setRenderTarget( targetOut );
  		renderer.render( blurMesh, _flatCamera );

  	}

  }

  function _createPlanes( lodMax ) {

  	const lodPlanes = [];
  	const sizeLods = [];
  	const sigmas = [];
  	const lodMeshes = [];

  	let lod = lodMax;

  	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

  	for ( let i = 0; i < totalLods; i ++ ) {

  		const sizeLod = Math.pow( 2, lod );
  		sizeLods.push( sizeLod );
  		let sigma = 1.0 / sizeLod;

  		if ( i > lodMax - LOD_MIN ) {

  			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

  		} else if ( i === 0 ) {

  			sigma = 0;

  		}

  		sigmas.push( sigma );

  		const texelSize = 1.0 / ( sizeLod - 2 );
  		const min = - texelSize;
  		const max = 1 + texelSize;
  		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

  		const cubeFaces = 6;
  		const vertices = 6;
  		const positionSize = 3;
  		const uvSize = 2;
  		const faceIndexSize = 1;

  		const position = new Float32Array( positionSize * vertices * cubeFaces );
  		const uv = new Float32Array( uvSize * vertices * cubeFaces );
  		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

  		for ( let face = 0; face < cubeFaces; face ++ ) {

  			const x = ( face % 3 ) * 2 / 3 - 1;
  			const y = face > 2 ? 0 : - 1;
  			const coordinates = [
  				x, y, 0,
  				x + 2 / 3, y, 0,
  				x + 2 / 3, y + 1, 0,
  				x, y, 0,
  				x + 2 / 3, y + 1, 0,
  				x, y + 1, 0
  			];

  			const faceIdx = _faceLib[ face ];
  			position.set( coordinates, positionSize * vertices * faceIdx );
  			uv.set( uv1, uvSize * vertices * faceIdx );
  			const fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];
  			faceIndex.set( fill, faceIndexSize * vertices * faceIdx );

  		}

  		const planes = new BufferGeometry();
  		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
  		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
  		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
  		lodPlanes.push( planes );
  		lodMeshes.push( new Mesh( planes, null ) );

  		if ( lod > LOD_MIN ) {

  			lod --;

  		}

  	}

  	return { lodPlanes, sizeLods, sigmas, lodMeshes };

  }

  function _createRenderTarget( width, height, params ) {

  	const cubeUVRenderTarget = new RenderTarget( width, height, params );
  	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
  	cubeUVRenderTarget.texture.isPMREMTexture = true;
  	cubeUVRenderTarget.scissorTest = true;
  	return cubeUVRenderTarget;

  }

  function _setViewport( target, x, y, width, height ) {

  	target.viewport.set( x, y, width, height );
  	target.scissor.set( x, y, width, height );

  }

  function _getMaterial( type ) {

  	const material = new NodeMaterial();
  	material.depthTest = false;
  	material.depthWrite = false;
  	material.blending = NoBlending;
  	material.name = `PMREM_${ type }`;

  	return material;

  }

  function _getBlurShader( lodMax, width, height ) {

  	const weights = uniformArray( new Array( MAX_SAMPLES ).fill( 0 ) );
  	const poleAxis = uniform( new Vector3( 0, 1, 0 ) );
  	const dTheta = uniform( 0 );
  	const n = float( MAX_SAMPLES );
  	const latitudinal = uniform( 0 ); // false, bool
  	const samples = uniform( 1 ); // int
  	const envMap = texture( null );
  	const mipInt = uniform( 0 ); // int
  	const CUBEUV_TEXEL_WIDTH = float( 1 / width );
  	const CUBEUV_TEXEL_HEIGHT = float( 1 / height );
  	const CUBEUV_MAX_MIP = float( lodMax );

  	const materialUniforms = {
  		n,
  		latitudinal,
  		weights,
  		poleAxis,
  		outputDirection,
  		dTheta,
  		samples,
  		envMap,
  		mipInt,
  		CUBEUV_TEXEL_WIDTH,
  		CUBEUV_TEXEL_HEIGHT,
  		CUBEUV_MAX_MIP
  	};

  	const material = _getMaterial( 'blur' );
  	material.uniforms = materialUniforms; // TODO: Move to outside of the material
  	material.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );

  	return material;

  }

  function _getCubemapMaterial( envTexture ) {

  	const material = _getMaterial( 'cubemap' );
  	material.fragmentNode = cubeTexture( envTexture, outputDirection );

  	return material;

  }

  function _getEquirectMaterial( envTexture ) {

  	const material = _getMaterial( 'equirect' );
  	material.fragmentNode = texture( envTexture, equirectUV( outputDirection ), 0 );

  	return material;

  }

  let _id$5 = 0;

  class BindGroup {

  	constructor( name = '', bindings = [], index = 0, bindingsReference = [] ) {

  		this.name = name;
  		this.bindings = bindings;
  		this.index = index;
  		this.bindingsReference = bindingsReference;

  		this.id = _id$5 ++;

  	}

  }

  const rendererCache = new WeakMap();

  const typeFromLength = new Map( [
  	[ 2, 'vec2' ],
  	[ 3, 'vec3' ],
  	[ 4, 'vec4' ],
  	[ 9, 'mat3' ],
  	[ 16, 'mat4' ]
  ] );

  const typeFromArray = new Map( [
  	[ Int8Array, 'int' ],
  	[ Int16Array, 'int' ],
  	[ Int32Array, 'int' ],
  	[ Uint8Array, 'uint' ],
  	[ Uint16Array, 'uint' ],
  	[ Uint32Array, 'uint' ],
  	[ Float32Array, 'float' ]
  ] );

  const toFloat = ( value ) => {

  	value = Number( value );

  	return value + ( value % 1 ? '' : '.0' );

  };

  class NodeBuilder {

  	constructor( object, renderer, parser ) {

  		this.object = object;
  		this.material = ( object && object.material ) || null;
  		this.geometry = ( object && object.geometry ) || null;
  		this.renderer = renderer;
  		this.parser = parser;
  		this.scene = null;
  		this.camera = null;

  		this.nodes = [];
  		this.updateNodes = [];
  		this.updateBeforeNodes = [];
  		this.updateAfterNodes = [];
  		this.hashNodes = {};

  		this.monitor = null;

  		this.lightsNode = null;
  		this.environmentNode = null;
  		this.fogNode = null;

  		this.clippingContext = null;

  		this.vertexShader = null;
  		this.fragmentShader = null;
  		this.computeShader = null;

  		this.flowNodes = { vertex: [], fragment: [], compute: [] };
  		this.flowCode = { vertex: '', fragment: '', compute: '' };
  		this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
  		this.structs = { vertex: [], fragment: [], compute: [], index: 0 };
  		this.bindings = { vertex: {}, fragment: {}, compute: {} };
  		this.bindingsIndexes = {};
  		this.bindGroups = null;
  		this.attributes = [];
  		this.bufferAttributes = [];
  		this.varyings = [];
  		this.codes = {};
  		this.vars = {};
  		this.flow = { code: '' };
  		this.chaining = [];
  		this.stack = stack();
  		this.stacks = [];
  		this.tab = '\t';

  		this.currentFunctionNode = null;

  		this.context = {
  			material: this.material
  		};

  		this.cache = new NodeCache();
  		this.globalCache = this.cache;

  		this.flowsData = new WeakMap();

  		this.shaderStage = null;
  		this.buildStage = null;

  		this.useComparisonMethod = false;

  	}

  	getBindGroupsCache() {

  		let bindGroupsCache = rendererCache.get( this.renderer );

  		if ( bindGroupsCache === undefined ) {

  			bindGroupsCache = new ChainMap();

  			rendererCache.set( this.renderer, bindGroupsCache );

  		}

  		return bindGroupsCache;

  	}

  	createRenderTarget( width, height, options ) {

  		return new RenderTarget( width, height, options );

  	}

  	createCubeRenderTarget( size, options ) {

  		return new CubeRenderTarget( size, options );

  	}

  	createPMREMGenerator() {

  		// TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support

  		return new PMREMGenerator( this.renderer );

  	}

  	includes( node ) {

  		return this.nodes.includes( node );

  	}

  	_getBindGroup( groupName, bindings ) {

  		const bindGroupsCache = this.getBindGroupsCache();

  		//

  		const bindingsArray = [];

  		let sharedGroup = true;

  		for ( const binding of bindings ) {

  			bindingsArray.push( binding );

  			sharedGroup = sharedGroup && binding.groupNode.shared !== true;

  		}

  		//

  		let bindGroup;

  		if ( sharedGroup ) {

  			bindGroup = bindGroupsCache.get( bindingsArray );

  			if ( bindGroup === undefined ) {

  				bindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );

  				bindGroupsCache.set( bindingsArray, bindGroup );

  			}

  		} else {

  			bindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );

  		}

  		return bindGroup;

  	}

  	getBindGroupArray( groupName, shaderStage ) {

  		const bindings = this.bindings[ shaderStage ];

  		let bindGroup = bindings[ groupName ];

  		if ( bindGroup === undefined ) {

  			if ( this.bindingsIndexes[ groupName ] === undefined ) {

  				this.bindingsIndexes[ groupName ] = { binding: 0, group: Object.keys( this.bindingsIndexes ).length };

  			}

  			bindings[ groupName ] = bindGroup = [];

  		}

  		return bindGroup;

  	}

  	getBindings() {

  		let bindingsGroups = this.bindGroups;

  		if ( bindingsGroups === null ) {

  			const groups = {};
  			const bindings = this.bindings;

  			for ( const shaderStage of shaderStages ) {

  				for ( const groupName in bindings[ shaderStage ] ) {

  					const uniforms = bindings[ shaderStage ][ groupName ];

  					const groupUniforms = groups[ groupName ] || ( groups[ groupName ] = [] );
  					groupUniforms.push( ...uniforms );

  				}

  			}

  			bindingsGroups = [];

  			for ( const groupName in groups ) {

  				const group = groups[ groupName ];

  				const bindingsGroup = this._getBindGroup( groupName, group );

  				bindingsGroups.push( bindingsGroup );

  			}

  			this.bindGroups = bindingsGroups;

  		}

  		return bindingsGroups;

  	}

  	sortBindingGroups() {

  		const bindingsGroups = this.getBindings();

  		bindingsGroups.sort( ( a, b ) => ( a.bindings[ 0 ].groupNode.order - b.bindings[ 0 ].groupNode.order ) );

  		for ( let i = 0; i < bindingsGroups.length; i ++ ) {

  			const bindingGroup = bindingsGroups[ i ];
  			this.bindingsIndexes[ bindingGroup.name ].group = i;

  			bindingGroup.index = i;

  		}

  	}

  	setHashNode( node, hash ) {

  		this.hashNodes[ hash ] = node;

  	}

  	addNode( node ) {

  		if ( this.nodes.includes( node ) === false ) {

  			this.nodes.push( node );

  			this.setHashNode( node, node.getHash( this ) );

  		}

  	}

  	buildUpdateNodes() {

  		for ( const node of this.nodes ) {

  			const updateType = node.getUpdateType();
  			const updateBeforeType = node.getUpdateBeforeType();
  			const updateAfterType = node.getUpdateAfterType();

  			if ( updateType !== NodeUpdateType.NONE ) {

  				this.updateNodes.push( node.getSelf() );

  			}

  			if ( updateBeforeType !== NodeUpdateType.NONE ) {

  				this.updateBeforeNodes.push( node.getSelf() );

  			}

  			if ( updateAfterType !== NodeUpdateType.NONE ) {

  				this.updateAfterNodes.push( node.getSelf() );

  			}

  		}

  	}

  	get currentNode() {

  		return this.chaining[ this.chaining.length - 1 ];

  	}

  	isFilteredTexture( texture ) {

  		return ( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
  			texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter );

  	}

  	addChain( node ) {

  		/*
  		if ( this.chaining.indexOf( node ) !== - 1 ) {

  			console.warn( 'Recursive node: ', node );

  		}
  		*/

  		this.chaining.push( node );

  	}

  	removeChain( node ) {

  		const lastChain = this.chaining.pop();

  		if ( lastChain !== node ) {

  			throw new Error( 'NodeBuilder: Invalid node chaining!' );

  		}

  	}

  	getMethod( method ) {

  		return method;

  	}

  	getNodeFromHash( hash ) {

  		return this.hashNodes[ hash ];

  	}

  	addFlow( shaderStage, node ) {

  		this.flowNodes[ shaderStage ].push( node );

  		return node;

  	}

  	setContext( context ) {

  		this.context = context;

  	}

  	getContext() {

  		return this.context;

  	}

  	getSharedContext() {

  		({ ...this.context });

  		return this.context;

  	}

  	setCache( cache ) {

  		this.cache = cache;

  	}

  	getCache() {

  		return this.cache;

  	}

  	getCacheFromNode( node, parent = true ) {

  		const data = this.getDataFromNode( node );
  		if ( data.cache === undefined ) data.cache = new NodeCache( parent ? this.getCache() : null );

  		return data.cache;

  	}

  	isAvailable( /*name*/ ) {

  		return false;

  	}

  	getVertexIndex() {

  		console.warn( 'Abstract function.' );

  	}

  	getInstanceIndex() {

  		console.warn( 'Abstract function.' );

  	}

  	getDrawIndex() {

  		console.warn( 'Abstract function.' );

  	}

  	getFrontFacing() {

  		console.warn( 'Abstract function.' );

  	}

  	getFragCoord() {

  		console.warn( 'Abstract function.' );

  	}

  	isFlipY() {

  		return false;

  	}

  	increaseUsage( node ) {

  		const nodeData = this.getDataFromNode( node );
  		nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;

  		return nodeData.usageCount;

  	}

  	generateTexture( /* texture, textureProperty, uvSnippet */ ) {

  		console.warn( 'Abstract function.' );

  	}

  	generateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {

  		console.warn( 'Abstract function.' );

  	}

  	generateConst( type, value = null ) {

  		if ( value === null ) {

  			if ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;
  			else if ( type === 'bool' ) value = false;
  			else if ( type === 'color' ) value = new Color();
  			else if ( type === 'vec2' ) value = new Vector2();
  			else if ( type === 'vec3' ) value = new Vector3();
  			else if ( type === 'vec4' ) value = new Vector4();

  		}

  		if ( type === 'float' ) return toFloat( value );
  		if ( type === 'int' ) return `${ Math.round( value ) }`;
  		if ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';
  		if ( type === 'bool' ) return value ? 'true' : 'false';
  		if ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;

  		const typeLength = this.getTypeLength( type );

  		const componentType = this.getComponentType( type );

  		const generateConst = value => this.generateConst( componentType, value );

  		if ( typeLength === 2 ) {

  			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;

  		} else if ( typeLength === 3 ) {

  			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;

  		} else if ( typeLength === 4 ) {

  			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;

  		} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {

  			return `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;

  		} else if ( typeLength > 4 ) {

  			return `${ this.getType( type ) }()`;

  		}

  		throw new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );

  	}

  	getType( type ) {

  		if ( type === 'color' ) return 'vec3';

  		return type;

  	}

  	hasGeometryAttribute( name ) {

  		return this.geometry && this.geometry.getAttribute( name ) !== undefined;

  	}

  	getAttribute( name, type ) {

  		const attributes = this.attributes;

  		// find attribute

  		for ( const attribute of attributes ) {

  			if ( attribute.name === name ) {

  				return attribute;

  			}

  		}

  		// create a new if no exist

  		const attribute = new NodeAttribute( name, type );

  		attributes.push( attribute );

  		return attribute;

  	}

  	getPropertyName( node/*, shaderStage*/ ) {

  		return node.name;

  	}

  	isVector( type ) {

  		return /vec\d/.test( type );

  	}

  	isMatrix( type ) {

  		return /mat\d/.test( type );

  	}

  	isReference( type ) {

  		return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';

  	}

  	needsToWorkingColorSpace( /*texture*/ ) {

  		return false;

  	}

  	getComponentTypeFromTexture( texture ) {

  		const type = texture.type;

  		if ( texture.isDataTexture ) {

  			if ( type === IntType ) return 'int';
  			if ( type === UnsignedIntType ) return 'uint';

  		}

  		return 'float';

  	}

  	getElementType( type ) {

  		if ( type === 'mat2' ) return 'vec2';
  		if ( type === 'mat3' ) return 'vec3';
  		if ( type === 'mat4' ) return 'vec4';

  		return this.getComponentType( type );

  	}

  	getComponentType( type ) {

  		type = this.getVectorType( type );

  		if ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;

  		const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );

  		if ( componentType === null ) return null;

  		if ( componentType[ 1 ] === 'b' ) return 'bool';
  		if ( componentType[ 1 ] === 'i' ) return 'int';
  		if ( componentType[ 1 ] === 'u' ) return 'uint';

  		return 'float';

  	}

  	getVectorType( type ) {

  		if ( type === 'color' ) return 'vec3';
  		if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';

  		return type;

  	}

  	getTypeFromLength( length, componentType = 'float' ) {

  		if ( length === 1 ) return componentType;

  		const baseType = typeFromLength.get( length );
  		const prefix = componentType === 'float' ? '' : componentType[ 0 ];

  		return prefix + baseType;

  	}

  	getTypeFromArray( array ) {

  		return typeFromArray.get( array.constructor );

  	}

  	getTypeFromAttribute( attribute ) {

  		let dataAttribute = attribute;

  		if ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;

  		const array = dataAttribute.array;
  		const itemSize = attribute.itemSize;
  		const normalized = attribute.normalized;

  		let arrayType;

  		if ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {

  			arrayType = this.getTypeFromArray( array );

  		}

  		return this.getTypeFromLength( itemSize, arrayType );

  	}

  	getTypeLength( type ) {

  		const vecType = this.getVectorType( type );
  		const vecNum = /vec([2-4])/.exec( vecType );

  		if ( vecNum !== null ) return Number( vecNum[ 1 ] );
  		if ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;
  		if ( /mat2/.test( type ) === true ) return 4;
  		if ( /mat3/.test( type ) === true ) return 9;
  		if ( /mat4/.test( type ) === true ) return 16;

  		return 0;

  	}

  	getVectorFromMatrix( type ) {

  		return type.replace( 'mat', 'vec' );

  	}

  	changeComponentType( type, newComponentType ) {

  		return this.getTypeFromLength( this.getTypeLength( type ), newComponentType );

  	}

  	getIntegerType( type ) {

  		const componentType = this.getComponentType( type );

  		if ( componentType === 'int' || componentType === 'uint' ) return type;

  		return this.changeComponentType( type, 'int' );

  	}

  	addStack() {

  		this.stack = stack( this.stack );

  		this.stacks.push( getCurrentStack() || this.stack );
  		setCurrentStack( this.stack );

  		return this.stack;

  	}

  	removeStack() {

  		const lastStack = this.stack;
  		this.stack = lastStack.parent;

  		setCurrentStack( this.stacks.pop() );

  		return lastStack;

  	}

  	getDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {

  		cache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;

  		let nodeData = cache.getData( node );

  		if ( nodeData === undefined ) {

  			nodeData = {};

  			cache.setData( node, nodeData );

  		}

  		if ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};

  		return nodeData[ shaderStage ];

  	}

  	getNodeProperties( node, shaderStage = 'any' ) {

  		const nodeData = this.getDataFromNode( node, shaderStage );

  		return nodeData.properties || ( nodeData.properties = { outputNode: null } );

  	}

  	getBufferAttributeFromNode( node, type ) {

  		const nodeData = this.getDataFromNode( node );

  		let bufferAttribute = nodeData.bufferAttribute;

  		if ( bufferAttribute === undefined ) {

  			const index = this.uniforms.index ++;

  			bufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );

  			this.bufferAttributes.push( bufferAttribute );

  			nodeData.bufferAttribute = bufferAttribute;

  		}

  		return bufferAttribute;

  	}

  	getStructTypeFromNode( node, shaderStage = this.shaderStage ) {

  		const nodeData = this.getDataFromNode( node, shaderStage );

  		if ( nodeData.structType === undefined ) {

  			const index = this.structs.index ++;

  			node.name = `StructType${ index }`;
  			this.structs[ shaderStage ].push( node );

  			nodeData.structType = node;

  		}

  		return node;

  	}

  	getUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {

  		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

  		let nodeUniform = nodeData.uniform;

  		if ( nodeUniform === undefined ) {

  			const index = this.uniforms.index ++;

  			nodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );

  			this.uniforms[ shaderStage ].push( nodeUniform );

  			nodeData.uniform = nodeUniform;

  		}

  		return nodeUniform;

  	}

  	getVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage ) {

  		const nodeData = this.getDataFromNode( node, shaderStage );

  		let nodeVar = nodeData.variable;

  		if ( nodeVar === undefined ) {

  			const vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );

  			if ( name === null ) name = 'nodeVar' + vars.length;

  			nodeVar = new NodeVar( name, type );

  			vars.push( nodeVar );

  			nodeData.variable = nodeVar;

  		}

  		return nodeVar;

  	}

  	getVaryingFromNode( node, name = null, type = node.getNodeType( this ) ) {

  		const nodeData = this.getDataFromNode( node, 'any' );

  		let nodeVarying = nodeData.varying;

  		if ( nodeVarying === undefined ) {

  			const varyings = this.varyings;
  			const index = varyings.length;

  			if ( name === null ) name = 'nodeVarying' + index;

  			nodeVarying = new NodeVarying( name, type );

  			varyings.push( nodeVarying );

  			nodeData.varying = nodeVarying;

  		}

  		return nodeVarying;

  	}

  	getCodeFromNode( node, type, shaderStage = this.shaderStage ) {

  		const nodeData = this.getDataFromNode( node );

  		let nodeCode = nodeData.code;

  		if ( nodeCode === undefined ) {

  			const codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );
  			const index = codes.length;

  			nodeCode = new NodeCode( 'nodeCode' + index, type );

  			codes.push( nodeCode );

  			nodeData.code = nodeCode;

  		}

  		return nodeCode;

  	}

  	addFlowCodeHierarchy( node, nodeBlock ) {

  		const { flowCodes, flowCodeBlock } = this.getDataFromNode( node );

  		let needsFlowCode = true;
  		let nodeBlockHierarchy = nodeBlock;

  		while ( nodeBlockHierarchy ) {

  			if ( flowCodeBlock.get( nodeBlockHierarchy ) === true ) {

  				needsFlowCode = false;
  				break;

  			}

  			nodeBlockHierarchy = this.getDataFromNode( nodeBlockHierarchy ).parentNodeBlock;

  		}

  		if ( needsFlowCode ) {

  			for ( const flowCode of flowCodes ) {

  				this.addLineFlowCode( flowCode );

  			}

  		}

  	}

  	addLineFlowCodeBlock( node, code, nodeBlock ) {

  		const nodeData = this.getDataFromNode( node );
  		const flowCodes = nodeData.flowCodes || ( nodeData.flowCodes = [] );
  		const codeBlock = nodeData.flowCodeBlock || ( nodeData.flowCodeBlock = new WeakMap() );

  		flowCodes.push( code );
  		codeBlock.set( nodeBlock, true );

  	}

  	addLineFlowCode( code, node = null ) {

  		if ( code === '' ) return this;

  		if ( node !== null && this.context.nodeBlock ) {

  			this.addLineFlowCodeBlock( node, code, this.context.nodeBlock );

  		}

  		code = this.tab + code;

  		if ( ! /;\s*$/.test( code ) ) {

  			code = code + ';\n';

  		}

  		this.flow.code += code;

  		return this;

  	}

  	addFlowCode( code ) {

  		this.flow.code += code;

  		return this;

  	}

  	addFlowTab() {

  		this.tab += '\t';

  		return this;

  	}

  	removeFlowTab() {

  		this.tab = this.tab.slice( 0, - 1 );

  		return this;

  	}

  	getFlowData( node/*, shaderStage*/ ) {

  		return this.flowsData.get( node );

  	}

  	flowNode( node ) {

  		const output = node.getNodeType( this );

  		const flowData = this.flowChildNode( node, output );

  		this.flowsData.set( node, flowData );

  		return flowData;

  	}

  	buildFunctionNode( shaderNode ) {

  		const fn = new FunctionNode();

  		const previous = this.currentFunctionNode;

  		this.currentFunctionNode = fn;

  		fn.code = this.buildFunctionCode( shaderNode );

  		this.currentFunctionNode = previous;

  		return fn;

  	}

  	flowShaderNode( shaderNode ) {

  		const layout = shaderNode.layout;

  		const inputs = {
  			[ Symbol.iterator ]() {

  				let index = 0;
  				const values = Object.values( this );
  				return {
  					next: () => ( {
  						value: values[ index ],
  						done: index ++ >= values.length
  					} )
  				};

  			}
  		};

  		for ( const input of layout.inputs ) {

  			inputs[ input.name ] = new ParameterNode( input.type, input.name );

  		}

  		//

  		shaderNode.layout = null;

  		const callNode = shaderNode.call( inputs );
  		const flowData = this.flowStagesNode( callNode, layout.type );

  		shaderNode.layout = layout;

  		return flowData;

  	}

  	flowStagesNode( node, output = null ) {

  		const previousFlow = this.flow;
  		const previousVars = this.vars;
  		const previousCache = this.cache;
  		const previousBuildStage = this.buildStage;
  		const previousStack = this.stack;

  		const flow = {
  			code: ''
  		};

  		this.flow = flow;
  		this.vars = {};
  		this.cache = new NodeCache();
  		this.stack = stack();

  		for ( const buildStage of defaultBuildStages ) {

  			this.setBuildStage( buildStage );

  			flow.result = node.build( this, output );

  		}

  		flow.vars = this.getVars( this.shaderStage );

  		this.flow = previousFlow;
  		this.vars = previousVars;
  		this.cache = previousCache;
  		this.stack = previousStack;

  		this.setBuildStage( previousBuildStage );

  		return flow;

  	}

  	getFunctionOperator() {

  		return null;

  	}

  	flowChildNode( node, output = null ) {

  		const previousFlow = this.flow;

  		const flow = {
  			code: ''
  		};

  		this.flow = flow;

  		flow.result = node.build( this, output );

  		this.flow = previousFlow;

  		return flow;

  	}

  	flowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {

  		const previousShaderStage = this.shaderStage;

  		this.setShaderStage( shaderStage );

  		const flowData = this.flowChildNode( node, output );

  		if ( propertyName !== null ) {

  			flowData.code += `${ this.tab + propertyName } = ${ flowData.result };\n`;

  		}

  		this.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;

  		this.setShaderStage( previousShaderStage );

  		return flowData;

  	}

  	getAttributesArray() {

  		return this.attributes.concat( this.bufferAttributes );

  	}

  	getAttributes( /*shaderStage*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	getVaryings( /*shaderStage*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	getVar( type, name ) {

  		return `${ this.getType( type ) } ${ name }`;

  	}

  	getVars( shaderStage ) {

  		let snippet = '';

  		const vars = this.vars[ shaderStage ];

  		if ( vars !== undefined ) {

  			for ( const variable of vars ) {

  				snippet += `${ this.getVar( variable.type, variable.name ) }; `;

  			}

  		}

  		return snippet;

  	}

  	getUniforms( /*shaderStage*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  	getCodes( shaderStage ) {

  		const codes = this.codes[ shaderStage ];

  		let code = '';

  		if ( codes !== undefined ) {

  			for ( const nodeCode of codes ) {

  				code += nodeCode.code + '\n';

  			}

  		}

  		return code;

  	}

  	getHash() {

  		return this.vertexShader + this.fragmentShader + this.computeShader;

  	}

  	setShaderStage( shaderStage ) {

  		this.shaderStage = shaderStage;

  	}

  	getShaderStage() {

  		return this.shaderStage;

  	}

  	setBuildStage( buildStage ) {

  		this.buildStage = buildStage;

  	}

  	getBuildStage() {

  		return this.buildStage;

  	}

  	buildCode() {

  		console.warn( 'Abstract function.' );

  	}

  	build() {

  		const { object, material, renderer } = this;

  		if ( material !== null ) {

  			let nodeMaterial = renderer.nodes.library.fromMaterial( material );

  			if ( nodeMaterial === null ) {

  				console.error( `NodeMaterial: Material "${ material.type }" is not compatible.` );

  				nodeMaterial = new NodeMaterial();

  			}

  			nodeMaterial.build( this );

  		} else {

  			this.addFlow( 'compute', object );

  		}

  		// setup() -> stage 1: create possible new nodes and returns an output reference node
  		// analyze()   -> stage 2: analyze nodes to possible optimization and validation
  		// generate()  -> stage 3: generate shader

  		for ( const buildStage of defaultBuildStages ) {

  			this.setBuildStage( buildStage );

  			if ( this.context.vertex && this.context.vertex.isNode ) {

  				this.flowNodeFromShaderStage( 'vertex', this.context.vertex );

  			}

  			for ( const shaderStage of shaderStages ) {

  				this.setShaderStage( shaderStage );

  				const flowNodes = this.flowNodes[ shaderStage ];

  				for ( const node of flowNodes ) {

  					if ( buildStage === 'generate' ) {

  						this.flowNode( node );

  					} else {

  						node.build( this );

  					}

  				}

  			}

  		}

  		this.setBuildStage( null );
  		this.setShaderStage( null );

  		// stage 4: build code for a specific output

  		this.buildCode();
  		this.buildUpdateNodes();

  		return this;

  	}

  	getNodeUniform( uniformNode, type ) {

  		if ( type === 'float' || type === 'int' || type === 'uint' ) return new NumberNodeUniform( uniformNode );
  		if ( type === 'vec2' || type === 'ivec2' || type === 'uvec2' ) return new Vector2NodeUniform( uniformNode );
  		if ( type === 'vec3' || type === 'ivec3' || type === 'uvec3' ) return new Vector3NodeUniform( uniformNode );
  		if ( type === 'vec4' || type === 'ivec4' || type === 'uvec4' ) return new Vector4NodeUniform( uniformNode );
  		if ( type === 'color' ) return new ColorNodeUniform( uniformNode );
  		if ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );
  		if ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );

  		throw new Error( `Uniform "${type}" not declared.` );

  	}

  	createNodeMaterial( type = 'NodeMaterial' ) { // @deprecated, r168

  		throw new Error( `THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${ type }() instead.` );

  	}

  	format( snippet, fromType, toType ) {

  		fromType = this.getVectorType( fromType );
  		toType = this.getVectorType( toType );

  		if ( fromType === toType || toType === null || this.isReference( toType ) ) {

  			return snippet;

  		}

  		const fromTypeLength = this.getTypeLength( fromType );
  		const toTypeLength = this.getTypeLength( toType );

  		if ( fromTypeLength === 16 && toTypeLength === 9 ) {

  			return `${ this.getType( toType ) }(${ snippet }[0].xyz, ${ snippet }[1].xyz, ${ snippet }[2].xyz)`;

  		}

  		if ( fromTypeLength === 9 && toTypeLength === 4 ) {

  			return `${ this.getType( toType ) }(${ snippet }[0].xy, ${ snippet }[1].xy)`;

  		}


  		if ( fromTypeLength > 4 ) { // fromType is matrix-like

  			// @TODO: ignore for now

  			return snippet;

  		}

  		if ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown

  			// @TODO: ignore for now

  			return snippet;

  		}

  		if ( fromTypeLength === toTypeLength ) {

  			return `${ this.getType( toType ) }( ${ snippet } )`;

  		}

  		if ( fromTypeLength > toTypeLength ) {

  			return this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );

  		}

  		if ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like

  			return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;

  		}

  		if ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like

  			return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;

  		}

  		if ( fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType( toType ) ) { // fromType is float-like

  			// convert a number value to vector type, e.g:
  			// vec3( 1u ) -> vec3( float( 1u ) )

  			snippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;

  		}

  		return `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like

  	}

  	getSignature() {

  		return `// Three.js r${ REVISION } - Node System\n`;

  	}

  }

  class NodeFrame {

  	constructor() {

  		this.time = 0;
  		this.deltaTime = 0;

  		this.frameId = 0;
  		this.renderId = 0;

  		this.startTime = null;

  		this.updateMap = new WeakMap();
  		this.updateBeforeMap = new WeakMap();
  		this.updateAfterMap = new WeakMap();

  		this.renderer = null;
  		this.material = null;
  		this.camera = null;
  		this.object = null;
  		this.scene = null;

  	}

  	_getMaps( referenceMap, nodeRef ) {

  		let maps = referenceMap.get( nodeRef );

  		if ( maps === undefined ) {

  			maps = {
  				renderMap: new WeakMap(),
  				frameMap: new WeakMap()
  			};

  			referenceMap.set( nodeRef, maps );

  		}

  		return maps;

  	}

  	updateBeforeNode( node ) {

  		const updateType = node.getUpdateBeforeType();
  		const reference = node.updateReference( this );

  		if ( updateType === NodeUpdateType.FRAME ) {

  			const { frameMap } = this._getMaps( this.updateBeforeMap, reference );

  			if ( frameMap.get( reference ) !== this.frameId ) {

  				if ( node.updateBefore( this ) !== false ) {

  					frameMap.set( reference, this.frameId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.RENDER ) {

  			const { renderMap } = this._getMaps( this.updateBeforeMap, reference );

  			if ( renderMap.get( reference ) !== this.renderId ) {

  				if ( node.updateBefore( this ) !== false ) {

  					renderMap.set( reference, this.renderId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.OBJECT ) {

  			node.updateBefore( this );

  		}

  	}

  	updateAfterNode( node ) {

  		const updateType = node.getUpdateAfterType();
  		const reference = node.updateReference( this );

  		if ( updateType === NodeUpdateType.FRAME ) {

  			const { frameMap } = this._getMaps( this.updateAfterMap, reference );

  			if ( frameMap.get( reference ) !== this.frameId ) {

  				if ( node.updateAfter( this ) !== false ) {

  					frameMap.set( reference, this.frameId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.RENDER ) {

  			const { renderMap } = this._getMaps( this.updateAfterMap, reference );

  			if ( renderMap.get( reference ) !== this.renderId ) {

  				if ( node.updateAfter( this ) !== false ) {

  					renderMap.set( reference, this.renderId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.OBJECT ) {

  			node.updateAfter( this );

  		}

  	}

  	updateNode( node ) {

  		const updateType = node.getUpdateType();
  		const reference = node.updateReference( this );

  		if ( updateType === NodeUpdateType.FRAME ) {

  			const { frameMap } = this._getMaps( this.updateMap, reference );

  			if ( frameMap.get( reference ) !== this.frameId ) {

  				if ( node.update( this ) !== false ) {

  					frameMap.set( reference, this.frameId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.RENDER ) {

  			const { renderMap } = this._getMaps( this.updateMap, reference );

  			if ( renderMap.get( reference ) !== this.renderId ) {

  				if ( node.update( this ) !== false ) {

  					renderMap.set( reference, this.renderId );

  				}

  			}

  		} else if ( updateType === NodeUpdateType.OBJECT ) {

  			node.update( this );

  		}

  	}

  	update() {

  		this.frameId ++;

  		if ( this.lastTime === undefined ) this.lastTime = performance.now();

  		this.deltaTime = ( performance.now() - this.lastTime ) / 1000;

  		this.lastTime = performance.now();

  		this.time += this.deltaTime;

  	}

  }

  class NodeFunctionInput {

  	constructor( type, name, count = null, qualifier = '', isConst = false ) {

  		this.type = type;
  		this.name = name;
  		this.count = count;
  		this.qualifier = qualifier;
  		this.isConst = isConst;

  	}

  }

  NodeFunctionInput.isNodeFunctionInput = true;

  class TimerNode extends UniformNode {

  	static get type() {

  		return 'TimerNode';

  	}

  	constructor( scope = TimerNode.LOCAL, scale = 1, value = 0 ) {

  		super( value );

  		this.scope = scope;
  		this.scale = scale;

  		this.updateType = NodeUpdateType.FRAME;

  	}
  	/*
  	@TODO:
  	getNodeType( builder ) {

  		const scope = this.scope;

  		if ( scope === TimerNode.FRAME ) {

  			return 'uint';

  		}

  		return 'float';

  	}
  */
  	update( frame ) {

  		const scope = this.scope;
  		const scale = this.scale;

  		if ( scope === TimerNode.LOCAL ) {

  			this.value += frame.deltaTime * scale;

  		} else if ( scope === TimerNode.DELTA ) {

  			this.value = frame.deltaTime * scale;

  		} else if ( scope === TimerNode.FRAME ) {

  			this.value = frame.frameId;

  		} else {

  			// global

  			this.value = frame.time * scale;

  		}

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.scope = this.scope;
  		data.scale = this.scale;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.scope = data.scope;
  		this.scale = data.scale;

  	}

  }

  TimerNode.LOCAL = 'local';
  TimerNode.GLOBAL = 'global';
  TimerNode.DELTA = 'delta';
  TimerNode.FRAME = 'frame';

  // @TODO: add support to use node in timeScale
  const timerLocal = ( timeScale, value = 0 ) => nodeObject( new TimerNode( TimerNode.LOCAL, timeScale, value ) );

  class OscNode extends Node {

  	static get type() {

  		return 'OscNode';

  	}

  	constructor( method = OscNode.SINE, timeNode = timerLocal() ) {

  		super();

  		this.method = method;
  		this.timeNode = timeNode;

  	}

  	getNodeType( builder ) {

  		return this.timeNode.getNodeType( builder );

  	}

  	setup() {

  		const method = this.method;
  		const timeNode = nodeObject( this.timeNode );

  		let outputNode = null;

  		if ( method === OscNode.SINE ) {

  			outputNode = timeNode.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );

  		} else if ( method === OscNode.SQUARE ) {

  			outputNode = timeNode.fract().round();

  		} else if ( method === OscNode.TRIANGLE ) {

  			outputNode = timeNode.add( 0.5 ).fract().mul( 2 ).sub( 1 ).abs();

  		} else if ( method === OscNode.SAWTOOTH ) {

  			outputNode = timeNode.fract();

  		}

  		return outputNode;

  	}

  	serialize( data ) {

  		super.serialize( data );

  		data.method = this.method;

  	}

  	deserialize( data ) {

  		super.deserialize( data );

  		this.method = data.method;

  	}

  }

  OscNode.SINE = 'sine';
  OscNode.SQUARE = 'square';
  OscNode.TRIANGLE = 'triangle';
  OscNode.SAWTOOTH = 'sawtooth';

  /*@__PURE__*/ nodeProxy( OscNode, OscNode.SINE );
  /*@__PURE__*/ nodeProxy( OscNode, OscNode.SQUARE );
  /*@__PURE__*/ nodeProxy( OscNode, OscNode.TRIANGLE );
  /*@__PURE__*/ nodeProxy( OscNode, OscNode.SAWTOOTH );

  new Plane();
  new Vector3();
  new Vector3();
  new Vector3();
  new Matrix4();
  new Vector3( 0, 0, - 1 );
  new Vector4();

  new Vector3();
  new Vector3();
  new Vector4();

  new Vector2();

  new RenderTarget();
  screenUV.flipX();

  // Helper for passes that need to fill the viewport with a single quad.

  const _camera$1 = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

  // https://github.com/mrdoob/three.js/pull/21358

  class QuadGeometry extends BufferGeometry {

  	constructor( flipY = false ) {

  		super();

  		const uv = flipY === false ? [ 0, - 1, 0, 1, 2, 1 ] : [ 0, 2, 0, 0, 2, 0 ];

  		this.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );

  	}

  }

  const _geometry$1 = /*@__PURE__*/ new QuadGeometry();

  class QuadMesh extends Mesh {

  	constructor( material = null ) {

  		super( _geometry$1, material );

  		this.camera = _camera$1;

  		this.isQuadMesh = true;

  	}

  	renderAsync( renderer ) {

  		return renderer.renderAsync( this, _camera$1 );

  	}

  	render( renderer ) {

  		renderer.render( this, _camera$1 );

  	}

  }

  class SceneNode extends Node {

  	static get type() {

  		return 'SceneNode';

  	}

  	constructor( scope = SceneNode.BACKGROUND_BLURRINESS, scene = null ) {

  		super();

  		this.scope = scope;
  		this.scene = scene;

  	}

  	setup( builder ) {

  		const scope = this.scope;
  		const scene = this.scene !== null ? this.scene : builder.scene;

  		let output;

  		if ( scope === SceneNode.BACKGROUND_BLURRINESS ) {

  			output = reference( 'backgroundBlurriness', 'float', scene );

  		} else if ( scope === SceneNode.BACKGROUND_INTENSITY ) {

  			output = reference( 'backgroundIntensity', 'float', scene );

  		} else {

  			console.error( 'THREE.SceneNode: Unknown scope:', scope );

  		}

  		return output;

  	}

  }

  SceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';
  SceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';

  const backgroundBlurriness = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_BLURRINESS );
  const backgroundIntensity = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_INTENSITY );

  const GPUPrimitiveTopology = {
  	PointList: 'point-list',
  	LineList: 'line-list',
  	LineStrip: 'line-strip',
  	TriangleList: 'triangle-list',
  	TriangleStrip: 'triangle-strip',
  };

  const GPUCompareFunction = {
  	Never: 'never',
  	Less: 'less',
  	Equal: 'equal',
  	LessEqual: 'less-equal',
  	Greater: 'greater',
  	NotEqual: 'not-equal',
  	GreaterEqual: 'greater-equal',
  	Always: 'always'
  };

  const GPUStoreOp = {
  	Store: 'store',
  	Discard: 'discard'
  };

  const GPULoadOp = {
  	Load: 'load',
  	Clear: 'clear'
  };

  const GPUFrontFace = {
  	CCW: 'ccw',
  	CW: 'cw'
  };

  const GPUCullMode = {
  	None: 'none',
  	Front: 'front',
  	Back: 'back'
  };

  const GPUIndexFormat = {
  	Uint16: 'uint16',
  	Uint32: 'uint32'
  };

  const GPUTextureFormat = {

  	// 8-bit formats

  	R8Unorm: 'r8unorm',
  	R8Snorm: 'r8snorm',
  	R8Uint: 'r8uint',
  	R8Sint: 'r8sint',

  	// 16-bit formats

  	R16Uint: 'r16uint',
  	R16Sint: 'r16sint',
  	R16Float: 'r16float',
  	RG8Unorm: 'rg8unorm',
  	RG8Snorm: 'rg8snorm',
  	RG8Uint: 'rg8uint',
  	RG8Sint: 'rg8sint',

  	// 32-bit formats

  	R32Uint: 'r32uint',
  	R32Sint: 'r32sint',
  	R32Float: 'r32float',
  	RG16Uint: 'rg16uint',
  	RG16Sint: 'rg16sint',
  	RG16Float: 'rg16float',
  	RGBA8Unorm: 'rgba8unorm',
  	RGBA8UnormSRGB: 'rgba8unorm-srgb',
  	RGBA8Snorm: 'rgba8snorm',
  	RGBA8Uint: 'rgba8uint',
  	RGBA8Sint: 'rgba8sint',
  	BGRA8Unorm: 'bgra8unorm',
  	BGRA8UnormSRGB: 'bgra8unorm-srgb',
  	// Packed 32-bit formats
  	RGB9E5UFloat: 'rgb9e5ufloat',
  	RGB10A2Unorm: 'rgb10a2unorm',
  	RG11B10uFloat: 'rgb10a2unorm',

  	// 64-bit formats

  	RG32Uint: 'rg32uint',
  	RG32Sint: 'rg32sint',
  	RG32Float: 'rg32float',
  	RGBA16Uint: 'rgba16uint',
  	RGBA16Sint: 'rgba16sint',
  	RGBA16Float: 'rgba16float',

  	// 128-bit formats

  	RGBA32Uint: 'rgba32uint',
  	RGBA32Sint: 'rgba32sint',
  	RGBA32Float: 'rgba32float',

  	// Depth and stencil formats

  	Stencil8: 'stencil8',
  	Depth16Unorm: 'depth16unorm',
  	Depth24Plus: 'depth24plus',
  	Depth24PlusStencil8: 'depth24plus-stencil8',
  	Depth32Float: 'depth32float',

  	// 'depth32float-stencil8' extension

  	Depth32FloatStencil8: 'depth32float-stencil8',

  	// BC compressed formats usable if 'texture-compression-bc' is both
  	// supported by the device/user agent and enabled in requestDevice.

  	BC1RGBAUnorm: 'bc1-rgba-unorm',
  	BC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',
  	BC2RGBAUnorm: 'bc2-rgba-unorm',
  	BC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',
  	BC3RGBAUnorm: 'bc3-rgba-unorm',
  	BC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',
  	BC4RUnorm: 'bc4-r-unorm',
  	BC4RSnorm: 'bc4-r-snorm',
  	BC5RGUnorm: 'bc5-rg-unorm',
  	BC5RGSnorm: 'bc5-rg-snorm',
  	BC6HRGBUFloat: 'bc6h-rgb-ufloat',
  	BC6HRGBFloat: 'bc6h-rgb-float',
  	BC7RGBAUnorm: 'bc7-rgba-unorm',
  	BC7RGBAUnormSRGB: 'bc7-rgba-srgb',

  	// ETC2 compressed formats usable if 'texture-compression-etc2' is both
  	// supported by the device/user agent and enabled in requestDevice.

  	ETC2RGB8Unorm: 'etc2-rgb8unorm',
  	ETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',
  	ETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',
  	ETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',
  	ETC2RGBA8Unorm: 'etc2-rgba8unorm',
  	ETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',
  	EACR11Unorm: 'eac-r11unorm',
  	EACR11Snorm: 'eac-r11snorm',
  	EACRG11Unorm: 'eac-rg11unorm',
  	EACRG11Snorm: 'eac-rg11snorm',

  	// ASTC compressed formats usable if 'texture-compression-astc' is both
  	// supported by the device/user agent and enabled in requestDevice.

  	ASTC4x4Unorm: 'astc-4x4-unorm',
  	ASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',
  	ASTC5x4Unorm: 'astc-5x4-unorm',
  	ASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',
  	ASTC5x5Unorm: 'astc-5x5-unorm',
  	ASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',
  	ASTC6x5Unorm: 'astc-6x5-unorm',
  	ASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',
  	ASTC6x6Unorm: 'astc-6x6-unorm',
  	ASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',
  	ASTC8x5Unorm: 'astc-8x5-unorm',
  	ASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',
  	ASTC8x6Unorm: 'astc-8x6-unorm',
  	ASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',
  	ASTC8x8Unorm: 'astc-8x8-unorm',
  	ASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',
  	ASTC10x5Unorm: 'astc-10x5-unorm',
  	ASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',
  	ASTC10x6Unorm: 'astc-10x6-unorm',
  	ASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',
  	ASTC10x8Unorm: 'astc-10x8-unorm',
  	ASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',
  	ASTC10x10Unorm: 'astc-10x10-unorm',
  	ASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',
  	ASTC12x10Unorm: 'astc-12x10-unorm',
  	ASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',
  	ASTC12x12Unorm: 'astc-12x12-unorm',
  	ASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',

  };

  const GPUAddressMode = {
  	ClampToEdge: 'clamp-to-edge',
  	Repeat: 'repeat',
  	MirrorRepeat: 'mirror-repeat'
  };

  const GPUFilterMode = {
  	Linear: 'linear',
  	Nearest: 'nearest'
  };

  const GPUBlendFactor = {
  	Zero: 'zero',
  	One: 'one',
  	Src: 'src',
  	OneMinusSrc: 'one-minus-src',
  	SrcAlpha: 'src-alpha',
  	OneMinusSrcAlpha: 'one-minus-src-alpha',
  	Dst: 'dst',
  	OneMinusDstColor: 'one-minus-dst',
  	DstAlpha: 'dst-alpha',
  	OneMinusDstAlpha: 'one-minus-dst-alpha',
  	SrcAlphaSaturated: 'src-alpha-saturated',
  	Constant: 'constant',
  	OneMinusConstant: 'one-minus-constant'
  };

  const GPUBlendOperation = {
  	Add: 'add',
  	Subtract: 'subtract',
  	ReverseSubtract: 'reverse-subtract',
  	Min: 'min',
  	Max: 'max'
  };

  const GPUColorWriteFlags = {
  	None: 0,
  	Red: 0x1,
  	Green: 0x2,
  	Blue: 0x4,
  	Alpha: 0x8,
  	All: 0xF
  };

  const GPUStencilOperation = {
  	Keep: 'keep',
  	Zero: 'zero',
  	Replace: 'replace',
  	Invert: 'invert',
  	IncrementClamp: 'increment-clamp',
  	DecrementClamp: 'decrement-clamp',
  	IncrementWrap: 'increment-wrap',
  	DecrementWrap: 'decrement-wrap'
  };

  const GPUBufferBindingType = {
  	Uniform: 'uniform',
  	Storage: 'storage',
  	ReadOnlyStorage: 'read-only-storage'
  };

  const GPUStorageTextureAccess = {
  	WriteOnly: 'write-only',
  	ReadOnly: 'read-only',
  	ReadWrite: 'read-write',
  };

  const GPUTextureSampleType = {
  	Float: 'float',
  	UnfilterableFloat: 'unfilterable-float',
  	Depth: 'depth',
  	SInt: 'sint',
  	UInt: 'uint'
  };

  const GPUTextureDimension = {
  	OneD: '1d',
  	TwoD: '2d',
  	ThreeD: '3d'
  };

  const GPUTextureViewDimension = {
  	OneD: '1d',
  	TwoD: '2d',
  	TwoDArray: '2d-array',
  	Cube: 'cube',
  	CubeArray: 'cube-array',
  	ThreeD: '3d'
  };

  const GPUTextureAspect = {
  	All: 'all',
  	StencilOnly: 'stencil-only',
  	DepthOnly: 'depth-only'
  };

  const GPUInputStepMode = {
  	Vertex: 'vertex',
  	Instance: 'instance'
  };

  const GPUFeatureName = {
  	DepthClipControl: 'depth-clip-control',
  	Depth32FloatStencil8: 'depth32float-stencil8',
  	TextureCompressionBC: 'texture-compression-bc',
  	TextureCompressionETC2: 'texture-compression-etc2',
  	TextureCompressionASTC: 'texture-compression-astc',
  	TimestampQuery: 'timestamp-query',
  	IndirectFirstInstance: 'indirect-first-instance',
  	ShaderF16: 'shader-f16',
  	RG11B10UFloat: 'rg11b10ufloat-renderable',
  	BGRA8UNormStorage: 'bgra8unorm-storage',
  	Float32Filterable: 'float32-filterable',
  	ClipDistances: 'clip-distances',
  	DualSourceBlending: 'dual-source-blending',
  	Subgroups: 'subgroups'
  };

  const _size$7 = /*@__PURE__*/ new Vector2();

  class PassTextureNode extends TextureNode {

  	static get type() {

  		return 'PassTextureNode';

  	}

  	constructor( passNode, texture ) {

  		super( texture );

  		this.passNode = passNode;

  		this.setUpdateMatrix( false );

  	}

  	setup( builder ) {

  		if ( builder.object.isQuadMesh ) this.passNode.build( builder );

  		return super.setup( builder );

  	}

  	clone() {

  		return new this.constructor( this.passNode, this.value );

  	}

  }

  class PassMultipleTextureNode extends PassTextureNode {

  	static get type() {

  		return 'PassMultipleTextureNode';

  	}

  	constructor( passNode, textureName, previousTexture = false ) {

  		super( passNode, null );

  		this.textureName = textureName;
  		this.previousTexture = previousTexture;

  	}

  	updateTexture() {

  		this.value = this.previousTexture ? this.passNode.getPreviousTexture( this.textureName ) : this.passNode.getTexture( this.textureName );

  	}

  	setup( builder ) {

  		this.updateTexture();

  		return super.setup( builder );

  	}

  	clone() {

  		return new this.constructor( this.passNode, this.textureName, this.previousTexture );

  	}

  }

  class PassNode extends TempNode {

  	static get type() {

  		return 'PassNode';

  	}

  	constructor( scope, scene, camera, options = {} ) {

  		super( 'vec4' );

  		this.scope = scope;
  		this.scene = scene;
  		this.camera = camera;
  		this.options = options;

  		this._pixelRatio = 1;
  		this._width = 1;
  		this._height = 1;

  		const depthTexture = new DepthTexture();
  		depthTexture.isRenderTargetTexture = true;
  		//depthTexture.type = FloatType;
  		depthTexture.name = 'depth';

  		const renderTarget = new RenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, } );
  		renderTarget.texture.name = 'output';
  		renderTarget.depthTexture = depthTexture;

  		this.renderTarget = renderTarget;

  		this.updateBeforeType = NodeUpdateType.FRAME;

  		this._textures = {
  			output: renderTarget.texture,
  			depth: depthTexture
  		};

  		this._textureNodes = {};
  		this._linearDepthNodes = {};
  		this._viewZNodes = {};

  		this._previousTextures = {};
  		this._previousTextureNodes = {};

  		this._cameraNear = uniform( 0 );
  		this._cameraFar = uniform( 0 );

  		this._mrt = null;

  		this.isPassNode = true;

  	}

  	setMRT( mrt ) {

  		this._mrt = mrt;

  		return this;

  	}

  	getMRT() {

  		return this._mrt;

  	}

  	isGlobal() {

  		return true;

  	}

  	getTexture( name ) {

  		let texture = this._textures[ name ];

  		if ( texture === undefined ) {

  			const refTexture = this.renderTarget.texture;

  			texture = refTexture.clone();
  			texture.isRenderTargetTexture = true;
  			texture.name = name;

  			this._textures[ name ] = texture;

  			this.renderTarget.textures.push( texture );

  		}

  		return texture;

  	}

  	getPreviousTexture( name ) {

  		let texture = this._previousTextures[ name ];

  		if ( texture === undefined ) {

  			texture = this.getTexture( name ).clone();
  			texture.isRenderTargetTexture = true;

  			this._previousTextures[ name ] = texture;

  		}

  		return texture;

  	}

  	toggleTexture( name ) {

  		const prevTexture = this._previousTextures[ name ];

  		if ( prevTexture !== undefined ) {

  			const texture = this._textures[ name ];

  			const index = this.renderTarget.textures.indexOf( texture );
  			this.renderTarget.textures[ index ] = prevTexture;

  			this._textures[ name ] = prevTexture;
  			this._previousTextures[ name ] = texture;

  			this._textureNodes[ name ].updateTexture();
  			this._previousTextureNodes[ name ].updateTexture();

  		}

  	}

  	getTextureNode( name = 'output' ) {

  		let textureNode = this._textureNodes[ name ];

  		if ( textureNode === undefined ) {

  			this._textureNodes[ name ] = textureNode = nodeObject( new PassMultipleTextureNode( this, name ) );
  			this._textureNodes[ name ].updateTexture();

  		}

  		return textureNode;

  	}

  	getPreviousTextureNode( name = 'output' ) {

  		let textureNode = this._previousTextureNodes[ name ];

  		if ( textureNode === undefined ) {

  			if ( this._textureNodes[ name ] === undefined ) this.getTextureNode( name );

  			this._previousTextureNodes[ name ] = textureNode = nodeObject( new PassMultipleTextureNode( this, name, true ) );
  			this._previousTextureNodes[ name ].updateTexture();

  		}

  		return textureNode;

  	}

  	getViewZNode( name = 'depth' ) {

  		let viewZNode = this._viewZNodes[ name ];

  		if ( viewZNode === undefined ) {

  			const cameraNear = this._cameraNear;
  			const cameraFar = this._cameraFar;

  			this._viewZNodes[ name ] = viewZNode = perspectiveDepthToViewZ( this.getTextureNode( name ), cameraNear, cameraFar );

  		}

  		return viewZNode;

  	}

  	getLinearDepthNode( name = 'depth' ) {

  		let linearDepthNode = this._linearDepthNodes[ name ];

  		if ( linearDepthNode === undefined ) {

  			const cameraNear = this._cameraNear;
  			const cameraFar = this._cameraFar;
  			const viewZNode = this.getViewZNode( name );

  			// TODO: just if ( builder.camera.isPerspectiveCamera )

  			this._linearDepthNodes[ name ] = linearDepthNode = viewZToOrthographicDepth( viewZNode, cameraNear, cameraFar );

  		}

  		return linearDepthNode;

  	}

  	setup( { renderer } ) {

  		this.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;

  		// Disable MSAA for WebGL backend for now
  		if ( renderer.backend.isWebGLBackend === true ) {

  			this.renderTarget.samples = 0;

  		}

  		this.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1;

  		return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();

  	}

  	updateBefore( frame ) {

  		const { renderer } = frame;
  		const { scene, camera } = this;

  		this._pixelRatio = renderer.getPixelRatio();

  		const size = renderer.getSize( _size$7 );

  		this.setSize( size.width, size.height );

  		const currentRenderTarget = renderer.getRenderTarget();
  		const currentMRT = renderer.getMRT();

  		this._cameraNear.value = camera.near;
  		this._cameraFar.value = camera.far;

  		for ( const name in this._previousTextures ) {

  			this.toggleTexture( name );

  		}

  		renderer.setRenderTarget( this.renderTarget );
  		renderer.setMRT( this._mrt );

  		renderer.render( scene, camera );

  		renderer.setRenderTarget( currentRenderTarget );
  		renderer.setMRT( currentMRT );

  	}

  	setSize( width, height ) {

  		this._width = width;
  		this._height = height;

  		const effectiveWidth = this._width * this._pixelRatio;
  		const effectiveHeight = this._height * this._pixelRatio;

  		this.renderTarget.setSize( effectiveWidth, effectiveHeight );

  	}

  	setPixelRatio( pixelRatio ) {

  		this._pixelRatio = pixelRatio;

  		this.setSize( this._width, this._height );

  	}

  	dispose() {

  		this.renderTarget.dispose();

  	}


  }

  PassNode.COLOR = 'color';
  PassNode.DEPTH = 'depth';

  class FogNode extends Node {

  	static get type() {

  		return 'FogNode';

  	}

  	constructor( colorNode, factorNode ) {

  		super( 'float' );

  		this.isFogNode = true;

  		this.colorNode = colorNode;
  		this.factorNode = factorNode;

  	}

  	getViewZNode( builder ) {

  		let viewZ;

  		const getViewZ = builder.context.getViewZ;

  		if ( getViewZ !== undefined ) {

  			viewZ = getViewZ( this );

  		}

  		return ( viewZ || positionView.z ).negate();

  	}

  	setup() {

  		return this.factorNode;

  	}

  }

  class FogRangeNode extends FogNode {

  	static get type() {

  		return 'FogRangeNode';

  	}

  	constructor( colorNode, nearNode, farNode ) {

  		super( colorNode );

  		this.isFogRangeNode = true;

  		this.nearNode = nearNode;
  		this.farNode = farNode;

  	}

  	setup( builder ) {

  		const viewZ = this.getViewZNode( builder );

  		return smoothstep( this.nearNode, this.farNode, viewZ );

  	}

  }

  const rangeFog = /*@__PURE__*/ nodeProxy( FogRangeNode );

  class FogExp2Node extends FogNode {

  	static get type() {

  		return 'FogExp2Node';

  	}

  	constructor( colorNode, densityNode ) {

  		super( colorNode );

  		this.isFogExp2Node = true;

  		this.densityNode = densityNode;

  	}

  	setup( builder ) {

  		const viewZ = this.getViewZNode( builder );
  		const density = this.densityNode;

  		return density.mul( density, viewZ, viewZ ).negate().exp().oneMinus();

  	}

  }

  const densityFog = /*@__PURE__*/ nodeProxy( FogExp2Node );

  const BasicShadowMap = Fn( ( { depthTexture, shadowCoord } ) => {

  	return texture( depthTexture, shadowCoord.xy ).compare( shadowCoord.z );

  } );

  const PCFShadowMap = Fn( ( { depthTexture, shadowCoord, shadow } ) => {

  	const depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );

  	const mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );
  	const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );

  	const texelSize = vec2( 1 ).div( mapSize );
  	const dx0 = texelSize.x.negate().mul( radius );
  	const dy0 = texelSize.y.negate().mul( radius );
  	const dx1 = texelSize.x.mul( radius );
  	const dy1 = texelSize.y.mul( radius );
  	const dx2 = dx0.div( 2 );
  	const dy2 = dy0.div( 2 );
  	const dx3 = dx1.div( 2 );
  	const dy3 = dy1.div( 2 );

  	return add(
  		depthCompare( shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy, shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),
  		depthCompare( shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )
  	).mul( 1 / 17 );

  } );

  const PCFSoftShadowMap = Fn( ( { depthTexture, shadowCoord, shadow } ) => {

  	const depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );

  	const mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );

  	const texelSize = vec2( 1 ).div( mapSize );
  	const dx = texelSize.x;
  	const dy = texelSize.y;

  	const uv = shadowCoord.xy;
  	const f = fract( uv.mul( mapSize ).add( 0.5 ) );
  	uv.subAssign( f.mul( texelSize ) );

  	return add(
  		depthCompare( uv, shadowCoord.z ),
  		depthCompare( uv.add( vec2( dx, 0 ) ), shadowCoord.z ),
  		depthCompare( uv.add( vec2( 0, dy ) ), shadowCoord.z ),
  		depthCompare( uv.add( texelSize ), shadowCoord.z ),
  		mix$2(
  			depthCompare( uv.add( vec2( dx.negate(), 0 ) ), shadowCoord.z ),
  			depthCompare( uv.add( vec2( dx.mul( 2 ), 0 ) ), shadowCoord.z ),
  			f.x
  		),
  		mix$2(
  			depthCompare( uv.add( vec2( dx.negate(), dy ) ), shadowCoord.z ),
  			depthCompare( uv.add( vec2( dx.mul( 2 ), dy ) ), shadowCoord.z ),
  			f.x
  		),
  		mix$2(
  			depthCompare( uv.add( vec2( 0, dy.negate() ) ), shadowCoord.z ),
  			depthCompare( uv.add( vec2( 0, dy.mul( 2 ) ) ), shadowCoord.z ),
  			f.y
  		),
  		mix$2(
  			depthCompare( uv.add( vec2( dx, dy.negate() ) ), shadowCoord.z ),
  			depthCompare( uv.add( vec2( dx, dy.mul( 2 ) ) ), shadowCoord.z ),
  			f.y
  		),
  		mix$2(
  			mix$2(
  				depthCompare( uv.add( vec2( dx.negate(), dy.negate() ) ), shadowCoord.z ),
  				depthCompare( uv.add( vec2( dx.mul( 2 ), dy.negate() ) ), shadowCoord.z ),
  				f.x
  			),
  			mix$2(
  				depthCompare( uv.add( vec2( dx.negate(), dy.mul( 2 ) ) ), shadowCoord.z ),
  				depthCompare( uv.add( vec2( dx.mul( 2 ), dy.mul( 2 ) ) ), shadowCoord.z ),
  				f.x
  			),
  			f.y
  		)
  	).mul( 1 / 9 );

  } );

  // VSM

  const VSMShadowMapNode = Fn( ( { depthTexture, shadowCoord } ) => {

  	const occlusion = float( 1 ).toVar();

  	const distribution = texture( depthTexture ).uv( shadowCoord.xy ).rg;

  	const hardShadow = step( shadowCoord.z, distribution.x );

  	If( hardShadow.notEqual( float( 1.0 ) ), () => {

  		const distance = shadowCoord.z.sub( distribution.x );
  		const variance = max$1( 0, distribution.y.mul( distribution.y ) );
  		let softnessProbability = variance.div( variance.add( distance.mul( distance ) ) ); // Chebeyshevs inequality
  		softnessProbability = clamp( sub( softnessProbability, 0.3 ).div( 0.95 - 0.3 ) );
  		occlusion.assign( clamp( max$1( hardShadow, softnessProbability ) ) );

  	} );

  	return occlusion;

  } );

  const VSMPassVertical = Fn( ( { samples, radius, size, shadowPass } ) => {

  	const mean = float( 0 ).toVar();
  	const squaredMean = float( 0 ).toVar();

  	const uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );
  	const uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );

  	Loop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {

  		const uvOffset = uvStart.add( float( i ).mul( uvStride ) );

  		const depth = shadowPass.uv( add( screenCoordinate.xy, vec2( 0, uvOffset ).mul( radius ) ).div( size ) ).x;
  		mean.addAssign( depth );
  		squaredMean.addAssign( depth.mul( depth ) );

  	} );

  	mean.divAssign( samples );
  	squaredMean.divAssign( samples );

  	const std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );
  	return vec2( mean, std_dev );

  } );

  const VSMPassHorizontal = Fn( ( { samples, radius, size, shadowPass } ) => {

  	const mean = float( 0 ).toVar();
  	const squaredMean = float( 0 ).toVar();

  	const uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );
  	const uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );

  	Loop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {

  		const uvOffset = uvStart.add( float( i ).mul( uvStride ) );

  		const distribution = shadowPass.uv( add( screenCoordinate.xy, vec2( uvOffset, 0 ).mul( radius ) ).div( size ) );
  		mean.addAssign( distribution.x );
  		squaredMean.addAssign( add( distribution.y.mul( distribution.y ), distribution.x.mul( distribution.x ) ) );

  	} );

  	mean.divAssign( samples );
  	squaredMean.divAssign( samples );

  	const std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );
  	return vec2( mean, std_dev );

  } );

  const _shadowFilterLib = [ BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, VSMShadowMapNode ];

  //

  let _overrideMaterial = null;
  const _quadMesh$1 = /*@__PURE__*/ new QuadMesh();

  class AnalyticLightNode extends LightingNode {

  	static get type() {

  		return 'AnalyticLightNode';

  	}

  	constructor( light = null ) {

  		super();

  		this.updateType = NodeUpdateType.FRAME;

  		this.light = light;

  		this.color = new Color();
  		this.colorNode = uniform( this.color ).setGroup( renderGroup );

  		this.baseColorNode = null;

  		this.shadowMap = null;
  		this.shadowNode = null;
  		this.shadowColorNode = null;

  		this.vsmShadowMapVertical = null;
  		this.vsmShadowMapHorizontal = null;

  		this.vsmMaterialVertical = null;
  		this.vsmMaterialHorizontal = null;

  		this.isAnalyticLightNode = true;

  	}

  	getCacheKey() {

  		return hash$1( super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0 );

  	}

  	getHash() {

  		return this.light.uuid;

  	}

  	setupShadow( builder ) {

  		const { object, renderer } = builder;

  		if ( renderer.shadowMap.enabled === false ) return;

  		let shadowColorNode = this.shadowColorNode;

  		if ( shadowColorNode === null ) {

  			if ( _overrideMaterial === null ) {

  				_overrideMaterial = new NodeMaterial();
  				_overrideMaterial.fragmentNode = vec4( 0, 0, 0, 1 );
  				_overrideMaterial.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.fragmentNode unintentionally when using material.shadowNode
  				_overrideMaterial.name = 'ShadowMaterial';

  			}

  			const shadowMapType = renderer.shadowMap.type;
  			const shadow = this.light.shadow;

  			const depthTexture = new DepthTexture();
  			depthTexture.compareFunction = LessCompare;

  			const shadowMap = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height );
  			shadowMap.depthTexture = depthTexture;

  			shadow.camera.updateProjectionMatrix();

  			// VSM

  			if ( shadowMapType === VSMShadowMap ) {

  				depthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()

  				this.vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );
  				this.vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );

  				const shadowPassVertical = texture( depthTexture );
  				const shadowPassHorizontal = texture( this.vsmShadowMapVertical.texture );

  				const samples = reference( 'blurSamples', 'float', shadow ).setGroup( renderGroup );
  				const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );
  				const size = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );

  				let material = this.vsmMaterialVertical || ( this.vsmMaterialVertical = new NodeMaterial() );
  				material.fragmentNode = VSMPassVertical( { samples, radius, size, shadowPass: shadowPassVertical } ).context( builder.getSharedContext() );
  				material.name = 'VSMVertical';

  				material = this.vsmMaterialHorizontal || ( this.vsmMaterialHorizontal = new NodeMaterial() );
  				material.fragmentNode = VSMPassHorizontal( { samples, radius, size, shadowPass: shadowPassHorizontal } ).context( builder.getSharedContext() );
  				material.name = 'VSMHorizontal';

  			}

  			//

  			const shadowIntensity = reference( 'intensity', 'float', shadow ).setGroup( renderGroup );
  			const bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );
  			const normalBias = reference( 'normalBias', 'float', shadow ).setGroup( renderGroup );

  			const position = object.material.shadowPositionNode || positionWorld;

  			let shadowCoord = uniform( shadow.matrix ).setGroup( renderGroup ).mul( position.add( normalWorld.mul( normalBias ) ) );
  			shadowCoord = shadowCoord.xyz.div( shadowCoord.w );

  			let coordZ = shadowCoord.z.add( bias );

  			if ( renderer.coordinateSystem === WebGPUCoordinateSystem ) {

  				coordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]

  			}

  			shadowCoord = vec3(
  				shadowCoord.x,
  				shadowCoord.y.oneMinus(), // follow webgpu standards
  				coordZ
  			);

  			const frustumTest = shadowCoord.x.greaterThanEqual( 0 )
  				.and( shadowCoord.x.lessThanEqual( 1 ) )
  				.and( shadowCoord.y.greaterThanEqual( 0 ) )
  				.and( shadowCoord.y.lessThanEqual( 1 ) )
  				.and( shadowCoord.z.lessThanEqual( 1 ) );

  			//

  			const filterFn = shadow.filterNode || _shadowFilterLib[ renderer.shadowMap.type ] || null;

  			if ( filterFn === null ) {

  				throw new Error( 'THREE.WebGPURenderer: Shadow map type not supported yet.' );

  			}

  			const shadowColor = texture( shadowMap.texture, shadowCoord );
  			const shadowNode = frustumTest.select( filterFn( { depthTexture: ( shadowMapType === VSMShadowMap ) ? this.vsmShadowMapHorizontal.texture : depthTexture, shadowCoord, shadow } ), float( 1 ) );

  			this.shadowMap = shadowMap;
  			this.light.shadow.map = shadowMap;

  			this.shadowNode = shadowNode;
  			this.shadowColorNode = shadowColorNode = this.colorNode.mul( mix$2( 1, shadowNode.rgb.mix( shadowColor, 1 ), shadowIntensity.mul( shadowColor.a ) ) );

  			this.baseColorNode = this.colorNode;

  		}

  		//

  		this.colorNode = shadowColorNode;

  		this.updateBeforeType = NodeUpdateType.RENDER;

  	}

  	setup( builder ) {

  		this.colorNode = this.baseColorNode || this.colorNode;

  		if ( this.light.castShadow ) {

  			if ( builder.object.receiveShadow ) {

  				this.setupShadow( builder );

  			}

  		} else if ( this.shadowNode !== null ) {

  			this.disposeShadow();

  		}

  	}

  	updateShadow( frame ) {

  		const { shadowMap, light } = this;
  		const { renderer, scene, camera } = frame;

  		const shadowType = renderer.shadowMap.type;

  		const depthVersion = shadowMap.depthTexture.version;
  		this._depthVersionCached = depthVersion;

  		const currentOverrideMaterial = scene.overrideMaterial;

  		scene.overrideMaterial = _overrideMaterial;

  		shadowMap.setSize( light.shadow.mapSize.width, light.shadow.mapSize.height );

  		light.shadow.updateMatrices( light );
  		light.shadow.camera.layers.mask = camera.layers.mask;

  		const currentRenderTarget = renderer.getRenderTarget();
  		const currentRenderObjectFunction = renderer.getRenderObjectFunction();

  		renderer.setRenderObjectFunction( ( object, ...params ) => {

  			if ( object.castShadow === true || ( object.receiveShadow && shadowType === VSMShadowMap ) ) {

  				renderer.renderObject( object, ...params );

  			}

  		} );

  		renderer.setRenderTarget( shadowMap );
  		renderer.render( scene, light.shadow.camera );

  		renderer.setRenderObjectFunction( currentRenderObjectFunction );

  		// vsm blur pass

  		if ( light.isPointLight !== true && shadowType === VSMShadowMap ) {

  			this.vsmPass( frame, light );

  		}

  		renderer.setRenderTarget( currentRenderTarget );

  		scene.overrideMaterial = currentOverrideMaterial;

  	}

  	vsmPass( frame, light ) {

  		const { renderer } = frame;

  		this.vsmShadowMapVertical.setSize( light.shadow.mapSize.width, light.shadow.mapSize.height );
  		this.vsmShadowMapHorizontal.setSize( light.shadow.mapSize.width, light.shadow.mapSize.height );

  		renderer.setRenderTarget( this.vsmShadowMapVertical );
  		_quadMesh$1.material = this.vsmMaterialVertical;
  		_quadMesh$1.render( renderer );

  		renderer.setRenderTarget( this.vsmShadowMapHorizontal );
  		_quadMesh$1.material = this.vsmMaterialHorizontal;
  		_quadMesh$1.render( renderer );

  	}

  	disposeShadow() {

  		this.shadowMap.dispose();
  		this.shadowMap = null;

  		if ( this.vsmShadowMapVertical !== null ) {

  			this.vsmShadowMapVertical.dispose();
  			this.vsmShadowMapVertical = null;

  			this.vsmMaterialVertical.dispose();
  			this.vsmMaterialVertical = null;

  		}

  		if ( this.vsmShadowMapHorizontal !== null ) {

  			this.vsmShadowMapHorizontal.dispose();
  			this.vsmShadowMapHorizontal = null;

  			this.vsmMaterialHorizontal.dispose();
  			this.vsmMaterialHorizontal = null;

  		}

  		this.shadowNode = null;
  		this.shadowColorNode = null;

  		this.baseColorNode = null;

  		this.updateBeforeType = NodeUpdateType.NONE;

  	}

  	updateBefore( frame ) {

  		const shadow = this.light.shadow;

  		const needsUpdate = shadow.needsUpdate || shadow.autoUpdate;

  		if ( needsUpdate ) {

  			this.updateShadow( frame );

  			if ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {

  				shadow.needsUpdate = false;

  			}

  		}

  	}

  	update( /*frame*/ ) {

  		const { light } = this;

  		this.color.copy( light.color ).multiplyScalar( light.intensity );

  	}

  }

  const getDistanceAttenuation = /*@__PURE__*/ Fn( ( inputs ) => {

  	const { lightDistance, cutoffDistance, decayExponent } = inputs;

  	// based upon Frostbite 3 Moving to Physically-based Rendering
  	// page 32, equation 26: E[window1]
  	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  	const distanceFalloff = lightDistance.pow( decayExponent ).max( 0.01 ).reciprocal();

  	return cutoffDistance.greaterThan( 0 ).select(
  		distanceFalloff.mul( lightDistance.div( cutoffDistance ).pow4().oneMinus().clamp().pow2() ),
  		distanceFalloff
  	);

  } ); // validated

  let uniformsLib;

  function getLightData( light ) {

  	uniformsLib = uniformsLib || new WeakMap();

  	let uniforms = uniformsLib.get( light );

  	if ( uniforms === undefined ) uniformsLib.set( light, uniforms = {} );

  	return uniforms;

  }

  function lightPosition( light ) {

  	const data = getLightData( light );

  	return data.position || ( data.position = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.matrixWorld ) ) );

  }

  function lightTargetPosition( light ) {

  	const data = getLightData( light );

  	return data.targetPosition || ( data.targetPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.target.matrixWorld ) ) );

  }

  function lightViewPosition( light ) {

  	const data = getLightData( light );

  	return data.viewPosition || ( data.viewPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => {

  		self.value = self.value || new Vector3();
  		self.value.setFromMatrixPosition( light.matrixWorld );

  		self.value.applyMatrix4( camera.matrixWorldInverse );

  	} ) );

  }

  const lightTargetDirection = ( light ) => cameraViewMatrix.transformDirection( lightPosition( light ).sub( lightTargetPosition( light ) ) );

  const sRGBToLinearSRGB = /*@__PURE__*/ Fn( ( [ color ] ) => {

  	const a = color.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );
  	const b = color.mul( 0.0773993808 );
  	const factor = color.lessThanEqual( 0.04045 );

  	const rgbResult = mix$2( a, b, factor );

  	return rgbResult;

  } ).setLayout( {
  	name: 'sRGBToLinearSRGB',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' }
  	]
  } );

  const linearSRGBTosRGB = /*@__PURE__*/ Fn( ( [ color ] ) => {

  	const a = color.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );
  	const b = color.mul( 12.92 );
  	const factor = color.lessThanEqual( 0.0031308 );

  	const rgbResult = mix$2( a, b, factor );

  	return rgbResult;

  } ).setLayout( {
  	name: 'linearSRGBTosRGB',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' }
  	]
  } );

  // exposure only

  const linearToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	return color.mul( exposure ).clamp();

  } ).setLayout( {
  	name: 'linearToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  // source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf

  const reinhardToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	color = color.mul( exposure );

  	return color.div( color.add( 1.0 ) ).clamp();

  } ).setLayout( {
  	name: 'reinhardToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  // source: http://filmicworlds.com/blog/filmic-tonemapping-operators/

  const cineonToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	// filmic operator by Jim Hejl and Richard Burgess-Dawson
  	color = color.mul( exposure );
  	color = color.sub( 0.004 ).max( 0.0 );

  	const a = color.mul( color.mul( 6.2 ).add( 0.5 ) );
  	const b = color.mul( color.mul( 6.2 ).add( 1.7 ) ).add( 0.06 );

  	return a.div( b ).pow( 2.2 );

  } ).setLayout( {
  	name: 'cineonToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  // source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs

  const RRTAndODTFit = /*@__PURE__*/ Fn( ( [ color ] ) => {

  	const a = color.mul( color.add( 0.0245786 ) ).sub( 0.000090537 );
  	const b = color.mul( color.add( 0.4329510 ).mul( 0.983729 ) ).add( 0.238081 );

  	return a.div( b );

  } );

  // source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs

  const acesFilmicToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
  	const ACESInputMat = mat3(
  		0.59719, 0.35458, 0.04823,
  		0.07600, 0.90834, 0.01566,
  		0.02840, 0.13383, 0.83777
  	);

  	// ODT_SAT => XYZ => D60_2_D65 => sRGB
  	const ACESOutputMat = mat3(
  		1.60475, - 0.53108, - 0.07367,
  		- 0.10208, 1.10813, - 0.00605,
  		- 0.00327, - 0.07276, 1.07602
  	);

  	color = color.mul( exposure ).div( 0.6 );

  	color = ACESInputMat.mul( color );

  	// Apply RRT and ODT
  	color = RRTAndODTFit( color );

  	color = ACESOutputMat.mul( color );

  	// Clamp to [0, 1]
  	return color.clamp();

  } ).setLayout( {
  	name: 'acesFilmicToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  const LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/ mat3( vec3( 1.6605, - 0.1246, - 0.0182 ), vec3( - 0.5876, 1.1329, - 0.1006 ), vec3( - 0.0728, - 0.0083, 1.1187 ) );
  const LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/ mat3( vec3( 0.6274, 0.0691, 0.0164 ), vec3( 0.3293, 0.9195, 0.0880 ), vec3( 0.0433, 0.0113, 0.8956 ) );

  const agxDefaultContrastApprox = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {

  	const x = vec3( x_immutable ).toVar();
  	const x2 = vec3( x.mul( x ) ).toVar();
  	const x4 = vec3( x2.mul( x2 ) ).toVar();

  	return float( 15.5 ).mul( x4.mul( x2 ) ).sub( mul( 40.14, x4.mul( x ) ) ).add( mul( 31.96, x4 ).sub( mul( 6.868, x2.mul( x ) ) ).add( mul( 0.4298, x2 ).add( mul( 0.1191, x ).sub( 0.00232 ) ) ) );

  } );

  const agxToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	const colortone = vec3( color ).toVar();
  	const AgXInsetMatrix = mat3( vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ), vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ), vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 ) );
  	const AgXOutsetMatrix = mat3( vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ), vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ), vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 ) );
  	const AgxMinEv = float( - 12.47393 );
  	const AgxMaxEv = float( 4.026069 );
  	colortone.mulAssign( exposure );
  	colortone.assign( LINEAR_SRGB_TO_LINEAR_REC2020.mul( colortone ) );
  	colortone.assign( AgXInsetMatrix.mul( colortone ) );
  	colortone.assign( max$1( colortone, 1e-10 ) );
  	colortone.assign( log2( colortone ) );
  	colortone.assign( colortone.sub( AgxMinEv ).div( AgxMaxEv.sub( AgxMinEv ) ) );
  	colortone.assign( clamp( colortone, 0.0, 1.0 ) );
  	colortone.assign( agxDefaultContrastApprox( colortone ) );
  	colortone.assign( AgXOutsetMatrix.mul( colortone ) );
  	colortone.assign( pow( max$1( vec3( 0.0 ), colortone ), vec3( 2.2 ) ) );
  	colortone.assign( LINEAR_REC2020_TO_LINEAR_SRGB.mul( colortone ) );
  	colortone.assign( clamp( colortone, 0.0, 1.0 ) );

  	return colortone;

  } ).setLayout( {
  	name: 'agxToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  // https://modelviewer.dev/examples/tone-mapping

  const neutralToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

  	const StartCompression = float( 0.8 - 0.04 );
  	const Desaturation = float( 0.15 );

  	color = color.mul( exposure );

  	const x = min$1( color.r, min$1( color.g, color.b ) );
  	const offset = select( x.lessThan( 0.08 ), x.sub( mul( 6.25, x.mul( x ) ) ), 0.04 );

  	color.subAssign( offset );

  	const peak = max$1( color.r, max$1( color.g, color.b ) );

  	If( peak.lessThan( StartCompression ), () => {

  		return color;

  	} );

  	const d = sub( 1, StartCompression );
  	const newPeak = sub( 1, d.mul( d ).div( peak.add( d.sub( StartCompression ) ) ) );
  	color.mulAssign( newPeak.div( peak ) );
  	const g = sub( 1, div( 1, Desaturation.mul( peak.sub( newPeak ) ).add( 1 ) ) );

  	return mix$2( color, vec3( newPeak ), g );

  } ).setLayout( {
  	name: 'neutralToneMapping',
  	type: 'vec3',
  	inputs: [
  		{ name: 'color', type: 'vec3' },
  		{ name: 'exposure', type: 'float' }
  	]
  } );

  class BarrierNode extends Node {

  	constructor( scope ) {

  		super();

  		this.scope = scope;

  	}

  	generate( builder ) {

  		const { scope } = this;
  		const { renderer } = builder;

  		if ( renderer.backend.isWebGLBackend === true ) {

  			builder.addFlowCode( `\t// ${scope}Barrier \n` );

  		} else {

  			builder.addLineFlowCode( `${scope}Barrier()`, this );

  		}

  	}

  }

  nodeProxy( BarrierNode );

  class AtomicFunctionNode extends TempNode {

  	static get type() {

  		return 'AtomicFunctionNode';

  	}

  	constructor( method, pointerNode, valueNode, storeNode = null ) {

  		super( 'uint' );

  		this.method = method;

  		this.pointerNode = pointerNode;
  		this.valueNode = valueNode;
  		this.storeNode = storeNode;

  	}

  	getInputType( builder ) {

  		return this.pointerNode.getNodeType( builder );

  	}

  	getNodeType( builder ) {

  		return this.getInputType( builder );

  	}

  	generate( builder ) {

  		const method = this.method;

  		const type = this.getNodeType( builder );
  		const inputType = this.getInputType( builder );

  		const a = this.pointerNode;
  		const b = this.valueNode;

  		const params = [];

  		params.push( `&${ a.build( builder, inputType ) }` );
  		params.push( b.build( builder, inputType ) );

  		const methodSnippet = `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`;

  		if ( this.storeNode !== null ) {

  			const varSnippet = this.storeNode.build( builder, inputType );

  			builder.addLineFlowCode( `${varSnippet} = ${methodSnippet}`, this );

  		} else {

  			builder.addLineFlowCode( methodSnippet, this );

  		}

  	}

  }

  AtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';
  AtomicFunctionNode.ATOMIC_STORE = 'atomicStore';
  AtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';
  AtomicFunctionNode.ATOMIC_SUB = 'atomicSub';
  AtomicFunctionNode.ATOMIC_MAX = 'atomicMax';
  AtomicFunctionNode.ATOMIC_MIN = 'atomicMin';
  AtomicFunctionNode.ATOMIC_AND = 'atomicAnd';
  AtomicFunctionNode.ATOMIC_OR = 'atomicOr';
  AtomicFunctionNode.ATOMIC_XOR = 'atomicXor';

  nodeProxy( AtomicFunctionNode );

  const getShIrradianceAt = /*@__PURE__*/ Fn( ( [ normal, shCoefficients ] ) => {

  	// normal is assumed to have unit length

  	const x = normal.x, y = normal.y, z = normal.z;

  	// band 0
  	let result = shCoefficients.element( 0 ).mul( 0.886227 );

  	// band 1
  	result = result.add( shCoefficients.element( 1 ).mul( 2.0 * 0.511664 ).mul( y ) );
  	result = result.add( shCoefficients.element( 2 ).mul( 2.0 * 0.511664 ).mul( z ) );
  	result = result.add( shCoefficients.element( 3 ).mul( 2.0 * 0.511664 ).mul( x ) );

  	// band 2
  	result = result.add( shCoefficients.element( 4 ).mul( 2.0 * 0.429043 ).mul( x ).mul( y ) );
  	result = result.add( shCoefficients.element( 5 ).mul( 2.0 * 0.429043 ).mul( y ).mul( z ) );
  	result = result.add( shCoefficients.element( 6 ).mul( z.mul( z ).mul( 0.743125 ).sub( 0.247708 ) ) );
  	result = result.add( shCoefficients.element( 7 ).mul( 2.0 * 0.429043 ).mul( x ).mul( z ) );
  	result = result.add( shCoefficients.element( 8 ).mul( 0.429043 ).mul( mul( x, x ).sub( mul( y, y ) ) ) );

  	return result;

  } );

  class PointLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'PointLightNode';

  	}

  	constructor( light = null ) {

  		super( light );

  		this.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );
  		this.decayExponentNode = uniform( 0 ).setGroup( renderGroup );

  	}

  	update( frame ) {

  		const { light } = this;

  		super.update( frame );

  		this.cutoffDistanceNode.value = light.distance;
  		this.decayExponentNode.value = light.decay;

  	}

  	setup( builder ) {

  		const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;

  		const lightingModel = builder.context.lightingModel;

  		const lVector = lightViewPosition( light ).sub( positionView ); // @TODO: Add it into LightNode

  		const lightDirection = lVector.normalize();
  		const lightDistance = lVector.length();

  		const lightAttenuation = getDistanceAttenuation( {
  			lightDistance,
  			cutoffDistance: cutoffDistanceNode,
  			decayExponent: decayExponentNode
  		} );

  		const lightColor = colorNode.mul( lightAttenuation );

  		const reflectedLight = builder.context.reflectedLight;

  		lightingModel.direct( {
  			lightDirection,
  			lightColor,
  			reflectedLight
  		}, builder.stack, builder );

  	}

  }

  class DirectionalLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'DirectionalLightNode';

  	}

  	constructor( light = null ) {

  		super( light );

  	}

  	setup( builder ) {

  		super.setup( builder );

  		const lightingModel = builder.context.lightingModel;

  		const lightColor = this.colorNode;
  		const lightDirection = lightTargetDirection( this.light );
  		const reflectedLight = builder.context.reflectedLight;

  		lightingModel.direct( {
  			lightDirection,
  			lightColor,
  			reflectedLight
  		}, builder.stack, builder );

  	}

  }

  const _matrix41 = /*@__PURE__*/ new Matrix4();
  const _matrix42 = /*@__PURE__*/ new Matrix4();

  let ltcLib = null;

  class RectAreaLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'RectAreaLightNode';

  	}

  	constructor( light = null ) {

  		super( light );

  		this.halfHeight = uniform( new Vector3() ).setGroup( renderGroup );
  		this.halfWidth = uniform( new Vector3() ).setGroup( renderGroup );

  	}

  	update( frame ) {

  		super.update( frame );

  		const { light } = this;

  		const viewMatrix = frame.camera.matrixWorldInverse;

  		_matrix42.identity();
  		_matrix41.copy( light.matrixWorld );
  		_matrix41.premultiply( viewMatrix );
  		_matrix42.extractRotation( _matrix41 );

  		this.halfWidth.value.set( light.width * 0.5, 0.0, 0.0 );
  		this.halfHeight.value.set( 0.0, light.height * 0.5, 0.0 );

  		this.halfWidth.value.applyMatrix4( _matrix42 );
  		this.halfHeight.value.applyMatrix4( _matrix42 );

  	}

  	setup( builder ) {

  		super.setup( builder );

  		let ltc_1, ltc_2;

  		if ( builder.isAvailable( 'float32Filterable' ) ) {

  			ltc_1 = texture( ltcLib.LTC_FLOAT_1 );
  			ltc_2 = texture( ltcLib.LTC_FLOAT_2 );

  		} else {

  			ltc_1 = texture( ltcLib.LTC_HALF_1 );
  			ltc_2 = texture( ltcLib.LTC_HALF_2 );

  		}

  		const { colorNode, light } = this;
  		const lightingModel = builder.context.lightingModel;

  		const lightPosition = lightViewPosition( light );
  		const reflectedLight = builder.context.reflectedLight;

  		lightingModel.directRectArea( {
  			lightColor: colorNode,
  			lightPosition,
  			halfWidth: this.halfWidth,
  			halfHeight: this.halfHeight,
  			reflectedLight,
  			ltc_1,
  			ltc_2
  		}, builder.stack, builder );

  	}

  	static setLTC( ltc ) {

  		ltcLib = ltc;

  	}

  }

  class SpotLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'SpotLightNode';

  	}

  	constructor( light = null ) {

  		super( light );

  		this.coneCosNode = uniform( 0 ).setGroup( renderGroup );
  		this.penumbraCosNode = uniform( 0 ).setGroup( renderGroup );

  		this.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );
  		this.decayExponentNode = uniform( 0 ).setGroup( renderGroup );

  	}

  	update( frame ) {

  		super.update( frame );

  		const { light } = this;

  		this.coneCosNode.value = Math.cos( light.angle );
  		this.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );

  		this.cutoffDistanceNode.value = light.distance;
  		this.decayExponentNode.value = light.decay;

  	}

  	getSpotAttenuation( angleCosine ) {

  		const { coneCosNode, penumbraCosNode } = this;

  		return smoothstep( coneCosNode, penumbraCosNode, angleCosine );

  	}

  	setup( builder ) {

  		super.setup( builder );

  		const lightingModel = builder.context.lightingModel;

  		const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;

  		const lVector = lightViewPosition( light ).sub( positionView ); // @TODO: Add it into LightNode

  		const lightDirection = lVector.normalize();
  		const angleCos = lightDirection.dot( lightTargetDirection( light ) );
  		const spotAttenuation = this.getSpotAttenuation( angleCos );

  		const lightDistance = lVector.length();

  		const lightAttenuation = getDistanceAttenuation( {
  			lightDistance,
  			cutoffDistance: cutoffDistanceNode,
  			decayExponent: decayExponentNode
  		} );

  		const lightColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );

  		const reflectedLight = builder.context.reflectedLight;

  		lightingModel.direct( {
  			lightDirection,
  			lightColor,
  			reflectedLight
  		}, builder.stack, builder );

  	}

  }

  class IESSpotLightNode extends SpotLightNode {

  	static get type() {

  		return 'IESSpotLightNode';

  	}

  	getSpotAttenuation( angleCosine ) {

  		const iesMap = this.light.iesMap;

  		let spotAttenuation = null;

  		if ( iesMap && iesMap.isTexture === true ) {

  			const angle = angleCosine.acos().mul( 1.0 / Math.PI );

  			spotAttenuation = texture( iesMap, vec2( angle, 0 ), 0 ).r;

  		} else {

  			spotAttenuation = super.getSpotAttenuation( angleCosine );

  		}

  		return spotAttenuation;

  	}

  }

  class AmbientLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'AmbientLightNode';

  	}

  	constructor( light = null ) {

  		super( light );

  	}

  	setup( { context } ) {

  		context.irradiance.addAssign( this.colorNode );

  	}

  }

  class HemisphereLightNode extends AnalyticLightNode {

  	static get type() {

  		return 'HemisphereLightNode';

  	}

  	constructor( light = null ) {

  		super( light );

  		this.lightPositionNode = lightPosition( light );
  		this.lightDirectionNode = this.lightPositionNode.normalize();

  		this.groundColorNode = uniform( new Color() ).setGroup( renderGroup );

  	}

  	update( frame ) {

  		const { light } = this;

  		super.update( frame );

  		this.lightPositionNode.object3d = light;

  		this.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );

  	}

  	setup( builder ) {

  		const { colorNode, groundColorNode, lightDirectionNode } = this;

  		const dotNL = normalView.dot( lightDirectionNode );
  		const hemiDiffuseWeight = dotNL.mul( 0.5 ).add( 0.5 );

  		const irradiance = mix$2( groundColorNode, colorNode, hemiDiffuseWeight );

  		builder.context.irradiance.addAssign( irradiance );

  	}

  }

  class LightProbeNode extends AnalyticLightNode {

  	static get type() {

  		return 'LightProbeNode';

  	}

  	constructor( light = null ) {

  		super( light );

  		const array = [];

  		for ( let i = 0; i < 9; i ++ ) array.push( new Vector3() );

  		this.lightProbe = uniformArray( array );

  	}

  	update( frame ) {

  		const { light } = this;

  		super.update( frame );

  		//

  		for ( let i = 0; i < 9; i ++ ) {

  			this.lightProbe.array[ i ].copy( light.sh.coefficients[ i ] ).multiplyScalar( light.intensity );

  		}

  	}

  	setup( builder ) {

  		const irradiance = getShIrradianceAt( normalWorld, this.lightProbe );

  		builder.context.irradiance.addAssign( irradiance );

  	}

  }

  class NodeParser {

  	parseFunction( /*source*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  }

  class NodeFunction {

  	constructor( type, inputs, name = '', precision = '' ) {

  		this.type = type;
  		this.inputs = inputs;
  		this.name = name;
  		this.precision = precision;

  	}

  	getCode( /*name = this.name*/ ) {

  		console.warn( 'Abstract function.' );

  	}

  }

  NodeFunction.isNodeFunction = true;

  const declarationRegexp$1 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
  const propertiesRegexp$1 = /[a-z_0-9]+/ig;

  const pragmaMain = '#pragma main';

  const parse$1 = ( source ) => {

  	source = source.trim();

  	const pragmaMainIndex = source.indexOf( pragmaMain );

  	const mainCode = pragmaMainIndex !== - 1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;

  	const declaration = mainCode.match( declarationRegexp$1 );

  	if ( declaration !== null && declaration.length === 5 ) {

  		// tokenizer

  		const inputsCode = declaration[ 4 ];
  		const propsMatches = [];

  		let nameMatch = null;

  		while ( ( nameMatch = propertiesRegexp$1.exec( inputsCode ) ) !== null ) {

  			propsMatches.push( nameMatch );

  		}

  		// parser

  		const inputs = [];

  		let i = 0;

  		while ( i < propsMatches.length ) {

  			const isConst = propsMatches[ i ][ 0 ] === 'const';

  			if ( isConst === true ) {

  				i ++;

  			}

  			let qualifier = propsMatches[ i ][ 0 ];

  			if ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {

  				i ++;

  			} else {

  				qualifier = '';

  			}

  			const type = propsMatches[ i ++ ][ 0 ];

  			let count = Number.parseInt( propsMatches[ i ][ 0 ] );

  			if ( Number.isNaN( count ) === false ) i ++;
  			else count = null;

  			const name = propsMatches[ i ++ ][ 0 ];

  			inputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );

  		}

  		//

  		const blockCode = mainCode.substring( declaration[ 0 ].length );

  		const name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';
  		const type = declaration[ 2 ];

  		const precision = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';

  		const headerCode = pragmaMainIndex !== - 1 ? source.slice( 0, pragmaMainIndex ) : '';

  		return {
  			type,
  			inputs,
  			name,
  			precision,
  			inputsCode,
  			blockCode,
  			headerCode
  		};

  	} else {

  		throw new Error( 'FunctionNode: Function is not a GLSL code.' );

  	}

  };

  class GLSLNodeFunction extends NodeFunction {

  	constructor( source ) {

  		const { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1( source );

  		super( type, inputs, name, precision );

  		this.inputsCode = inputsCode;
  		this.blockCode = blockCode;
  		this.headerCode = headerCode;

  	}

  	getCode( name = this.name ) {

  		let code;

  		const blockCode = this.blockCode;

  		if ( blockCode !== '' ) {

  			const { type, inputsCode, headerCode, precision } = this;

  			let declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;

  			if ( precision !== '' ) {

  				declarationCode = `${ precision } ${ declarationCode }`;

  			}

  			code = headerCode + declarationCode + blockCode;

  		} else {

  			// interface function

  			code = '';

  		}

  		return code;

  	}

  }

  class GLSLNodeParser extends NodeParser {

  	parseFunction( source ) {

  		return new GLSLNodeFunction( source );

  	}

  }

  function painterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.material.id !== b.material.id ) {

  		return a.material.id - b.material.id;

  	} else if ( a.z !== b.z ) {

  		return a.z - b.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  function reversePainterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.z !== b.z ) {

  		return b.z - a.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  class RenderList {

  	constructor() {

  		this.renderItems = [];
  		this.renderItemsIndex = 0;

  		this.opaque = [];
  		this.transparent = [];
  		this.bundles = [];

  		this.lightsNode = new LightsNode( [] );
  		this.lightsArray = [];

  		this.occlusionQueryCount = 0;

  	}

  	begin() {

  		this.renderItemsIndex = 0;

  		this.opaque.length = 0;
  		this.transparent.length = 0;
  		this.bundles.length = 0;

  		this.lightsArray.length = 0;

  		this.occlusionQueryCount = 0;

  		return this;

  	}

  	getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

  		let renderItem = this.renderItems[ this.renderItemsIndex ];

  		if ( renderItem === undefined ) {

  			renderItem = {
  				id: object.id,
  				object: object,
  				geometry: geometry,
  				material: material,
  				groupOrder: groupOrder,
  				renderOrder: object.renderOrder,
  				z: z,
  				group: group
  			};

  			this.renderItems[ this.renderItemsIndex ] = renderItem;

  		} else {

  			renderItem.id = object.id;
  			renderItem.object = object;
  			renderItem.geometry = geometry;
  			renderItem.material = material;
  			renderItem.groupOrder = groupOrder;
  			renderItem.renderOrder = object.renderOrder;
  			renderItem.z = z;
  			renderItem.group = group;

  		}

  		this.renderItemsIndex ++;

  		return renderItem;

  	}

  	push( object, geometry, material, groupOrder, z, group ) {

  		const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group );

  		if ( object.occlusionTest === true ) this.occlusionQueryCount ++;

  		( material.transparent === true || material.transmission > 0 ? this.transparent : this.opaque ).push( renderItem );

  	}

  	unshift( object, geometry, material, groupOrder, z, group ) {

  		const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group );

  		( material.transparent === true ? this.transparent : this.opaque ).unshift( renderItem );

  	}

  	pushBundle( group ) {

  		this.bundles.push( group );

  	}

  	pushLight( light ) {

  		this.lightsArray.push( light );

  	}

  	getLightsNode() {

  		return this.lightsNode.fromLights( this.lightsArray );

  	}

  	sort( customOpaqueSort, customTransparentSort ) {

  		if ( this.opaque.length > 1 ) this.opaque.sort( customOpaqueSort || painterSortStable );
  		if ( this.transparent.length > 1 ) this.transparent.sort( customTransparentSort || reversePainterSortStable );

  	}

  	finish() {

  		// update lights

  		this.lightsNode.setLights( this.lightsArray );

  		// Clear references from inactive renderItems in the list

  		for ( let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i ++ ) {

  			const renderItem = this.renderItems[ i ];

  			if ( renderItem.id === null ) break;

  			renderItem.id = null;
  			renderItem.object = null;
  			renderItem.geometry = null;
  			renderItem.material = null;
  			renderItem.groupOrder = null;
  			renderItem.renderOrder = null;
  			renderItem.z = null;
  			renderItem.group = null;

  		}

  	}

  }

  class RenderLists {

  	constructor() {

  		this.lists = new ChainMap();

  	}

  	get( scene, camera ) {

  		const lists = this.lists;
  		const keys = [ scene, camera ];

  		let list = lists.get( keys );

  		if ( list === undefined ) {

  			list = new RenderList();
  			lists.set( keys, list );

  		}

  		return list;

  	}

  	dispose() {

  		this.lists = new ChainMap();

  	}

  }

  let id = 0;

  class RenderContext {

  	constructor() {

  		this.id = id ++;

  		this.color = true;
  		this.clearColor = true;
  		this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };

  		this.depth = true;
  		this.clearDepth = true;
  		this.clearDepthValue = 1;

  		this.stencil = false;
  		this.clearStencil = true;
  		this.clearStencilValue = 1;

  		this.viewport = false;
  		this.viewportValue = new Vector4();

  		this.scissor = false;
  		this.scissorValue = new Vector4();

  		this.textures = null;
  		this.depthTexture = null;
  		this.activeCubeFace = 0;
  		this.sampleCount = 1;

  		this.width = 0;
  		this.height = 0;

  		this.isRenderContext = true;

  	}

  	getCacheKey() {

  		return getCacheKey( this );

  	}

  }

  function getCacheKey( renderContext ) {

  	const { textures, activeCubeFace } = renderContext;

  	const values = [ activeCubeFace ];

  	for ( const texture of textures ) {

  		values.push( texture.id );

  	}

  	return hashArray( values );

  }

  class RenderContexts {

  	constructor() {

  		this.chainMaps = {};

  	}

  	get( scene, camera, renderTarget = null ) {

  		const chainKey = [ scene, camera ];

  		let attachmentState;

  		if ( renderTarget === null ) {

  			attachmentState = 'default';

  		} else {

  			const format = renderTarget.texture.format;
  			const count = renderTarget.textures.length;

  			attachmentState = `${ count }:${ format }:${ renderTarget.samples }:${ renderTarget.depthBuffer }:${ renderTarget.stencilBuffer }`;

  		}

  		const chainMap = this.getChainMap( attachmentState );

  		let renderState = chainMap.get( chainKey );

  		if ( renderState === undefined ) {

  			renderState = new RenderContext();

  			chainMap.set( chainKey, renderState );

  		}

  		if ( renderTarget !== null ) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;

  		return renderState;

  	}

  	getChainMap( attachmentState ) {

  		return this.chainMaps[ attachmentState ] || ( this.chainMaps[ attachmentState ] = new ChainMap() );

  	}

  	dispose() {

  		this.chainMaps = {};

  	}

  }

  const _size = /*@__PURE__*/ new Vector3();

  class Textures extends DataMap {

  	constructor( renderer, backend, info ) {

  		super();

  		this.renderer = renderer;
  		this.backend = backend;
  		this.info = info;

  	}

  	updateRenderTarget( renderTarget, activeMipmapLevel = 0 ) {

  		const renderTargetData = this.get( renderTarget );

  		const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
  		const depthTextureMips = renderTargetData.depthTextureMips || ( renderTargetData.depthTextureMips = {} );

  		const textures = renderTarget.textures;

  		const size = this.getSize( textures[ 0 ] );

  		const mipWidth = size.width >> activeMipmapLevel;
  		const mipHeight = size.height >> activeMipmapLevel;

  		let depthTexture = renderTarget.depthTexture || depthTextureMips[ activeMipmapLevel ];
  		let textureNeedsUpdate = false;

  		if ( depthTexture === undefined ) {

  			depthTexture = new DepthTexture();
  			depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;
  			depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType
  			depthTexture.image.width = mipWidth;
  			depthTexture.image.height = mipHeight;

  			depthTextureMips[ activeMipmapLevel ] = depthTexture;

  		}

  		if ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {

  			textureNeedsUpdate = true;
  			depthTexture.needsUpdate = true;

  			depthTexture.image.width = mipWidth;
  			depthTexture.image.height = mipHeight;

  		}

  		renderTargetData.width = size.width;
  		renderTargetData.height = size.height;
  		renderTargetData.textures = textures;
  		renderTargetData.depthTexture = depthTexture;
  		renderTargetData.depth = renderTarget.depthBuffer;
  		renderTargetData.stencil = renderTarget.stencilBuffer;
  		renderTargetData.renderTarget = renderTarget;

  		if ( renderTargetData.sampleCount !== sampleCount ) {

  			textureNeedsUpdate = true;
  			depthTexture.needsUpdate = true;

  			renderTargetData.sampleCount = sampleCount;

  		}

  		//

  		const options = { sampleCount };

  		for ( let i = 0; i < textures.length; i ++ ) {

  			const texture = textures[ i ];

  			if ( textureNeedsUpdate ) texture.needsUpdate = true;

  			this.updateTexture( texture, options );

  		}

  		this.updateTexture( depthTexture, options );

  		// dispose handler

  		if ( renderTargetData.initialized !== true ) {

  			renderTargetData.initialized = true;

  			// dispose

  			const onDispose = () => {

  				renderTarget.removeEventListener( 'dispose', onDispose );

  				for ( let i = 0; i < textures.length; i ++ ) {

  					this._destroyTexture( textures[ i ] );

  				}

  				this._destroyTexture( depthTexture );

  				this.delete( renderTarget );

  			};

  			renderTarget.addEventListener( 'dispose', onDispose );

  		}

  	}

  	updateTexture( texture, options = {} ) {

  		const textureData = this.get( texture );
  		if ( textureData.initialized === true && textureData.version === texture.version ) return;

  		const isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;
  		const backend = this.backend;

  		if ( isRenderTarget && textureData.initialized === true ) {

  			// it's an update

  			backend.destroySampler( texture );
  			backend.destroyTexture( texture );

  		}

  		//

  		if ( texture.isFramebufferTexture ) {

  			const renderer = this.renderer;
  			const renderTarget = renderer.getRenderTarget();

  			if ( renderTarget ) {

  				texture.type = renderTarget.texture.type;

  			} else {

  				texture.type = UnsignedByteType;

  			}

  		}

  		//

  		const { width, height, depth } = this.getSize( texture );

  		options.width = width;
  		options.height = height;
  		options.depth = depth;
  		options.needsMipmaps = this.needsMipmaps( texture );
  		options.levels = options.needsMipmaps ? this.getMipLevels( texture, width, height ) : 1;

  		//

  		if ( isRenderTarget || texture.isStorageTexture === true ) {

  			backend.createSampler( texture );
  			backend.createTexture( texture, options );

  			textureData.generation = texture.version;

  		} else {

  			const needsCreate = textureData.initialized !== true;

  			if ( needsCreate ) backend.createSampler( texture );

  			if ( texture.version > 0 ) {

  				const image = texture.image;

  				if ( image === undefined ) {

  					console.warn( 'THREE.Renderer: Texture marked for update but image is undefined.' );

  				} else if ( image.complete === false ) {

  					console.warn( 'THREE.Renderer: Texture marked for update but image is incomplete.' );

  				} else {

  					if ( texture.images ) {

  						const images = [];

  						for ( const image of texture.images ) {

  							images.push( image );

  						}

  						options.images = images;

  					} else {

  						options.image = image;

  					}

  					if ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {

  						backend.createTexture( texture, options );

  						textureData.isDefaultTexture = false;
  						textureData.generation = texture.version;

  					}

  					if ( texture.source.dataReady === true ) backend.updateTexture( texture, options );

  					if ( options.needsMipmaps && texture.mipmaps.length === 0 ) backend.generateMipmaps( texture );

  				}

  			} else {

  				// async update

  				backend.createDefaultTexture( texture );

  				textureData.isDefaultTexture = true;
  				textureData.generation = texture.version;

  			}

  		}

  		// dispose handler

  		if ( textureData.initialized !== true ) {

  			textureData.initialized = true;
  			textureData.generation = texture.version;

  			//

  			this.info.memory.textures ++;

  			// dispose

  			const onDispose = () => {

  				texture.removeEventListener( 'dispose', onDispose );

  				this._destroyTexture( texture );

  				this.info.memory.textures --;

  			};

  			texture.addEventListener( 'dispose', onDispose );

  		}

  		//

  		textureData.version = texture.version;

  	}

  	getSize( texture, target = _size ) {

  		let image = texture.images ? texture.images[ 0 ] : texture.image;

  		if ( image ) {

  			if ( image.image !== undefined ) image = image.image;

  			target.width = image.width;
  			target.height = image.height;
  			target.depth = texture.isCubeTexture ? 6 : ( image.depth || 1 );

  		} else {

  			target.width = target.height = target.depth = 1;

  		}

  		return target;

  	}

  	getMipLevels( texture, width, height ) {

  		let mipLevelCount;

  		if ( texture.isCompressedTexture ) {

  			mipLevelCount = texture.mipmaps.length;

  		} else {

  			mipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;

  		}

  		return mipLevelCount;

  	}

  	needsMipmaps( texture ) {

  		if ( this.isEnvironmentTexture( texture ) ) return true;

  		return ( texture.isCompressedTexture === true ) || ( ( texture.minFilter !== NearestFilter ) && ( texture.minFilter !== LinearFilter ) );

  	}

  	isEnvironmentTexture( texture ) {

  		const mapping = texture.mapping;

  		return ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

  	}

  	_destroyTexture( texture ) {

  		this.backend.destroySampler( texture );
  		this.backend.destroyTexture( texture );

  		this.delete( texture );

  	}

  }

  class Color4 extends Color {

  	constructor( r, g, b, a = 1 ) {

  		super( r, g, b );

  		this.a = a;

  	}

  	set( r, g, b, a = 1 ) {

  		this.a = a;

  		return super.set( r, g, b );

  	}

  	copy( color ) {

  		if ( color.a !== undefined ) this.a = color.a;

  		return super.copy( color );

  	}

  	clone() {

  		return new this.constructor( this.r, this.g, this.b, this.a );

  	}

  }

  const _clearColor = /*@__PURE__*/ new Color4();

  class Background extends DataMap {

  	constructor( renderer, nodes ) {

  		super();

  		this.renderer = renderer;
  		this.nodes = nodes;

  	}

  	update( scene, renderList, renderContext ) {

  		const renderer = this.renderer;
  		const background = this.nodes.getBackgroundNode( scene ) || scene.background;

  		let forceClear = false;

  		if ( background === null ) {

  			// no background settings, use clear color configuration from the renderer

  			renderer._clearColor.getRGB( _clearColor, LinearSRGBColorSpace );
  			_clearColor.a = renderer._clearColor.a;

  		} else if ( background.isColor === true ) {

  			// background is an opaque color

  			background.getRGB( _clearColor, LinearSRGBColorSpace );
  			_clearColor.a = 1;

  			forceClear = true;

  		} else if ( background.isNode === true ) {

  			const sceneData = this.get( scene );
  			const backgroundNode = background;

  			_clearColor.copy( renderer._clearColor );

  			let backgroundMesh = sceneData.backgroundMesh;

  			if ( backgroundMesh === undefined ) {

  				const backgroundMeshNode = context( vec4( backgroundNode ).mul( backgroundIntensity ), {
  					// @TODO: Add Texture2D support using node context
  					getUV: () => normalWorld,
  					getTextureLevel: () => backgroundBlurriness
  				} );

  				let viewProj = modelViewProjection();
  				viewProj = viewProj.setZ( viewProj.w );

  				const nodeMaterial = new NodeMaterial();
  				nodeMaterial.name = 'Background.material';
  				nodeMaterial.side = BackSide;
  				nodeMaterial.depthTest = false;
  				nodeMaterial.depthWrite = false;
  				nodeMaterial.fog = false;
  				nodeMaterial.lights = false;
  				nodeMaterial.vertexNode = viewProj;
  				nodeMaterial.colorNode = backgroundMeshNode;

  				sceneData.backgroundMeshNode = backgroundMeshNode;
  				sceneData.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );
  				backgroundMesh.frustumCulled = false;
  				backgroundMesh.name = 'Background.mesh';

  				backgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {

  					this.matrixWorld.copyPosition( camera.matrixWorld );

  				};

  			}

  			const backgroundCacheKey = backgroundNode.getCacheKey();

  			if ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {

  				sceneData.backgroundMeshNode.node = vec4( backgroundNode ).mul( backgroundIntensity );
  				sceneData.backgroundMeshNode.needsUpdate = true;

  				backgroundMesh.material.needsUpdate = true;

  				sceneData.backgroundCacheKey = backgroundCacheKey;

  			}

  			renderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null );

  		} else {

  			console.error( 'THREE.Renderer: Unsupported background configuration.', background );

  		}

  		//

  		if ( renderer.autoClear === true || forceClear === true ) {

  			_clearColor.multiplyScalar( _clearColor.a );

  			const clearColorValue = renderContext.clearColorValue;

  			clearColorValue.r = _clearColor.r;
  			clearColorValue.g = _clearColor.g;
  			clearColorValue.b = _clearColor.b;
  			clearColorValue.a = _clearColor.a;

  			renderContext.depthClearValue = renderer._clearDepth;
  			renderContext.stencilClearValue = renderer._clearStencil;

  			renderContext.clearColor = renderer.autoClearColor === true;
  			renderContext.clearDepth = renderer.autoClearDepth === true;
  			renderContext.clearStencil = renderer.autoClearStencil === true;

  		} else {

  			renderContext.clearColor = false;
  			renderContext.clearDepth = false;
  			renderContext.clearStencil = false;

  		}

  	}

  }

  class NodeBuilderState {

  	constructor( vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, monitor, transforms = [] ) {

  		this.vertexShader = vertexShader;
  		this.fragmentShader = fragmentShader;
  		this.computeShader = computeShader;
  		this.transforms = transforms;

  		this.nodeAttributes = nodeAttributes;
  		this.bindings = bindings;

  		this.updateNodes = updateNodes;
  		this.updateBeforeNodes = updateBeforeNodes;
  		this.updateAfterNodes = updateAfterNodes;

  		this.monitor = monitor;

  		this.usedTimes = 0;

  	}

  	createBindings() {

  		const bindings = [];

  		for ( const instanceGroup of this.bindings ) {

  			const shared = instanceGroup.bindings[ 0 ].groupNode.shared;

  			if ( shared !== true ) {

  				const bindingsGroup = new BindGroup( instanceGroup.name, [], instanceGroup.index, instanceGroup );
  				bindings.push( bindingsGroup );

  				for ( const instanceBinding of instanceGroup.bindings ) {

  					bindingsGroup.bindings.push( instanceBinding.clone() );

  				}

  			} else {

  				bindings.push( instanceGroup );

  			}

  		}

  		return bindings;

  	}

  }

  const outputNodeMap = new WeakMap();

  class Nodes extends DataMap {

  	constructor( renderer, backend ) {

  		super();

  		this.renderer = renderer;
  		this.backend = backend;
  		this.nodeFrame = new NodeFrame();
  		this.nodeBuilderCache = new Map();
  		this.callHashCache = new ChainMap();
  		this.groupsData = new ChainMap();

  	}

  	updateGroup( nodeUniformsGroup ) {

  		const groupNode = nodeUniformsGroup.groupNode;
  		const name = groupNode.name;

  		// objectGroup is every updated

  		if ( name === objectGroup.name ) return true;

  		// renderGroup is updated once per render/compute call

  		if ( name === renderGroup.name ) {

  			const uniformsGroupData = this.get( nodeUniformsGroup );
  			const renderId = this.nodeFrame.renderId;

  			if ( uniformsGroupData.renderId !== renderId ) {

  				uniformsGroupData.renderId = renderId;

  				return true;

  			}

  			return false;

  		}

  		// frameGroup is updated once per frame

  		if ( name === frameGroup.name ) {

  			const uniformsGroupData = this.get( nodeUniformsGroup );
  			const frameId = this.nodeFrame.frameId;

  			if ( uniformsGroupData.frameId !== frameId ) {

  				uniformsGroupData.frameId = frameId;

  				return true;

  			}

  			return false;

  		}

  		// other groups are updated just when groupNode.needsUpdate is true

  		const groupChain = [ groupNode, nodeUniformsGroup ];

  		let groupData = this.groupsData.get( groupChain );
  		if ( groupData === undefined ) this.groupsData.set( groupChain, groupData = {} );

  		if ( groupData.version !== groupNode.version ) {

  			groupData.version = groupNode.version;

  			return true;

  		}

  		return false;

  	}

  	getForRenderCacheKey( renderObject ) {

  		return renderObject.initialCacheKey;

  	}

  	getForRender( renderObject ) {

  		const renderObjectData = this.get( renderObject );

  		let nodeBuilderState = renderObjectData.nodeBuilderState;

  		if ( nodeBuilderState === undefined ) {

  			const { nodeBuilderCache } = this;

  			const cacheKey = this.getForRenderCacheKey( renderObject );

  			nodeBuilderState = nodeBuilderCache.get( cacheKey );

  			if ( nodeBuilderState === undefined ) {

  				const nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer );
  				nodeBuilder.scene = renderObject.scene;
  				nodeBuilder.material = renderObject.material;
  				nodeBuilder.camera = renderObject.camera;
  				nodeBuilder.context.material = renderObject.material;
  				nodeBuilder.lightsNode = renderObject.lightsNode;
  				nodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );
  				nodeBuilder.fogNode = this.getFogNode( renderObject.scene );
  				nodeBuilder.clippingContext = renderObject.clippingContext;
  				nodeBuilder.build();

  				nodeBuilderState = this._createNodeBuilderState( nodeBuilder );

  				nodeBuilderCache.set( cacheKey, nodeBuilderState );

  			}

  			nodeBuilderState.usedTimes ++;

  			renderObjectData.nodeBuilderState = nodeBuilderState;

  		}

  		return nodeBuilderState;

  	}

  	delete( object ) {

  		if ( object.isRenderObject ) {

  			const nodeBuilderState = this.get( object ).nodeBuilderState;
  			nodeBuilderState.usedTimes --;

  			if ( nodeBuilderState.usedTimes === 0 ) {

  				this.nodeBuilderCache.delete( this.getForRenderCacheKey( object ) );

  			}

  		}

  		return super.delete( object );

  	}

  	getForCompute( computeNode ) {

  		const computeData = this.get( computeNode );

  		let nodeBuilderState = computeData.nodeBuilderState;

  		if ( nodeBuilderState === undefined ) {

  			const nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );
  			nodeBuilder.build();

  			nodeBuilderState = this._createNodeBuilderState( nodeBuilder );

  			computeData.nodeBuilderState = nodeBuilderState;

  		}

  		return nodeBuilderState;

  	}

  	_createNodeBuilderState( nodeBuilder ) {

  		return new NodeBuilderState(
  			nodeBuilder.vertexShader,
  			nodeBuilder.fragmentShader,
  			nodeBuilder.computeShader,
  			nodeBuilder.getAttributesArray(),
  			nodeBuilder.getBindings(),
  			nodeBuilder.updateNodes,
  			nodeBuilder.updateBeforeNodes,
  			nodeBuilder.updateAfterNodes,
  			nodeBuilder.monitor,
  			nodeBuilder.transforms
  		);

  	}

  	getEnvironmentNode( scene ) {

  		return scene.environmentNode || this.get( scene ).environmentNode || null;

  	}

  	getBackgroundNode( scene ) {

  		return scene.backgroundNode || this.get( scene ).backgroundNode || null;

  	}

  	getFogNode( scene ) {

  		return scene.fogNode || this.get( scene ).fogNode || null;

  	}

  	getCacheKey( scene, lightsNode ) {

  		const chain = [ scene, lightsNode ];
  		const callId = this.renderer.info.calls;

  		let cacheKeyData = this.callHashCache.get( chain );

  		if ( cacheKeyData === undefined || cacheKeyData.callId !== callId ) {

  			const environmentNode = this.getEnvironmentNode( scene );
  			const fogNode = this.getFogNode( scene );

  			const values = [];

  			if ( lightsNode ) values.push( lightsNode.getCacheKey( true ) );
  			if ( environmentNode ) values.push( environmentNode.getCacheKey() );
  			if ( fogNode ) values.push( fogNode.getCacheKey() );

  			values.push( this.renderer.shadowMap.enabled ? 1 : 0 );

  			cacheKeyData = {
  				callId,
  				cacheKey: hashArray( values )
  			};

  			this.callHashCache.set( chain, cacheKeyData );

  		}

  		return cacheKeyData.cacheKey;

  	}

  	updateScene( scene ) {

  		this.updateEnvironment( scene );
  		this.updateFog( scene );
  		this.updateBackground( scene );

  	}

  	get isToneMappingState() {

  		return this.renderer.getRenderTarget() ? false : true;

  	}

  	updateBackground( scene ) {

  		const sceneData = this.get( scene );
  		const background = scene.background;

  		if ( background ) {

  			const forceUpdate = ( scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 ) || ( scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0 );

  			if ( sceneData.background !== background || forceUpdate ) {

  				let backgroundNode = null;

  				if ( background.isCubeTexture === true || ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping ) ) {

  					if ( scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping ) {

  						backgroundNode = pmremTexture( background, normalWorld );

  					} else {

  						let envMap;

  						if ( background.isCubeTexture === true ) {

  							envMap = cubeTexture( background );

  						} else {

  							envMap = texture( background );

  						}

  						backgroundNode = cubeMapNode( envMap );

  					}

  				} else if ( background.isTexture === true ) {

  					backgroundNode = texture( background, screenUV.flipY() ).setUpdateMatrix( true );

  				} else if ( background.isColor !== true ) {

  					console.error( 'WebGPUNodes: Unsupported background configuration.', background );

  				}

  				sceneData.backgroundNode = backgroundNode;
  				sceneData.background = background;
  				sceneData.backgroundBlurriness = scene.backgroundBlurriness;

  			}

  		} else if ( sceneData.backgroundNode ) {

  			delete sceneData.backgroundNode;
  			delete sceneData.background;

  		}

  	}

  	updateFog( scene ) {

  		const sceneData = this.get( scene );
  		const fog = scene.fog;

  		if ( fog ) {

  			if ( sceneData.fog !== fog ) {

  				let fogNode = null;

  				if ( fog.isFogExp2 ) {

  					const color = reference( 'color', 'color', fog ).setGroup( renderGroup );
  					const density = reference( 'density', 'float', fog ).setGroup( renderGroup );

  					fogNode = densityFog( color, density );

  				} else if ( fog.isFog ) {

  					const color = reference( 'color', 'color', fog ).setGroup( renderGroup );
  					const near = reference( 'near', 'float', fog ).setGroup( renderGroup );
  					const far = reference( 'far', 'float', fog ).setGroup( renderGroup );

  					fogNode = rangeFog( color, near, far );

  				} else {

  					console.error( 'WebGPUNodes: Unsupported fog configuration.', fog );

  				}

  				sceneData.fogNode = fogNode;
  				sceneData.fog = fog;

  			}

  		} else {

  			delete sceneData.fogNode;
  			delete sceneData.fog;

  		}

  	}

  	updateEnvironment( scene ) {

  		const sceneData = this.get( scene );
  		const environment = scene.environment;

  		if ( environment ) {

  			if ( sceneData.environment !== environment ) {

  				let environmentNode = null;

  				if ( environment.isCubeTexture === true ) {

  					environmentNode = cubeTexture( environment );

  				} else if ( environment.isTexture === true ) {

  					environmentNode = texture( environment );

  				} else {

  					console.error( 'Nodes: Unsupported environment configuration.', environment );

  				}

  				sceneData.environmentNode = environmentNode;
  				sceneData.environment = environment;

  			}

  		} else if ( sceneData.environmentNode ) {

  			delete sceneData.environmentNode;
  			delete sceneData.environment;

  		}

  	}

  	getNodeFrame( renderer = this.renderer, scene = null, object = null, camera = null, material = null ) {

  		const nodeFrame = this.nodeFrame;
  		nodeFrame.renderer = renderer;
  		nodeFrame.scene = scene;
  		nodeFrame.object = object;
  		nodeFrame.camera = camera;
  		nodeFrame.material = material;

  		return nodeFrame;

  	}

  	getNodeFrameForRender( renderObject ) {

  		return this.getNodeFrame( renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material );

  	}

  	getOutputCacheKey() {

  		const renderer = this.renderer;

  		return renderer.toneMapping + ',' + renderer.currentColorSpace;

  	}

  	hasOutputChange( outputTarget ) {

  		const cacheKey = outputNodeMap.get( outputTarget );

  		return cacheKey !== this.getOutputCacheKey();

  	}

  	getOutputNode( outputTexture ) {

  		const renderer = this.renderer;
  		const cacheKey = this.getOutputCacheKey();

  		const output = texture( outputTexture, screenUV ).renderOutput( renderer.toneMapping, renderer.currentColorSpace );

  		outputNodeMap.set( outputTexture, cacheKey );

  		return output;

  	}

  	updateBefore( renderObject ) {

  		const nodeBuilder = renderObject.getNodeBuilderState();

  		for ( const node of nodeBuilder.updateBeforeNodes ) {

  			// update frame state for each node

  			this.getNodeFrameForRender( renderObject ).updateBeforeNode( node );

  		}

  	}

  	updateAfter( renderObject ) {

  		const nodeBuilder = renderObject.getNodeBuilderState();

  		for ( const node of nodeBuilder.updateAfterNodes ) {

  			// update frame state for each node

  			this.getNodeFrameForRender( renderObject ).updateAfterNode( node );

  		}

  	}

  	updateForCompute( computeNode ) {

  		const nodeFrame = this.getNodeFrame();
  		const nodeBuilder = this.getForCompute( computeNode );

  		for ( const node of nodeBuilder.updateNodes ) {

  			nodeFrame.updateNode( node );

  		}

  	}

  	updateForRender( renderObject ) {

  		const nodeFrame = this.getNodeFrameForRender( renderObject );
  		const nodeBuilder = renderObject.getNodeBuilderState();

  		for ( const node of nodeBuilder.updateNodes ) {

  			nodeFrame.updateNode( node );

  		}

  	}

  	needsRefresh( renderObject ) {

  		const nodeFrame = this.getNodeFrameForRender( renderObject );
  		const monitor = renderObject.getMonitor();

  		return monitor.needsRefresh( renderObject, nodeFrame );

  	}

  	dispose() {

  		super.dispose();

  		this.nodeFrame = new NodeFrame();
  		this.nodeBuilderCache = new Map();

  	}

  }

  class RenderBundle {

  	constructor( scene, camera ) {

  		this.scene = scene;
  		this.camera = camera;

  	}

  	clone() {

  		return Object.assign( new this.constructor(), this );

  	}

  }

  class RenderBundles {

  	constructor() {

  		this.lists = new ChainMap();

  	}

  	get( scene, camera ) {

  		const lists = this.lists;
  		const keys = [ scene, camera ];

  		let list = lists.get( keys );

  		if ( list === undefined ) {

  			list = new RenderBundle( scene, camera );
  			lists.set( keys, list );

  		}

  		return list;

  	}

  	dispose() {

  		this.lists = new ChainMap();

  	}

  }

  class NodeLibrary {

  	constructor() {

  		this.lightNodes = new WeakMap();
  		this.materialNodes = new Map();
  		this.toneMappingNodes = new Map();
  		this.colorSpaceNodes = new Map();

  	}

  	fromMaterial( material ) {

  		if ( material.isNodeMaterial ) return material;

  		let nodeMaterial = null;

  		const nodeMaterialClass = this.getMaterialNodeClass( material.type );

  		if ( nodeMaterialClass !== null ) {

  			nodeMaterial = new nodeMaterialClass();

  			for ( const key in material ) {

  				nodeMaterial[ key ] = material[ key ];

  			}

  		}

  		return nodeMaterial;

  	}

  	addColorSpace( colorSpaceNode, colorSpace ) {

  		this.addType( colorSpaceNode, colorSpace, this.colorSpaceNodes );

  	}

  	getColorSpaceFunction( colorSpace ) {

  		return this.colorSpaceNodes.get( colorSpace ) || null;

  	}

  	addToneMapping( toneMappingNode, toneMapping ) {

  		this.addType( toneMappingNode, toneMapping, this.toneMappingNodes );

  	}

  	getToneMappingFunction( toneMapping ) {

  		return this.toneMappingNodes.get( toneMapping ) || null;

  	}

  	getMaterialNodeClass( materialType ) {

  		return this.materialNodes.get( materialType ) || null;

  	}

  	addMaterial( materialNodeClass, materialClass ) {

  		this.addType( materialNodeClass, materialClass.name, this.materialNodes );

  	}

  	getLightNodeClass( light ) {

  		return this.lightNodes.get( light ) || null;

  	}

  	addLight( lightNodeClass, lightClass ) {

  		this.addClass( lightNodeClass, lightClass, this.lightNodes );

  	}

  	addType( nodeClass, type, library ) {

  		if ( library.has( type ) ) {

  			console.warn( `Redefinition of node ${ type }` );
  			return;

  		}

  		if ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );
  		if ( typeof type === 'function' || typeof type === 'object' ) throw new Error( `Base class ${ type } is not a class.` );

  		library.set( type, nodeClass );

  	}

  	addClass( nodeClass, baseClass, library ) {

  		if ( library.has( baseClass ) ) {

  			console.warn( `Redefinition of node ${ baseClass.name }` );
  			return;

  		}

  		if ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );
  		if ( typeof baseClass !== 'function' ) throw new Error( `Base class ${ baseClass.name } is not a class.` );

  		library.set( baseClass, nodeClass );

  	}

  }

  const _scene = /*@__PURE__*/ new Scene();
  const _drawingBufferSize = /*@__PURE__*/ new Vector2();
  const _screen = /*@__PURE__*/ new Vector4();
  const _frustum = /*@__PURE__*/ new Frustum();
  const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
  const _vector4 = /*@__PURE__*/ new Vector4();

  class Renderer {

  	constructor( backend, parameters = {} ) {

  		this.isRenderer = true;

  		//

  		const {
  			logarithmicDepthBuffer = false,
  			alpha = true,
  			depth = true,
  			stencil = false,
  			antialias = false,
  			samples = 0,
  			getFallback = null
  		} = parameters;

  		// public
  		this.domElement = backend.getDomElement();

  		this.backend = backend;

  		this.samples = samples || ( antialias === true ) ? 4 : 0;

  		this.autoClear = true;
  		this.autoClearColor = true;
  		this.autoClearDepth = true;
  		this.autoClearStencil = true;

  		this.alpha = alpha;

  		this.logarithmicDepthBuffer = logarithmicDepthBuffer;

  		this.outputColorSpace = SRGBColorSpace;

  		this.toneMapping = NoToneMapping;
  		this.toneMappingExposure = 1.0;

  		this.sortObjects = true;

  		this.depth = depth;
  		this.stencil = stencil;

  		this.clippingPlanes = [];

  		this.info = new Info();

  		this.nodes = {
  			library: new NodeLibrary(),
  			modelViewMatrix: null,
  			modelNormalViewMatrix: null
  		};

  		// internals

  		this._getFallback = getFallback;

  		this._pixelRatio = 1;
  		this._width = this.domElement.width;
  		this._height = this.domElement.height;

  		this._viewport = new Vector4( 0, 0, this._width, this._height );
  		this._scissor = new Vector4( 0, 0, this._width, this._height );
  		this._scissorTest = false;

  		this._attributes = null;
  		this._geometries = null;
  		this._nodes = null;
  		this._animation = null;
  		this._bindings = null;
  		this._objects = null;
  		this._pipelines = null;
  		this._bundles = null;
  		this._renderLists = null;
  		this._renderContexts = null;
  		this._textures = null;
  		this._background = null;

  		this._quad = new QuadMesh( new NodeMaterial() );
  		this._quad.material.type = 'Renderer_output';

  		this._currentRenderContext = null;

  		this._opaqueSort = null;
  		this._transparentSort = null;

  		this._frameBufferTarget = null;

  		const alphaClear = this.alpha === true ? 0 : 1;

  		this._clearColor = new Color4( 0, 0, 0, alphaClear );
  		this._clearDepth = 1;
  		this._clearStencil = 0;

  		this._renderTarget = null;
  		this._activeCubeFace = 0;
  		this._activeMipmapLevel = 0;

  		this._mrt = null;

  		this._renderObjectFunction = null;
  		this._currentRenderObjectFunction = null;
  		this._currentRenderBundle = null;

  		this._handleObjectFunction = this._renderObjectDirect;

  		this._initialized = false;
  		this._initPromise = null;

  		this._compilationPromises = null;

  		this.transparent = true;
  		this.opaque = true;

  		this.shadowMap = {
  			enabled: false,
  			type: PCFShadowMap$1
  		};

  		this.xr = {
  			enabled: false
  		};

  		this.debug = {
  			checkShaderErrors: true,
  			onShaderError: null,
  			getShaderAsync: async ( scene, camera, object ) => {

  				await this.compileAsync( scene, camera );

  				const renderList = this._renderLists.get( scene, camera );
  				const renderContext = this._renderContexts.get( scene, camera, this._renderTarget );

  				const material = scene.overrideMaterial || object.material;

  				const renderObject = this._objects.get( object, material, scene, camera, renderList.lightsNode, renderContext );

  				const { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();

  				return { fragmentShader, vertexShader };

  			}
  		};

  	}

  	async init() {

  		if ( this._initialized ) {

  			throw new Error( 'Renderer: Backend has already been initialized.' );

  		}

  		if ( this._initPromise !== null ) {

  			return this._initPromise;

  		}

  		this._initPromise = new Promise( async ( resolve, reject ) => {

  			let backend = this.backend;

  			try {

  				await backend.init( this );

  			} catch ( error ) {

  				if ( this._getFallback !== null ) {

  					// try the fallback

  					try {

  						this.backend = backend = this._getFallback( error );
  						await backend.init( this );

  					} catch ( error ) {

  						reject( error );
  						return;

  					}

  				} else {

  					reject( error );
  					return;

  				}

  			}

  			this._nodes = new Nodes( this, backend );
  			this._animation = new Animation( this._nodes, this.info );
  			this._attributes = new Attributes( backend );
  			this._background = new Background( this, this._nodes );
  			this._geometries = new Geometries( this._attributes, this.info );
  			this._textures = new Textures( this, backend, this.info );
  			this._pipelines = new Pipelines( backend, this._nodes );
  			this._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );
  			this._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );
  			this._renderLists = new RenderLists();
  			this._bundles = new RenderBundles();
  			this._renderContexts = new RenderContexts();

  			//

  			this._initialized = true;

  			resolve();

  		} );

  		return this._initPromise;

  	}

  	get coordinateSystem() {

  		return this.backend.coordinateSystem;

  	}

  	async compileAsync( scene, camera, targetScene = null ) {

  		if ( this._initialized === false ) await this.init();

  		// preserve render tree

  		const nodeFrame = this._nodes.nodeFrame;

  		const previousRenderId = nodeFrame.renderId;
  		const previousRenderContext = this._currentRenderContext;
  		const previousRenderObjectFunction = this._currentRenderObjectFunction;
  		const previousCompilationPromises = this._compilationPromises;

  		//

  		const sceneRef = ( scene.isScene === true ) ? scene : _scene;

  		if ( targetScene === null ) targetScene = scene;

  		const renderTarget = this._renderTarget;
  		const renderContext = this._renderContexts.get( targetScene, camera, renderTarget );
  		const activeMipmapLevel = this._activeMipmapLevel;

  		const compilationPromises = [];

  		this._currentRenderContext = renderContext;
  		this._currentRenderObjectFunction = this.renderObject;

  		this._handleObjectFunction = this._createObjectPipeline;

  		this._compilationPromises = compilationPromises;

  		nodeFrame.renderId ++;

  		//

  		nodeFrame.update();

  		//

  		renderContext.depth = this.depth;
  		renderContext.stencil = this.stencil;

  		if ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();
  		renderContext.clippingContext.updateGlobal( this, camera );

  		//

  		sceneRef.onBeforeRender( this, scene, camera, renderTarget );

  		//

  		const renderList = this._renderLists.get( scene, camera );
  		renderList.begin();

  		this._projectObject( scene, camera, 0, renderList );

  		// include lights from target scene
  		if ( targetScene !== scene ) {

  			targetScene.traverseVisible( function ( object ) {

  				if ( object.isLight && object.layers.test( camera.layers ) ) {

  					renderList.pushLight( object );

  				}

  			} );

  		}

  		renderList.finish();

  		//

  		if ( renderTarget !== null ) {

  			this._textures.updateRenderTarget( renderTarget, activeMipmapLevel );

  			const renderTargetData = this._textures.get( renderTarget );

  			renderContext.textures = renderTargetData.textures;
  			renderContext.depthTexture = renderTargetData.depthTexture;

  		} else {

  			renderContext.textures = null;
  			renderContext.depthTexture = null;

  		}

  		//

  		this._nodes.updateScene( sceneRef );

  		//

  		this._background.update( sceneRef, renderList, renderContext );

  		// process render lists

  		const opaqueObjects = renderList.opaque;
  		const transparentObjects = renderList.transparent;
  		const lightsNode = renderList.lightsNode;

  		if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
  		if ( this.transparent === true && transparentObjects.length > 0 ) this._renderObjects( transparentObjects, camera, sceneRef, lightsNode );

  		// restore render tree

  		nodeFrame.renderId = previousRenderId;

  		this._currentRenderContext = previousRenderContext;
  		this._currentRenderObjectFunction = previousRenderObjectFunction;
  		this._compilationPromises = previousCompilationPromises;

  		this._handleObjectFunction = this._renderObjectDirect;

  		// wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete

  		await Promise.all( compilationPromises );

  	}

  	async renderAsync( scene, camera ) {

  		if ( this._initialized === false ) await this.init();

  		const renderContext = this._renderScene( scene, camera );

  		await this.backend.resolveTimestampAsync( renderContext, 'render' );

  	}

  	setMRT( mrt ) {

  		this._mrt = mrt;

  		return this;

  	}

  	getMRT() {

  		return this._mrt;

  	}

  	_renderBundle( bundle, sceneRef, lightsNode ) {

  		const { bundleGroup, camera, renderList } = bundle;

  		const renderContext = this._currentRenderContext;

  		//

  		const renderBundle = this._bundles.get( bundleGroup, camera );
  		const renderBundleData = this.backend.get( renderBundle );

  		if ( renderBundleData.renderContexts === undefined ) renderBundleData.renderContexts = new Set();

  		//

  		const needsUpdate = bundleGroup.version !== renderBundleData.version;
  		const renderBundleNeedsUpdate = renderBundleData.renderContexts.has( renderContext ) === false || needsUpdate;

  		renderBundleData.renderContexts.add( renderContext );

  		if ( renderBundleNeedsUpdate ) {

  			this.backend.beginBundle( renderContext );

  			if ( renderBundleData.renderObjects === undefined || needsUpdate ) {

  				renderBundleData.renderObjects = [];

  			}

  			this._currentRenderBundle = renderBundle;

  			const opaqueObjects = renderList.opaque;

  			if ( opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );

  			this._currentRenderBundle = null;

  			//

  			this.backend.finishBundle( renderContext, renderBundle );

  			renderBundleData.version = bundleGroup.version;

  		} else {

  			const { renderObjects } = renderBundleData;

  			for ( let i = 0, l = renderObjects.length; i < l; i ++ ) {

  				const renderObject = renderObjects[ i ];

  				if ( this._nodes.needsRefresh( renderObject ) ) {

  					this._nodes.updateBefore( renderObject );

  					this._nodes.updateForRender( renderObject );
  					this._bindings.updateForRender( renderObject );

  					this._nodes.updateAfter( renderObject );

  				}

  			}

  		}

  		this.backend.addBundle( renderContext, renderBundle );

  	}

  	render( scene, camera ) {

  		if ( this._initialized === false ) {

  			console.warn( 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.' );

  			return this.renderAsync( scene, camera );

  		}

  		this._renderScene( scene, camera );

  	}

  	_getFrameBufferTarget() {

  		const { currentToneMapping, currentColorSpace } = this;

  		const useToneMapping = currentToneMapping !== NoToneMapping;
  		const useColorSpace = currentColorSpace !== LinearSRGBColorSpace;

  		if ( useToneMapping === false && useColorSpace === false ) return null;

  		const { width, height } = this.getDrawingBufferSize( _drawingBufferSize );
  		const { depth, stencil } = this;

  		let frameBufferTarget = this._frameBufferTarget;

  		if ( frameBufferTarget === null ) {

  			frameBufferTarget = new RenderTarget( width, height, {
  				depthBuffer: depth,
  				stencilBuffer: stencil,
  				type: HalfFloatType, // FloatType
  				format: RGBAFormat,
  				colorSpace: LinearSRGBColorSpace,
  				generateMipmaps: false,
  				minFilter: LinearFilter,
  				magFilter: LinearFilter,
  				samples: this.samples
  			} );

  			frameBufferTarget.isPostProcessingRenderTarget = true;

  			this._frameBufferTarget = frameBufferTarget;

  		}

  		frameBufferTarget.depthBuffer = depth;
  		frameBufferTarget.stencilBuffer = stencil;
  		frameBufferTarget.setSize( width, height );
  		frameBufferTarget.viewport.copy( this._viewport );
  		frameBufferTarget.scissor.copy( this._scissor );
  		frameBufferTarget.viewport.multiplyScalar( this._pixelRatio );
  		frameBufferTarget.scissor.multiplyScalar( this._pixelRatio );
  		frameBufferTarget.scissorTest = this._scissorTest;

  		return frameBufferTarget;

  	}

  	_renderScene( scene, camera, useFrameBufferTarget = true ) {

  		const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;

  		// preserve render tree

  		const nodeFrame = this._nodes.nodeFrame;

  		const previousRenderId = nodeFrame.renderId;
  		const previousRenderContext = this._currentRenderContext;
  		const previousRenderObjectFunction = this._currentRenderObjectFunction;

  		//

  		const sceneRef = ( scene.isScene === true ) ? scene : _scene;

  		const outputRenderTarget = this._renderTarget;

  		const activeCubeFace = this._activeCubeFace;
  		const activeMipmapLevel = this._activeMipmapLevel;

  		//

  		let renderTarget;

  		if ( frameBufferTarget !== null ) {

  			renderTarget = frameBufferTarget;

  			this.setRenderTarget( renderTarget );

  		} else {

  			renderTarget = outputRenderTarget;

  		}

  		//

  		const renderContext = this._renderContexts.get( scene, camera, renderTarget );

  		this._currentRenderContext = renderContext;
  		this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;

  		//

  		this.info.calls ++;
  		this.info.render.calls ++;
  		this.info.render.frameCalls ++;

  		nodeFrame.renderId = this.info.calls;

  		//

  		const coordinateSystem = this.coordinateSystem;

  		if ( camera.coordinateSystem !== coordinateSystem ) {

  			camera.coordinateSystem = coordinateSystem;

  			camera.updateProjectionMatrix();

  		}

  		//

  		if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

  		if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

  		//

  		let viewport = this._viewport;
  		let scissor = this._scissor;
  		let pixelRatio = this._pixelRatio;

  		if ( renderTarget !== null ) {

  			viewport = renderTarget.viewport;
  			scissor = renderTarget.scissor;
  			pixelRatio = 1;

  		}

  		this.getDrawingBufferSize( _drawingBufferSize );

  		_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );

  		const minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;
  		const maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;

  		renderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();
  		renderContext.viewportValue.width >>= activeMipmapLevel;
  		renderContext.viewportValue.height >>= activeMipmapLevel;
  		renderContext.viewportValue.minDepth = minDepth;
  		renderContext.viewportValue.maxDepth = maxDepth;
  		renderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;

  		renderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();
  		renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;
  		renderContext.scissorValue.width >>= activeMipmapLevel;
  		renderContext.scissorValue.height >>= activeMipmapLevel;

  		if ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();
  		renderContext.clippingContext.updateGlobal( this, camera );

  		//

  		sceneRef.onBeforeRender( this, scene, camera, renderTarget );

  		//

  		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  		_frustum.setFromProjectionMatrix( _projScreenMatrix, coordinateSystem );

  		const renderList = this._renderLists.get( scene, camera );
  		renderList.begin();

  		this._projectObject( scene, camera, 0, renderList );

  		renderList.finish();

  		if ( this.sortObjects === true ) {

  			renderList.sort( this._opaqueSort, this._transparentSort );

  		}

  		//

  		if ( renderTarget !== null ) {

  			this._textures.updateRenderTarget( renderTarget, activeMipmapLevel );

  			const renderTargetData = this._textures.get( renderTarget );

  			renderContext.textures = renderTargetData.textures;
  			renderContext.depthTexture = renderTargetData.depthTexture;
  			renderContext.width = renderTargetData.width;
  			renderContext.height = renderTargetData.height;
  			renderContext.renderTarget = renderTarget;
  			renderContext.depth = renderTarget.depthBuffer;
  			renderContext.stencil = renderTarget.stencilBuffer;

  		} else {

  			renderContext.textures = null;
  			renderContext.depthTexture = null;
  			renderContext.width = this.domElement.width;
  			renderContext.height = this.domElement.height;
  			renderContext.depth = this.depth;
  			renderContext.stencil = this.stencil;

  		}

  		renderContext.width >>= activeMipmapLevel;
  		renderContext.height >>= activeMipmapLevel;
  		renderContext.activeCubeFace = activeCubeFace;
  		renderContext.activeMipmapLevel = activeMipmapLevel;
  		renderContext.occlusionQueryCount = renderList.occlusionQueryCount;

  		//

  		this._nodes.updateScene( sceneRef );

  		//

  		this._background.update( sceneRef, renderList, renderContext );

  		//

  		this.backend.beginRender( renderContext );

  		// process render lists

  		const {
  			bundles,
  			lightsNode,
  			transparent: transparentObjects,
  			opaque: opaqueObjects
  		} = renderList;

  		if ( bundles.length > 0 ) this._renderBundles( bundles, sceneRef, lightsNode );
  		if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
  		if ( this.transparent === true && transparentObjects.length > 0 ) this._renderObjects( transparentObjects, camera, sceneRef, lightsNode );

  		// finish render pass

  		this.backend.finishRender( renderContext );

  		// restore render tree

  		nodeFrame.renderId = previousRenderId;

  		this._currentRenderContext = previousRenderContext;
  		this._currentRenderObjectFunction = previousRenderObjectFunction;

  		//

  		if ( frameBufferTarget !== null ) {

  			this.setRenderTarget( outputRenderTarget, activeCubeFace, activeMipmapLevel );

  			const quad = this._quad;

  			if ( this._nodes.hasOutputChange( renderTarget.texture ) ) {

  				quad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );
  				quad.material.needsUpdate = true;

  			}

  			this._renderScene( quad, quad.camera, false );

  		}

  		//

  		sceneRef.onAfterRender( this, scene, camera, renderTarget );

  		//

  		return renderContext;

  	}

  	getMaxAnisotropy() {

  		return this.backend.getMaxAnisotropy();

  	}

  	getActiveCubeFace() {

  		return this._activeCubeFace;

  	}

  	getActiveMipmapLevel() {

  		return this._activeMipmapLevel;

  	}

  	async setAnimationLoop( callback ) {

  		if ( this._initialized === false ) await this.init();

  		this._animation.setAnimationLoop( callback );

  	}

  	async getArrayBufferAsync( attribute ) {

  		return await this.backend.getArrayBufferAsync( attribute );

  	}

  	getContext() {

  		return this.backend.getContext();

  	}

  	getPixelRatio() {

  		return this._pixelRatio;

  	}

  	getDrawingBufferSize( target ) {

  		return target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();

  	}

  	getSize( target ) {

  		return target.set( this._width, this._height );

  	}

  	setPixelRatio( value = 1 ) {

  		this._pixelRatio = value;

  		this.setSize( this._width, this._height, false );

  	}

  	setDrawingBufferSize( width, height, pixelRatio ) {

  		this._width = width;
  		this._height = height;

  		this._pixelRatio = pixelRatio;

  		this.domElement.width = Math.floor( width * pixelRatio );
  		this.domElement.height = Math.floor( height * pixelRatio );

  		this.setViewport( 0, 0, width, height );

  		if ( this._initialized ) this.backend.updateSize();

  	}

  	setSize( width, height, updateStyle = true ) {

  		this._width = width;
  		this._height = height;

  		this.domElement.width = Math.floor( width * this._pixelRatio );
  		this.domElement.height = Math.floor( height * this._pixelRatio );

  		if ( updateStyle === true ) {

  			this.domElement.style.width = width + 'px';
  			this.domElement.style.height = height + 'px';

  		}

  		this.setViewport( 0, 0, width, height );

  		if ( this._initialized ) this.backend.updateSize();

  	}

  	setOpaqueSort( method ) {

  		this._opaqueSort = method;

  	}

  	setTransparentSort( method ) {

  		this._transparentSort = method;

  	}

  	getScissor( target ) {

  		const scissor = this._scissor;

  		target.x = scissor.x;
  		target.y = scissor.y;
  		target.width = scissor.width;
  		target.height = scissor.height;

  		return target;

  	}

  	setScissor( x, y, width, height ) {

  		const scissor = this._scissor;

  		if ( x.isVector4 ) {

  			scissor.copy( x );

  		} else {

  			scissor.set( x, y, width, height );

  		}

  	}

  	getScissorTest() {

  		return this._scissorTest;

  	}

  	setScissorTest( boolean ) {

  		this._scissorTest = boolean;

  		this.backend.setScissorTest( boolean );

  	}

  	getViewport( target ) {

  		return target.copy( this._viewport );

  	}

  	setViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {

  		const viewport = this._viewport;

  		if ( x.isVector4 ) {

  			viewport.copy( x );

  		} else {

  			viewport.set( x, y, width, height );

  		}

  		viewport.minDepth = minDepth;
  		viewport.maxDepth = maxDepth;

  	}

  	getClearColor( target ) {

  		return target.copy( this._clearColor );

  	}

  	setClearColor( color, alpha = 1 ) {

  		this._clearColor.set( color );
  		this._clearColor.a = alpha;

  	}

  	getClearAlpha() {

  		return this._clearColor.a;

  	}

  	setClearAlpha( alpha ) {

  		this._clearColor.a = alpha;

  	}

  	getClearDepth() {

  		return this._clearDepth;

  	}

  	setClearDepth( depth ) {

  		this._clearDepth = depth;

  	}

  	getClearStencil() {

  		return this._clearStencil;

  	}

  	setClearStencil( stencil ) {

  		this._clearStencil = stencil;

  	}

  	isOccluded( object ) {

  		const renderContext = this._currentRenderContext;

  		return renderContext && this.backend.isOccluded( renderContext, object );

  	}

  	clear( color = true, depth = true, stencil = true ) {

  		if ( this._initialized === false ) {

  			console.warn( 'THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.' );

  			return this.clearAsync( color, depth, stencil );

  		}

  		const renderTarget = this._renderTarget || this._getFrameBufferTarget();

  		let renderTargetData = null;

  		if ( renderTarget !== null ) {

  			this._textures.updateRenderTarget( renderTarget );

  			renderTargetData = this._textures.get( renderTarget );

  		}

  		this.backend.clear( color, depth, stencil, renderTargetData );

  		if ( renderTarget !== null && this._renderTarget === null ) {

  			// If a color space transform or tone mapping is required,
  			// the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.

  			const quad = this._quad;

  			if ( this._nodes.hasOutputChange( renderTarget.texture ) ) {

  				quad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );
  				quad.material.needsUpdate = true;

  			}

  			this._renderScene( quad, quad.camera, false );

  		}

  	}

  	clearColor() {

  		return this.clear( true, false, false );

  	}

  	clearDepth() {

  		return this.clear( false, true, false );

  	}

  	clearStencil() {

  		return this.clear( false, false, true );

  	}

  	async clearAsync( color = true, depth = true, stencil = true ) {

  		if ( this._initialized === false ) await this.init();

  		this.clear( color, depth, stencil );

  	}

  	clearColorAsync() {

  		return this.clearAsync( true, false, false );

  	}

  	clearDepthAsync() {

  		return this.clearAsync( false, true, false );

  	}

  	clearStencilAsync() {

  		return this.clearAsync( false, false, true );

  	}

  	get currentToneMapping() {

  		return this._renderTarget !== null ? NoToneMapping : this.toneMapping;

  	}

  	get currentColorSpace() {

  		return this._renderTarget !== null ? LinearSRGBColorSpace : this.outputColorSpace;

  	}

  	dispose() {

  		this.info.dispose();

  		this._animation.dispose();
  		this._objects.dispose();
  		this._pipelines.dispose();
  		this._nodes.dispose();
  		this._bindings.dispose();
  		this._renderLists.dispose();
  		this._renderContexts.dispose();
  		this._textures.dispose();

  		this.setRenderTarget( null );
  		this.setAnimationLoop( null );

  	}

  	setRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

  		this._renderTarget = renderTarget;
  		this._activeCubeFace = activeCubeFace;
  		this._activeMipmapLevel = activeMipmapLevel;

  	}

  	getRenderTarget() {

  		return this._renderTarget;

  	}

  	setRenderObjectFunction( renderObjectFunction ) {

  		this._renderObjectFunction = renderObjectFunction;

  	}

  	getRenderObjectFunction() {

  		return this._renderObjectFunction;

  	}

  	async computeAsync( computeNodes ) {

  		if ( this._initialized === false ) await this.init();

  		const nodeFrame = this._nodes.nodeFrame;

  		const previousRenderId = nodeFrame.renderId;

  		//

  		this.info.calls ++;
  		this.info.compute.calls ++;
  		this.info.compute.frameCalls ++;

  		nodeFrame.renderId = this.info.calls;

  		//

  		const backend = this.backend;
  		const pipelines = this._pipelines;
  		const bindings = this._bindings;
  		const nodes = this._nodes;

  		const computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];

  		if ( computeList[ 0 ] === undefined || computeList[ 0 ].isComputeNode !== true ) {

  			throw new Error( 'THREE.Renderer: .compute() expects a ComputeNode.' );

  		}

  		backend.beginCompute( computeNodes );

  		for ( const computeNode of computeList ) {

  			// onInit

  			if ( pipelines.has( computeNode ) === false ) {

  				const dispose = () => {

  					computeNode.removeEventListener( 'dispose', dispose );

  					pipelines.delete( computeNode );
  					bindings.delete( computeNode );
  					nodes.delete( computeNode );

  				};

  				computeNode.addEventListener( 'dispose', dispose );

  				//

  				computeNode.onInit( { renderer: this } );

  			}

  			nodes.updateForCompute( computeNode );
  			bindings.updateForCompute( computeNode );

  			const computeBindings = bindings.getForCompute( computeNode );
  			const computePipeline = pipelines.getForCompute( computeNode, computeBindings );

  			backend.compute( computeNodes, computeNode, computeBindings, computePipeline );

  		}

  		backend.finishCompute( computeNodes );

  		await this.backend.resolveTimestampAsync( computeNodes, 'compute' );

  		//

  		nodeFrame.renderId = previousRenderId;

  	}

  	async hasFeatureAsync( name ) {

  		if ( this._initialized === false ) await this.init();

  		return this.backend.hasFeature( name );

  	}

  	hasFeature( name ) {

  		if ( this._initialized === false ) {

  			console.warn( 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.' );

  			return false;

  		}

  		return this.backend.hasFeature( name );

  	}

  	copyFramebufferToTexture( framebufferTexture, rectangle = null ) {

  		const renderContext = this._currentRenderContext;

  		this._textures.updateTexture( framebufferTexture );

  		rectangle = rectangle === null ? _vector4.set( 0, 0, framebufferTexture.image.width, framebufferTexture.image.height ) : rectangle;

  		this.backend.copyFramebufferToTexture( framebufferTexture, renderContext, rectangle );

  	}

  	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

  		this._textures.updateTexture( srcTexture );
  		this._textures.updateTexture( dstTexture );

  		this.backend.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );

  	}


  	readRenderTargetPixelsAsync( renderTarget, x, y, width, height, index = 0, faceIndex = 0 ) {

  		return this.backend.copyTextureToBuffer( renderTarget.textures[ index ], x, y, width, height, faceIndex );

  	}

  	_projectObject( object, camera, groupOrder, renderList ) {

  		if ( object.visible === false ) return;

  		const visible = object.layers.test( camera.layers );

  		if ( visible ) {

  			if ( object.isGroup ) {

  				groupOrder = object.renderOrder;

  			} else if ( object.isLOD ) {

  				if ( object.autoUpdate === true ) object.update( camera );

  			} else if ( object.isLight ) {

  				renderList.pushLight( object );

  			} else if ( object.isSprite ) {

  				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

  					if ( this.sortObjects === true ) {

  						_vector4.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );

  					}

  					const { geometry, material } = object;

  					if ( material.visible ) {

  						renderList.push( object, geometry, material, groupOrder, _vector4.z, null );

  					}

  				}

  			} else if ( object.isLineLoop ) {

  				console.error( 'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );

  			} else if ( object.isMesh || object.isLine || object.isPoints ) {

  				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

  					const { geometry, material } = object;

  					if ( this.sortObjects === true ) {

  						if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  						_vector4
  							.copy( geometry.boundingSphere.center )
  							.applyMatrix4( object.matrixWorld )
  							.applyMatrix4( _projScreenMatrix );

  					}

  					if ( Array.isArray( material ) ) {

  						const groups = geometry.groups;

  						for ( let i = 0, l = groups.length; i < l; i ++ ) {

  							const group = groups[ i ];
  							const groupMaterial = material[ group.materialIndex ];

  							if ( groupMaterial && groupMaterial.visible ) {

  								renderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group );

  							}

  						}

  					} else if ( material.visible ) {

  						renderList.push( object, geometry, material, groupOrder, _vector4.z, null );

  					}

  				}

  			}

  		}

  		if ( object.isBundleGroup === true && this.backend.beginBundle !== undefined ) {

  			const baseRenderList = renderList;

  			// replace render list
  			renderList = this._renderLists.get( object, camera );

  			renderList.begin();

  			baseRenderList.pushBundle( {
  				bundleGroup: object,
  				camera,
  				renderList,
  			} );

  			renderList.finish();

  		}

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			this._projectObject( children[ i ], camera, groupOrder, renderList );

  		}

  	}

  	_renderBundles( bundles, sceneRef, lightsNode ) {

  		for ( const bundle of bundles ) {

  			this._renderBundle( bundle, sceneRef, lightsNode );

  		}

  	}

  	_renderObjects( renderList, camera, scene, lightsNode ) {

  		// process renderable objects

  		for ( let i = 0, il = renderList.length; i < il; i ++ ) {

  			const renderItem = renderList[ i ];

  			// @TODO: Add support for multiple materials per object. This will require to extract
  			// the material from the renderItem object and pass it with its group data to renderObject().

  			const { object, geometry, material, group } = renderItem;

  			if ( camera.isArrayCamera ) {

  				const cameras = camera.cameras;

  				for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

  					const camera2 = cameras[ j ];

  					if ( object.layers.test( camera2.layers ) ) {

  						const vp = camera2.viewport;
  						const minDepth = ( vp.minDepth === undefined ) ? 0 : vp.minDepth;
  						const maxDepth = ( vp.maxDepth === undefined ) ? 1 : vp.maxDepth;

  						const viewportValue = this._currentRenderContext.viewportValue;
  						viewportValue.copy( vp ).multiplyScalar( this._pixelRatio ).floor();
  						viewportValue.minDepth = minDepth;
  						viewportValue.maxDepth = maxDepth;

  						this.backend.updateViewport( this._currentRenderContext );

  						this._currentRenderObjectFunction( object, scene, camera2, geometry, material, group, lightsNode );

  					}

  				}

  			} else {

  				this._currentRenderObjectFunction( object, scene, camera, geometry, material, group, lightsNode );

  			}

  		}

  	}

  	renderObject( object, scene, camera, geometry, material, group, lightsNode ) {

  		let overridePositionNode;
  		let overrideFragmentNode;
  		let overrideDepthNode;

  		//

  		object.onBeforeRender( this, scene, camera, geometry, material, group );

  		//

  		if ( scene.overrideMaterial !== null ) {

  			const overrideMaterial = scene.overrideMaterial;

  			if ( material.positionNode && material.positionNode.isNode ) {

  				overridePositionNode = overrideMaterial.positionNode;
  				overrideMaterial.positionNode = material.positionNode;

  			}

  			if ( overrideMaterial.isShadowNodeMaterial ) {

  				overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;

  				if ( material.depthNode && material.depthNode.isNode ) {

  					overrideDepthNode = overrideMaterial.depthNode;
  					overrideMaterial.depthNode = material.depthNode;

  				}


  				if ( material.shadowNode && material.shadowNode.isNode ) {

  					overrideFragmentNode = overrideMaterial.fragmentNode;
  					overrideMaterial.fragmentNode = material.shadowNode;

  				}

  				if ( this.localClippingEnabled ) {

  					if ( material.clipShadows ) {

  						if ( overrideMaterial.clippingPlanes !== material.clippingPlanes ) {

  							overrideMaterial.clippingPlanes = material.clippingPlanes;
  							overrideMaterial.needsUpdate = true;

  						}

  						if ( overrideMaterial.clipIntersection !== material.clipIntersection ) {

  							overrideMaterial.clipIntersection = material.clipIntersection;

  						}

  					} else if ( Array.isArray( overrideMaterial.clippingPlanes ) ) {

  						overrideMaterial.clippingPlanes = null;
  						overrideMaterial.needsUpdate = true;

  					}

  				}

  			}

  			material = overrideMaterial;

  		}

  		//

  		if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

  			material.side = BackSide;
  			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, 'backSide' ); // create backSide pass id

  			material.side = FrontSide;
  			this._handleObjectFunction( object, material, scene, camera, lightsNode, group ); // use default pass id

  			material.side = DoubleSide;

  		} else {

  			this._handleObjectFunction( object, material, scene, camera, lightsNode, group );

  		}

  		//

  		if ( overridePositionNode !== undefined ) {

  			scene.overrideMaterial.positionNode = overridePositionNode;

  		}

  		if ( overrideDepthNode !== undefined ) {

  			scene.overrideMaterial.depthNode = overrideDepthNode;

  		}

  		if ( overrideFragmentNode !== undefined ) {

  			scene.overrideMaterial.fragmentNode = overrideFragmentNode;

  		}

  		//

  		object.onAfterRender( this, scene, camera, geometry, material, group );

  	}

  	_renderObjectDirect( object, material, scene, camera, lightsNode, group, passId ) {

  		const renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, passId );
  		renderObject.drawRange = object.geometry.drawRange;
  		renderObject.group = group;

  		//

  		const needsRefresh = this._nodes.needsRefresh( renderObject );

  		if ( needsRefresh ) {

  			this._nodes.updateBefore( renderObject );

  			this._geometries.updateForRender( renderObject );

  			this._nodes.updateForRender( renderObject );
  			this._bindings.updateForRender( renderObject );

  		}

  		this._pipelines.updateForRender( renderObject );

  		//

  		if ( this._currentRenderBundle !== null ) {

  			const renderBundleData = this.backend.get( this._currentRenderBundle );

  			renderBundleData.renderObjects.push( renderObject );

  			renderObject.bundle = this._currentRenderBundle.scene;

  		}

  		this.backend.draw( renderObject, this.info );

  		if ( needsRefresh ) this._nodes.updateAfter( renderObject );

  	}

  	_createObjectPipeline( object, material, scene, camera, lightsNode, passId ) {

  		const renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, passId );

  		//

  		this._nodes.updateBefore( renderObject );

  		this._geometries.updateForRender( renderObject );

  		this._nodes.updateForRender( renderObject );
  		this._bindings.updateForRender( renderObject );

  		this._pipelines.getForRender( renderObject, this._compilationPromises );

  		this._nodes.updateAfter( renderObject );

  	}

  	get compute() {

  		return this.computeAsync;

  	}

  	get compile() {

  		return this.compileAsync;

  	}

  }

  class Binding {

  	constructor( name = '' ) {

  		this.name = name;

  		this.visibility = 0;

  	}

  	setVisibility( visibility ) {

  		this.visibility |= visibility;

  	}

  	clone() {

  		return Object.assign( new this.constructor(), this );

  	}

  }

  function getFloatLength( floatLength ) {

  	// ensure chunk size alignment (STD140 layout)

  	return floatLength + ( ( GPU_CHUNK_BYTES - ( floatLength % GPU_CHUNK_BYTES ) ) % GPU_CHUNK_BYTES );

  }

  class Buffer extends Binding {

  	constructor( name, buffer = null ) {

  		super( name );

  		this.isBuffer = true;

  		this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;

  		this._buffer = buffer;

  	}

  	get byteLength() {

  		return getFloatLength( this._buffer.byteLength );

  	}

  	get buffer() {

  		return this._buffer;

  	}

  	update() {

  		return true;

  	}

  }

  class UniformBuffer extends Buffer {

  	constructor( name, buffer = null ) {

  		super( name, buffer );

  		this.isUniformBuffer = true;

  	}

  }

  let _id$4 = 0;

  class NodeUniformBuffer extends UniformBuffer {

  	constructor( nodeUniform, groupNode ) {

  		super( 'UniformBuffer_' + _id$4 ++, nodeUniform ? nodeUniform.value : null );

  		this.nodeUniform = nodeUniform;
  		this.groupNode = groupNode;

  	}

  	get buffer() {

  		return this.nodeUniform.value;

  	}

  }

  class UniformsGroup extends UniformBuffer {

  	constructor( name ) {

  		super( name );

  		this.isUniformsGroup = true;

  		this._values = null;

  		// the order of uniforms in this array must match the order of uniforms in the shader

  		this.uniforms = [];

  	}

  	addUniform( uniform ) {

  		this.uniforms.push( uniform );

  		return this;

  	}

  	removeUniform( uniform ) {

  		const index = this.uniforms.indexOf( uniform );

  		if ( index !== - 1 ) {

  			this.uniforms.splice( index, 1 );

  		}

  		return this;

  	}

  	get values() {

  		if ( this._values === null ) {

  			this._values = Array.from( this.buffer );

  		}

  		return this._values;

  	}

  	get buffer() {

  		let buffer = this._buffer;

  		if ( buffer === null ) {

  			const byteLength = this.byteLength;

  			buffer = new Float32Array( new ArrayBuffer( byteLength ) );

  			this._buffer = buffer;

  		}

  		return buffer;

  	}

  	get byteLength() {

  		let offset = 0; // global buffer offset in bytes

  		for ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {

  			const uniform = this.uniforms[ i ];

  			const { boundary, itemSize } = uniform;

  			// offset within a single chunk in bytes

  			const chunkOffset = offset % GPU_CHUNK_BYTES;
  			const remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;

  			// conformance tests

  			if ( chunkOffset !== 0 && ( remainingSizeInChunk - boundary ) < 0 ) {

  				// check for chunk overflow

  				offset += ( GPU_CHUNK_BYTES - chunkOffset );

  			} else if ( chunkOffset % boundary !== 0 ) {

  				// check for correct alignment

  				offset += ( chunkOffset % boundary );

  			}

  			uniform.offset = ( offset / this.bytesPerElement );

  			offset += ( itemSize * this.bytesPerElement );

  		}

  		return Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;

  	}

  	update() {

  		let updated = false;

  		for ( const uniform of this.uniforms ) {

  			if ( this.updateByType( uniform ) === true ) {

  				updated = true;

  			}

  		}

  		return updated;

  	}

  	updateByType( uniform ) {

  		if ( uniform.isNumberUniform ) return this.updateNumber( uniform );
  		if ( uniform.isVector2Uniform ) return this.updateVector2( uniform );
  		if ( uniform.isVector3Uniform ) return this.updateVector3( uniform );
  		if ( uniform.isVector4Uniform ) return this.updateVector4( uniform );
  		if ( uniform.isColorUniform ) return this.updateColor( uniform );
  		if ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );
  		if ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );

  		console.error( 'THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform );

  	}

  	updateNumber( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const v = uniform.getValue();
  		const offset = uniform.offset;

  		if ( a[ offset ] !== v ) {

  			const b = this.buffer;

  			b[ offset ] = a[ offset ] = v;
  			updated = true;

  		}

  		return updated;

  	}

  	updateVector2( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const v = uniform.getValue();
  		const offset = uniform.offset;

  		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {

  			const b = this.buffer;

  			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
  			b[ offset + 1 ] = a[ offset + 1 ] = v.y;

  			updated = true;

  		}

  		return updated;

  	}

  	updateVector3( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const v = uniform.getValue();
  		const offset = uniform.offset;

  		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {

  			const b = this.buffer;

  			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
  			b[ offset + 1 ] = a[ offset + 1 ] = v.y;
  			b[ offset + 2 ] = a[ offset + 2 ] = v.z;

  			updated = true;

  		}

  		return updated;

  	}

  	updateVector4( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const v = uniform.getValue();
  		const offset = uniform.offset;

  		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {

  			const b = this.buffer;

  			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
  			b[ offset + 1 ] = a[ offset + 1 ] = v.y;
  			b[ offset + 2 ] = a[ offset + 2 ] = v.z;
  			b[ offset + 3 ] = a[ offset + 3 ] = v.w;

  			updated = true;

  		}

  		return updated;

  	}

  	updateColor( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const c = uniform.getValue();
  		const offset = uniform.offset;

  		if ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {

  			const b = this.buffer;

  			b[ offset + 0 ] = a[ offset + 0 ] = c.r;
  			b[ offset + 1 ] = a[ offset + 1 ] = c.g;
  			b[ offset + 2 ] = a[ offset + 2 ] = c.b;

  			updated = true;

  		}

  		return updated;

  	}

  	updateMatrix3( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const e = uniform.getValue().elements;
  		const offset = uniform.offset;

  		if ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||
  			a[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||
  			a[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {

  			const b = this.buffer;

  			b[ offset + 0 ] = a[ offset + 0 ] = e[ 0 ];
  			b[ offset + 1 ] = a[ offset + 1 ] = e[ 1 ];
  			b[ offset + 2 ] = a[ offset + 2 ] = e[ 2 ];
  			b[ offset + 4 ] = a[ offset + 4 ] = e[ 3 ];
  			b[ offset + 5 ] = a[ offset + 5 ] = e[ 4 ];
  			b[ offset + 6 ] = a[ offset + 6 ] = e[ 5 ];
  			b[ offset + 8 ] = a[ offset + 8 ] = e[ 6 ];
  			b[ offset + 9 ] = a[ offset + 9 ] = e[ 7 ];
  			b[ offset + 10 ] = a[ offset + 10 ] = e[ 8 ];

  			updated = true;

  		}

  		return updated;

  	}

  	updateMatrix4( uniform ) {

  		let updated = false;

  		const a = this.values;
  		const e = uniform.getValue().elements;
  		const offset = uniform.offset;

  		if ( arraysEqual( a, e, offset ) === false ) {

  			const b = this.buffer;
  			b.set( e, offset );
  			setArray( a, e, offset );
  			updated = true;

  		}

  		return updated;

  	}

  }

  function setArray( a, b, offset ) {

  	for ( let i = 0, l = b.length; i < l; i ++ ) {

  		a[ offset + i ] = b[ i ];

  	}

  }

  function arraysEqual( a, b, offset ) {

  	for ( let i = 0, l = b.length; i < l; i ++ ) {

  		if ( a[ offset + i ] !== b[ i ] ) return false;

  	}

  	return true;

  }

  let _id$3 = 0;

  class NodeUniformsGroup extends UniformsGroup {

  	constructor( name, groupNode ) {

  		super( name );

  		this.id = _id$3 ++;
  		this.groupNode = groupNode;

  		this.isNodeUniformsGroup = true;

  	}

  	getNodes() {

  		const nodes = [];

  		for ( const uniform of this.uniforms ) {

  			const node = uniform.nodeUniform.node;

  			if ( ! node ) throw new Error( 'NodeUniformsGroup: Uniform has no node.' );

  			nodes.push( node );

  		}

  		return nodes;

  	}

  }

  let _id$2 = 0;

  class SampledTexture extends Binding {

  	constructor( name, texture ) {

  		super( name );

  		this.id = _id$2 ++;

  		this.texture = texture;
  		this.version = texture ? texture.version : 0;
  		this.store = false;
  		this.generation = null;

  		this.isSampledTexture = true;

  	}

  	needsBindingsUpdate( generation ) {

  		const { texture } = this;

  		if ( generation !== this.generation ) {

  			this.generation = generation;

  			return true;

  		}

  		return texture.isVideoTexture;

  	}

  	update() {

  		const { texture, version } = this;

  		if ( version !== texture.version ) {

  			this.version = texture.version;

  			return true;

  		}

  		return false;

  	}

  }

  class NodeSampledTexture extends SampledTexture {

  	constructor( name, textureNode, groupNode, access = null ) {

  		super( name, textureNode ? textureNode.value : null );

  		this.textureNode = textureNode;
  		this.groupNode = groupNode;

  		this.access = access;

  	}

  	needsBindingsUpdate( generation ) {

  		return this.textureNode.value !== this.texture || super.needsBindingsUpdate( generation );

  	}

  	update() {

  		const { textureNode } = this;

  		if ( this.texture !== textureNode.value ) {

  			this.texture = textureNode.value;

  			return true;

  		}

  		return super.update();

  	}

  }

  class NodeSampledCubeTexture extends NodeSampledTexture {

  	constructor( name, textureNode, groupNode, access ) {

  		super( name, textureNode, groupNode, access );

  		this.isSampledCubeTexture = true;

  	}

  }

  class NodeSampledTexture3D extends NodeSampledTexture {

  	constructor( name, textureNode, groupNode, access ) {

  		super( name, textureNode, groupNode, access );

  		this.isSampledTexture3D = true;

  	}

  }

  const glslMethods = {
  	atan2: 'atan',
  	textureDimensions: 'textureSize',
  	equals: 'equal'
  };

  const precisionLib = {
  	low: 'lowp',
  	medium: 'mediump',
  	high: 'highp'
  };

  const supports$1 = {
  	swizzleAssign: true,
  	storageBuffer: false
  };

  const defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;

  class GLSLNodeBuilder extends NodeBuilder {

  	constructor( object, renderer ) {

  		super( object, renderer, new GLSLNodeParser() );

  		this.uniformGroups = {};
  		this.transforms = [];
  		this.extensions = {};

  		this.useComparisonMethod = true;

  	}

  	needsColorSpaceToLinearSRGB( texture ) {

  		return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;

  	}

  	getMethod( method ) {

  		return glslMethods[ method ] || method;

  	}

  	getOutputStructName() {

  		return '';

  	}

  	buildFunctionCode( shaderNode ) {

  		const layout = shaderNode.layout;
  		const flowData = this.flowShaderNode( shaderNode );

  		const parameters = [];

  		for ( const input of layout.inputs ) {

  			parameters.push( this.getType( input.type ) + ' ' + input.name );

  		}

  		//

  		const code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {

	${ flowData.vars }

${ flowData.code }
	return ${ flowData.result };

}`;

  		//

  		return code;

  	}

  	setupPBO( storageBufferNode ) {

  		const attribute = storageBufferNode.value;

  		if ( attribute.pbo === undefined ) {

  			const originalArray = attribute.array;
  			const numElements = attribute.count * attribute.itemSize;

  			const { itemSize } = attribute;

  			const isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );

  			let format = isInteger ? RedIntegerFormat : RedFormat;


  			if ( itemSize === 2 ) {

  				format = isInteger ? RGIntegerFormat : RGFormat;

  			} else if ( itemSize === 3 ) {

  				format = isInteger ? RGBIntegerFormat : RGBFormat;

  			} else if ( itemSize === 4 ) {

  				format = isInteger ? RGBAIntegerFormat : RGBAFormat;

  			}

  			const typeMap = {
  				Float32Array: FloatType,
  				Uint8Array: UnsignedByteType,
  				Uint16Array: UnsignedShortType,
  				Uint32Array: UnsignedIntType,
  				Int8Array: ByteType,
  				Int16Array: ShortType,
  				Int32Array: IntType,
  				Uint8ClampedArray: UnsignedByteType,
  			};

  			const width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );
  			let height = Math.ceil( ( numElements / itemSize ) / width );
  			if ( width * height * itemSize < numElements ) height ++; // Ensure enough space

  			const newSize = width * height * itemSize;

  			const newArray = new originalArray.constructor( newSize );

  			newArray.set( originalArray, 0 );

  			attribute.array = newArray;

  			const pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );
  			pboTexture.needsUpdate = true;
  			pboTexture.isPBOTexture = true;

  			const pbo = new TextureNode( pboTexture, null, null );
  			pbo.setPrecision( 'high' );

  			attribute.pboNode = pbo;
  			attribute.pbo = pbo.value;

  			this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );

  		}

  	}

  	getPropertyName( node, shaderStage = this.shaderStage ) {

  		if ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {

  			return shaderStage.charAt( 0 ) + '_' + node.name;

  		}

  		return super.getPropertyName( node, shaderStage );

  	}

  	generatePBO( storageArrayElementNode ) {

  		const { node, indexNode } = storageArrayElementNode;
  		const attribute = node.value;

  		if ( this.renderer.backend.has( attribute ) ) {

  			const attributeData = this.renderer.backend.get( attribute );
  			attributeData.pbo = attribute.pbo;

  		}


  		const nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );
  		const textureName = this.getPropertyName( nodeUniform );

  		this.increaseUsage( indexNode ); // force cache generate to be used as index in x,y
  		const indexSnippet = indexNode.build( this, 'uint' );

  		const elementNodeData = this.getDataFromNode( storageArrayElementNode );

  		let propertyName = elementNodeData.propertyName;

  		if ( propertyName === undefined ) {

  			// property element

  			const nodeVar = this.getVarFromNode( storageArrayElementNode );

  			propertyName = this.getPropertyName( nodeVar );

  			// property size

  			const bufferNodeData = this.getDataFromNode( node );

  			let propertySizeName = bufferNodeData.propertySizeName;

  			if ( propertySizeName === undefined ) {

  				propertySizeName = propertyName + 'Size';

  				this.getVarFromNode( node, propertySizeName, 'uint' );

  				this.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );

  				bufferNodeData.propertySizeName = propertySizeName;

  			}

  			//

  			const { itemSize } = attribute;

  			const channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );
  			const uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;

  			const snippet = this.generateTextureLoad( null, textureName, uvSnippet, null, '0' );

  			//


  			let prefix = 'vec4';

  			if ( attribute.pbo.type === UnsignedIntType ) {

  				prefix = 'uvec4';

  			} else if ( attribute.pbo.type === IntType ) {

  				prefix = 'ivec4';

  			}

  			this.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );

  			elementNodeData.propertyName = propertyName;

  		}

  		return propertyName;

  	}

  	generateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0' ) {

  		if ( depthSnippet ) {

  			return `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;

  		} else {

  			return `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;

  		}

  	}

  	generateTexture( texture, textureProperty, uvSnippet, depthSnippet ) {

  		if ( texture.isDepthTexture ) {

  			return `texture( ${ textureProperty }, ${ uvSnippet } ).x`;

  		} else {

  			if ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;

  			return `texture( ${ textureProperty }, ${ uvSnippet } )`;

  		}

  	}

  	generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet ) {

  		return `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;

  	}

  	generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet ) {

  		return `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;

  	}

  	generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet ) {

  		return `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;

  	}

  	generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			return `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;

  		} else {

  			console.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );

  		}

  	}

  	getVars( shaderStage ) {

  		const snippets = [];

  		const vars = this.vars[ shaderStage ];

  		if ( vars !== undefined ) {

  			for ( const variable of vars ) {

  				snippets.push( `${ this.getVar( variable.type, variable.name ) };` );

  			}

  		}

  		return snippets.join( '\n\t' );

  	}

  	getUniforms( shaderStage ) {

  		const uniforms = this.uniforms[ shaderStage ];

  		const bindingSnippets = [];
  		const uniformGroups = {};

  		for ( const uniform of uniforms ) {

  			let snippet = null;
  			let group = false;

  			if ( uniform.type === 'texture' ) {

  				const texture = uniform.node.value;

  				let typePrefix = '';

  				if ( texture.isDataTexture === true ) {


  					if ( texture.type === UnsignedIntType ) {

  						typePrefix = 'u';

  					} else if ( texture.type === IntType ) {

  						typePrefix = 'i';

  					}

  				}

  				if ( texture.compareFunction ) {

  					snippet = `sampler2DShadow ${ uniform.name };`;

  				} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

  					snippet = `${typePrefix}sampler2DArray ${ uniform.name };`;

  				} else {

  					snippet = `${typePrefix}sampler2D ${ uniform.name };`;

  				}

  			} else if ( uniform.type === 'cubeTexture' ) {

  				snippet = `samplerCube ${ uniform.name };`;

  			} else if ( uniform.type === 'texture3D' ) {

  				snippet = `sampler3D ${ uniform.name };`;

  			} else if ( uniform.type === 'buffer' ) {

  				const bufferNode = uniform.node;
  				const bufferType = this.getType( bufferNode.bufferType );
  				const bufferCount = bufferNode.bufferCount;

  				const bufferCountSnippet = bufferCount > 0 ? bufferCount : '';
  				snippet = `${bufferNode.name} {\n\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\n};\n`;

  			} else {

  				const vectorType = this.getVectorType( uniform.type );

  				snippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;

  				group = true;

  			}

  			const precision = uniform.node.precision;

  			if ( precision !== null ) {

  				snippet = precisionLib[ precision ] + ' ' + snippet;

  			}

  			if ( group ) {

  				snippet = '\t' + snippet;

  				const groupName = uniform.groupNode.name;
  				const groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );

  				groupSnippets.push( snippet );

  			} else {

  				snippet = 'uniform ' + snippet;

  				bindingSnippets.push( snippet );

  			}

  		}

  		let output = '';

  		for ( const name in uniformGroups ) {

  			const groupSnippets = uniformGroups[ name ];

  			output += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\n' ) ) + '\n';

  		}

  		output += bindingSnippets.join( '\n' );

  		return output;

  	}

  	getTypeFromAttribute( attribute ) {

  		let nodeType = super.getTypeFromAttribute( attribute );

  		if ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {

  			let dataAttribute = attribute;

  			if ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;

  			const array = dataAttribute.array;

  			if ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {

  				nodeType = nodeType.slice( 1 );

  			}

  		}

  		return nodeType;

  	}

  	getAttributes( shaderStage ) {

  		let snippet = '';

  		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

  			const attributes = this.getAttributesArray();

  			let location = 0;

  			for ( const attribute of attributes ) {

  				snippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\n`;

  			}

  		}

  		return snippet;

  	}

  	getStructMembers( struct ) {

  		const snippets = [];
  		const members = struct.getMemberTypes();

  		for ( let i = 0; i < members.length; i ++ ) {

  			const member = members[ i ];
  			snippets.push( `layout( location = ${i} ) out ${ member} m${i};` );

  		}

  		return snippets.join( '\n' );

  	}

  	getStructs( shaderStage ) {

  		const snippets = [];
  		const structs = this.structs[ shaderStage ];

  		if ( structs.length === 0 ) {

  			return 'layout( location = 0 ) out vec4 fragColor;\n';

  		}

  		for ( let index = 0, length = structs.length; index < length; index ++ ) {

  			const struct = structs[ index ];

  			let snippet = '\n';
  			snippet += this.getStructMembers( struct );
  			snippet += '\n';

  			snippets.push( snippet );

  		}

  		return snippets.join( '\n\n' );

  	}

  	getVaryings( shaderStage ) {

  		let snippet = '';

  		const varyings = this.varyings;

  		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

  			for ( const varying of varyings ) {

  				if ( shaderStage === 'compute' ) varying.needsInterpolation = true;
  				const type = varying.type;
  				const flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';

  				snippet += `${flat}${varying.needsInterpolation ? 'out' : '/*out*/'} ${type} ${varying.name};\n`;

  			}

  		} else if ( shaderStage === 'fragment' ) {

  			for ( const varying of varyings ) {

  				if ( varying.needsInterpolation ) {

  					const type = varying.type;
  					const flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';

  					snippet += `${flat}in ${type} ${varying.name};\n`;

  				}

  			}

  		}

  		return snippet;

  	}

  	getVertexIndex() {

  		return 'uint( gl_VertexID )';

  	}

  	getInstanceIndex() {

  		return 'uint( gl_InstanceID )';

  	}

  	getInvocationLocalIndex() {

  		const workgroupSize = this.object.workgroupSize;

  		const size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );

  		return `uint( gl_InstanceID ) % ${size}u`;

  	}

  	getDrawIndex() {

  		const extensions = this.renderer.backend.extensions;

  		if ( extensions.has( 'WEBGL_multi_draw' ) ) {

  			return 'uint( gl_DrawID )';

  		}

  		return null;

  	}

  	getFrontFacing() {

  		return 'gl_FrontFacing';

  	}

  	getFragCoord() {

  		return 'gl_FragCoord.xy';

  	}

  	getFragDepth() {

  		return 'gl_FragDepth';

  	}

  	enableExtension( name, behavior, shaderStage = this.shaderStage ) {

  		const map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );

  		if ( map.has( name ) === false ) {

  			map.set( name, {
  				name,
  				behavior
  			} );

  		}

  	}

  	getExtensions( shaderStage ) {

  		const snippets = [];

  		if ( shaderStage === 'vertex' ) {

  			const ext = this.renderer.backend.extensions;
  			const isBatchedMesh = this.object.isBatchedMesh;

  			if ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {

  				this.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );

  			}

  		}

  		const extensions = this.extensions[ shaderStage ];

  		if ( extensions !== undefined ) {

  			for ( const { name, behavior } of extensions.values() ) {

  				snippets.push( `#extension ${name} : ${behavior}` );

  			}

  		}

  		return snippets.join( '\n' );

  	}

  	isAvailable( name ) {

  		let result = supports$1[ name ];

  		if ( result === undefined ) {

  			if ( name === 'float32Filterable' ) {

  				const extensions = this.renderer.backend.extensions;

  				if ( extensions.has( 'OES_texture_float_linear' ) ) {

  					extensions.get( 'OES_texture_float_linear' );
  					result = true;

  				} else {

  					result = false;

  				}

  			}

  			supports$1[ name ] = result;

  		}

  		return result;

  	}

  	isFlipY() {

  		return true;

  	}

  	registerTransform( varyingName, attributeNode ) {

  		this.transforms.push( { varyingName, attributeNode } );

  	}

  	getTransforms( /* shaderStage  */ ) {

  		const transforms = this.transforms;

  		let snippet = '';

  		for ( let i = 0; i < transforms.length; i ++ ) {

  			const transform = transforms[ i ];

  			const attributeName = this.getPropertyName( transform.attributeNode );

  			snippet += `${ transform.varyingName } = ${ attributeName };\n\t`;

  		}

  		return snippet;

  	}

  	_getGLSLUniformStruct( name, vars ) {

  		return `
layout( std140 ) uniform ${name} {
${vars}
};`;

  	}

  	_getGLSLVertexCode( shaderData ) {

  		return `#version 300 es

${ this.getSignature() }

// extensions 
${shaderData.extensions}

// precision
${ defaultPrecisions }

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// transforms
	${shaderData.transforms}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;

  	}

  	_getGLSLFragmentCode( shaderData ) {

  		return `#version 300 es

${ this.getSignature() }

// precision
${ defaultPrecisions }

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

${shaderData.structs}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

  	}

  	buildCode() {

  		const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };

  		this.sortBindingGroups();

  		for ( const shaderStage in shadersData ) {

  			let flow = '// code\n\n';
  			flow += this.flowCode[ shaderStage ];

  			const flowNodes = this.flowNodes[ shaderStage ];
  			const mainNode = flowNodes[ flowNodes.length - 1 ];

  			for ( const node of flowNodes ) {

  				const flowSlotData = this.getFlowData( node/*, shaderStage*/ );
  				const slotName = node.name;

  				if ( slotName ) {

  					if ( flow.length > 0 ) flow += '\n';

  					flow += `\t// flow -> ${ slotName }\n\t`;

  				}

  				flow += `${ flowSlotData.code }\n\t`;

  				if ( node === mainNode && shaderStage !== 'compute' ) {

  					flow += '// result\n\t';

  					if ( shaderStage === 'vertex' ) {

  						flow += 'gl_Position = ';
  						flow += `${ flowSlotData.result };`;

  					} else if ( shaderStage === 'fragment' ) {

  						if ( ! node.outputNode.isOutputStructNode ) {

  							flow += 'fragColor = ';
  							flow += `${ flowSlotData.result };`;

  						}

  					}

  				}

  			}

  			const stageData = shadersData[ shaderStage ];

  			stageData.extensions = this.getExtensions( shaderStage );
  			stageData.uniforms = this.getUniforms( shaderStage );
  			stageData.attributes = this.getAttributes( shaderStage );
  			stageData.varyings = this.getVaryings( shaderStage );
  			stageData.vars = this.getVars( shaderStage );
  			stageData.structs = this.getStructs( shaderStage );
  			stageData.codes = this.getCodes( shaderStage );
  			stageData.transforms = this.getTransforms( shaderStage );
  			stageData.flow = flow;

  		}

  		if ( this.material !== null ) {

  			this.vertexShader = this._getGLSLVertexCode( shadersData.vertex );
  			this.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );

  		} else {

  			this.computeShader = this._getGLSLVertexCode( shadersData.compute );

  		}

  	}

  	getUniformFromNode( node, type, shaderStage, name = null ) {

  		const uniformNode = super.getUniformFromNode( node, type, shaderStage, name );
  		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

  		let uniformGPU = nodeData.uniformGPU;

  		if ( uniformGPU === undefined ) {

  			const group = node.groupNode;
  			const groupName = group.name;

  			const bindings = this.getBindGroupArray( groupName, shaderStage );

  			if ( type === 'texture' ) {

  				uniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );
  				bindings.push( uniformGPU );

  			} else if ( type === 'cubeTexture' ) {

  				uniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );
  				bindings.push( uniformGPU );

  			} else if ( type === 'texture3D' ) {

  				uniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );
  				bindings.push( uniformGPU );

  			} else if ( type === 'buffer' ) {

  				node.name = `NodeBuffer_${ node.id }`;
  				uniformNode.name = `buffer${ node.id }`;

  				const buffer = new NodeUniformBuffer( node, group );
  				buffer.name = node.name;

  				bindings.push( buffer );

  				uniformGPU = buffer;

  			} else {

  				const uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );

  				let uniformsGroup = uniformsStage[ groupName ];

  				if ( uniformsGroup === undefined ) {

  					uniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );
  					//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

  					uniformsStage[ groupName ] = uniformsGroup;

  					bindings.push( uniformsGroup );

  				}

  				uniformGPU = this.getNodeUniform( uniformNode, type );

  				uniformsGroup.addUniform( uniformGPU );

  			}

  			nodeData.uniformGPU = uniformGPU;

  		}

  		return uniformNode;

  	}

  }

  let vector2 = null;
  let vector4 = null;
  let color4 = null;

  class Backend {

  	constructor( parameters = {} ) {

  		this.parameters = Object.assign( {}, parameters );
  		this.data = new WeakMap();
  		this.renderer = null;
  		this.domElement = null;

  	}

  	async init( renderer ) {

  		this.renderer = renderer;

  	}

  	// render context

  	begin( /*renderContext*/ ) { }

  	finish( /*renderContext*/ ) { }

  	// render object

  	draw( /*renderObject, info*/ ) { }

  	// program

  	createProgram( /*program*/ ) { }

  	destroyProgram( /*program*/ ) { }

  	// bindings

  	createBindings( /*bingGroup, bindings*/ ) { }

  	updateBindings( /*bingGroup, bindings*/ ) { }

  	// pipeline

  	createRenderPipeline( /*renderObject*/ ) { }

  	createComputePipeline( /*computeNode, pipeline*/ ) { }

  	destroyPipeline( /*pipeline*/ ) { }

  	// cache key

  	needsRenderUpdate( /*renderObject*/ ) { } // return Boolean ( fast test )

  	getRenderCacheKey( /*renderObject*/ ) { } // return String

  	// node builder

  	createNodeBuilder( /*renderObject*/ ) { } // return NodeBuilder (ADD IT)

  	// textures

  	createSampler( /*texture*/ ) { }

  	createDefaultTexture( /*texture*/ ) { }

  	createTexture( /*texture*/ ) { }

  	copyTextureToBuffer( /*texture, x, y, width, height*/ ) {}

  	// attributes

  	createAttribute( /*attribute*/ ) { }

  	createIndexAttribute( /*attribute*/ ) { }

  	updateAttribute( /*attribute*/ ) { }

  	destroyAttribute( /*attribute*/ ) { }

  	// canvas

  	getContext() { }

  	updateSize() { }

  	// utils

  	resolveTimestampAsync( /*renderContext, type*/ ) { }

  	hasFeatureAsync( /*name*/ ) { } // return Boolean

  	hasFeature( /*name*/ ) { } // return Boolean

  	getInstanceCount( renderObject ) {

  		const { object, geometry } = renderObject;

  		return geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );

  	}

  	getDrawingBufferSize() {

  		vector2 = vector2 || new Vector2();

  		return this.renderer.getDrawingBufferSize( vector2 );

  	}

  	getScissor() {

  		vector4 = vector4 || new Vector4();

  		return this.renderer.getScissor( vector4 );

  	}

  	setScissorTest( /*boolean*/ ) { }

  	getClearColor() {

  		const renderer = this.renderer;

  		color4 = color4 || new Color4();

  		renderer.getClearColor( color4 );

  		color4.getRGB( color4, this.renderer.currentColorSpace );

  		return color4;

  	}

  	getDomElement() {

  		let domElement = this.domElement;

  		if ( domElement === null ) {

  			domElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : createCanvasElement();

  			// OffscreenCanvas does not have setAttribute, see #22811
  			if ( 'setAttribute' in domElement ) domElement.setAttribute( 'data-engine', `three.js r${REVISION} webgpu` );

  			this.domElement = domElement;

  		}

  		return domElement;

  	}

  	// resource properties

  	set( object, value ) {

  		this.data.set( object, value );

  	}

  	get( object ) {

  		let map = this.data.get( object );

  		if ( map === undefined ) {

  			map = {};
  			this.data.set( object, map );

  		}

  		return map;

  	}

  	has( object ) {

  		return this.data.has( object );

  	}

  	delete( object ) {

  		this.data.delete( object );

  	}

  }

  let _id$1 = 0;

  class DualAttributeData {

  	constructor( attributeData, dualBuffer ) {

  		this.buffers = [ attributeData.bufferGPU, dualBuffer ];
  		this.type = attributeData.type;
  		this.bufferType = attributeData.bufferType;
  		this.pbo = attributeData.pbo;
  		this.byteLength = attributeData.byteLength;
  		this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
  		this.version = attributeData.version;
  		this.isInteger = attributeData.isInteger;
  		this.activeBufferIndex = 0;
  		this.baseId = attributeData.id;

  	}


  	get id() {

  		return `${ this.baseId }|${ this.activeBufferIndex }`;

  	}

  	get bufferGPU() {

  		return this.buffers[ this.activeBufferIndex ];

  	}

  	get transformBuffer() {

  		return this.buffers[ this.activeBufferIndex ^ 1 ];

  	}

  	switchBuffers() {

  		this.activeBufferIndex ^= 1;

  	}

  }

  class WebGLAttributeUtils {

  	constructor( backend ) {

  		this.backend = backend;

  	}

  	createAttribute( attribute, bufferType ) {

  		const backend = this.backend;
  		const { gl } = backend;

  		const array = attribute.array;
  		const usage = attribute.usage || gl.STATIC_DRAW;

  		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
  		const bufferData = backend.get( bufferAttribute );

  		let bufferGPU = bufferData.bufferGPU;

  		if ( bufferGPU === undefined ) {

  			bufferGPU = this._createBuffer( gl, bufferType, array, usage );

  			bufferData.bufferGPU = bufferGPU;
  			bufferData.bufferType = bufferType;
  			bufferData.version = bufferAttribute.version;

  		}

  		//attribute.onUploadCallback();

  		let type;

  		if ( array instanceof Float32Array ) {

  			type = gl.FLOAT;

  		} else if ( array instanceof Uint16Array ) {

  			if ( attribute.isFloat16BufferAttribute ) {

  				type = gl.HALF_FLOAT;

  			} else {

  				type = gl.UNSIGNED_SHORT;

  			}

  		} else if ( array instanceof Int16Array ) {

  			type = gl.SHORT;

  		} else if ( array instanceof Uint32Array ) {

  			type = gl.UNSIGNED_INT;

  		} else if ( array instanceof Int32Array ) {

  			type = gl.INT;

  		} else if ( array instanceof Int8Array ) {

  			type = gl.BYTE;

  		} else if ( array instanceof Uint8Array ) {

  			type = gl.UNSIGNED_BYTE;

  		} else if ( array instanceof Uint8ClampedArray ) {

  			type = gl.UNSIGNED_BYTE;

  		} else {

  			throw new Error( 'THREE.WebGLBackend: Unsupported buffer data format: ' + array );

  		}

  		let attributeData = {
  			bufferGPU,
  			bufferType,
  			type,
  			byteLength: array.byteLength,
  			bytesPerElement: array.BYTES_PER_ELEMENT,
  			version: attribute.version,
  			pbo: attribute.pbo,
  			isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,
  			id: _id$1 ++
  		};

  		if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {

  			// create buffer for tranform feedback use
  			const bufferGPUDual = this._createBuffer( gl, bufferType, array, usage );
  			attributeData = new DualAttributeData( attributeData, bufferGPUDual );

  		}

  		backend.set( attribute, attributeData );

  	}

  	updateAttribute( attribute ) {

  		const backend = this.backend;
  		const { gl } = backend;

  		const array = attribute.array;
  		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
  		const bufferData = backend.get( bufferAttribute );
  		const bufferType = bufferData.bufferType;
  		const updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;

  		gl.bindBuffer( bufferType, bufferData.bufferGPU );

  		if ( updateRanges.length === 0 ) {

  			// Not using update ranges

  			gl.bufferSubData( bufferType, 0, array );

  		} else {

  			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

  				const range = updateRanges[ i ];
  				gl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,
  					array, range.start, range.count );

  			}

  			bufferAttribute.clearUpdateRanges();

  		}

  		gl.bindBuffer( bufferType, null );

  		bufferData.version = bufferAttribute.version;

  	}

  	destroyAttribute( attribute ) {

  		const backend = this.backend;
  		const { gl } = backend;

  		if ( attribute.isInterleavedBufferAttribute ) {

  			backend.delete( attribute.data );

  		}

  		const attributeData = backend.get( attribute );

  		gl.deleteBuffer( attributeData.bufferGPU );

  		backend.delete( attribute );

  	}

  	async getArrayBufferAsync( attribute ) {

  		const backend = this.backend;
  		const { gl } = backend;

  		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
  		const { bufferGPU } = backend.get( bufferAttribute );

  		const array = attribute.array;
  		const byteLength = array.byteLength;

  		gl.bindBuffer( gl.COPY_READ_BUFFER, bufferGPU );

  		const writeBuffer = gl.createBuffer();

  		gl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );
  		gl.bufferData( gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ );

  		gl.copyBufferSubData( gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength );

  		await backend.utils._clientWaitAsync();

  		const dstBuffer = new attribute.array.constructor( array.length );

  		// Ensure the buffer is bound before reading
  		gl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );

  		gl.getBufferSubData( gl.COPY_WRITE_BUFFER, 0, dstBuffer );

  		gl.deleteBuffer( writeBuffer );

  		gl.bindBuffer( gl.COPY_READ_BUFFER, null );
  		gl.bindBuffer( gl.COPY_WRITE_BUFFER, null );

  		return dstBuffer.buffer;

  	}

  	_createBuffer( gl, bufferType, array, usage ) {

  		const bufferGPU = gl.createBuffer();

  		gl.bindBuffer( bufferType, bufferGPU );
  		gl.bufferData( bufferType, array, usage );
  		gl.bindBuffer( bufferType, null );

  		return bufferGPU;

  	}

  }

  let initialized$1 = false, equationToGL, factorToGL;

  class WebGLState {

  	constructor( backend ) {

  		this.backend = backend;

  		this.gl = this.backend.gl;

  		this.enabled = {};
  		this.currentFlipSided = null;
  		this.currentCullFace = null;
  		this.currentProgram = null;
  		this.currentBlendingEnabled = false;
  		this.currentBlending = null;
  		this.currentBlendSrc = null;
  		this.currentBlendDst = null;
  		this.currentBlendSrcAlpha = null;
  		this.currentBlendDstAlpha = null;
  		this.currentPremultipledAlpha = null;
  		this.currentPolygonOffsetFactor = null;
  		this.currentPolygonOffsetUnits = null;
  		this.currentColorMask = null;
  		this.currentDepthFunc = null;
  		this.currentDepthMask = null;
  		this.currentStencilFunc = null;
  		this.currentStencilRef = null;
  		this.currentStencilFuncMask = null;
  		this.currentStencilFail = null;
  		this.currentStencilZFail = null;
  		this.currentStencilZPass = null;
  		this.currentStencilMask = null;
  		this.currentLineWidth = null;

  		this.currentBoundFramebuffers = {};
  		this.currentDrawbuffers = new WeakMap();

  		this.maxTextures = this.gl.getParameter( this.gl.MAX_TEXTURE_IMAGE_UNITS );
  		this.currentTextureSlot = null;
  		this.currentBoundTextures = {};
  		this.currentBoundBufferBases = {};

  		if ( initialized$1 === false ) {

  			this._init( this.gl );

  			initialized$1 = true;

  		}

  	}

  	_init( gl ) {

  		// Store only WebGL constants here.

  		equationToGL = {
  			[ AddEquation ]: gl.FUNC_ADD,
  			[ SubtractEquation ]: gl.FUNC_SUBTRACT,
  			[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
  		};

  		factorToGL = {
  			[ ZeroFactor ]: gl.ZERO,
  			[ OneFactor ]: gl.ONE,
  			[ SrcColorFactor ]: gl.SRC_COLOR,
  			[ SrcAlphaFactor ]: gl.SRC_ALPHA,
  			[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
  			[ DstColorFactor ]: gl.DST_COLOR,
  			[ DstAlphaFactor ]: gl.DST_ALPHA,
  			[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
  			[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
  			[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
  			[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA
  		};

  	}

  	enable( id ) {

  		const { enabled } = this;

  		if ( enabled[ id ] !== true ) {

  			this.gl.enable( id );
  			enabled[ id ] = true;

  		}

  	}

  	disable( id ) {

  		const { enabled } = this;

  		if ( enabled[ id ] !== false ) {

  			this.gl.disable( id );
  			enabled[ id ] = false;

  		}

  	}

  	setFlipSided( flipSided ) {

  		if ( this.currentFlipSided !== flipSided ) {

  			const { gl } = this;

  			if ( flipSided ) {

  				gl.frontFace( gl.CW );

  			} else {

  				gl.frontFace( gl.CCW );

  			}

  			this.currentFlipSided = flipSided;

  		}

  	}

  	setCullFace( cullFace ) {

  		const { gl } = this;

  		if ( cullFace !== CullFaceNone ) {

  			this.enable( gl.CULL_FACE );

  			if ( cullFace !== this.currentCullFace ) {

  				if ( cullFace === CullFaceBack ) {

  					gl.cullFace( gl.BACK );

  				} else if ( cullFace === CullFaceFront ) {

  					gl.cullFace( gl.FRONT );

  				} else {

  					gl.cullFace( gl.FRONT_AND_BACK );

  				}

  			}

  		} else {

  			this.disable( gl.CULL_FACE );

  		}

  		this.currentCullFace = cullFace;

  	}

  	setLineWidth( width ) {

  		const { currentLineWidth, gl } = this;

  		if ( width !== currentLineWidth ) {

  			gl.lineWidth( width );

  			this.currentLineWidth = width;

  		}

  	}


  	setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

  		const { gl } = this;

  		if ( blending === NoBlending ) {

  			if ( this.currentBlendingEnabled === true ) {

  				this.disable( gl.BLEND );
  				this.currentBlendingEnabled = false;

  			}

  			return;

  		}

  		if ( this.currentBlendingEnabled === false ) {

  			this.enable( gl.BLEND );
  			this.currentBlendingEnabled = true;

  		}

  		if ( blending !== CustomBlending ) {

  			if ( blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha ) {

  				if ( this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation ) {

  					gl.blendEquation( gl.FUNC_ADD );

  					this.currentBlendEquation = AddEquation;
  					this.currentBlendEquationAlpha = AddEquation;

  				}

  				if ( premultipliedAlpha ) {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
  							break;

  						case AdditiveBlending:
  							gl.blendFunc( gl.ONE, gl.ONE );
  							break;

  						case SubtractiveBlending:
  							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
  							break;

  						case MultiplyBlending:
  							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
  							break;

  						default:
  							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				} else {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
  							break;

  						case AdditiveBlending:
  							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
  							break;

  						case SubtractiveBlending:
  							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
  							break;

  						case MultiplyBlending:
  							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
  							break;

  						default:
  							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				}

  				this.currentBlendSrc = null;
  				this.currentBlendDst = null;
  				this.currentBlendSrcAlpha = null;
  				this.currentBlendDstAlpha = null;

  				this.currentBlending = blending;
  				this.currentPremultipledAlpha = premultipliedAlpha;

  			}

  			return;

  		}

  		// custom blending

  		blendEquationAlpha = blendEquationAlpha || blendEquation;
  		blendSrcAlpha = blendSrcAlpha || blendSrc;
  		blendDstAlpha = blendDstAlpha || blendDst;

  		if ( blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha ) {

  			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

  			this.currentBlendEquation = blendEquation;
  			this.currentBlendEquationAlpha = blendEquationAlpha;

  		}

  		if ( blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha ) {

  			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

  			this.currentBlendSrc = blendSrc;
  			this.currentBlendDst = blendDst;
  			this.currentBlendSrcAlpha = blendSrcAlpha;
  			this.currentBlendDstAlpha = blendDstAlpha;

  		}

  		this.currentBlending = blending;
  		this.currentPremultipledAlpha = false;

  	}

  	setColorMask( colorMask ) {

  		if ( this.currentColorMask !== colorMask ) {

  			this.gl.colorMask( colorMask, colorMask, colorMask, colorMask );
  			this.currentColorMask = colorMask;

  		}

  	}

  	setDepthTest( depthTest ) {

  		const { gl } = this;

  		if ( depthTest ) {

  			this.enable( gl.DEPTH_TEST );

  		} else {

  			this.disable( gl.DEPTH_TEST );

  		}

  	}

  	setDepthMask( depthMask ) {

  		if ( this.currentDepthMask !== depthMask ) {

  			this.gl.depthMask( depthMask );
  			this.currentDepthMask = depthMask;

  		}

  	}

  	setDepthFunc( depthFunc ) {

  		if ( this.currentDepthFunc !== depthFunc ) {

  			const { gl } = this;

  			switch ( depthFunc ) {

  				case NeverDepth:

  					gl.depthFunc( gl.NEVER );
  					break;

  				case AlwaysDepth:

  					gl.depthFunc( gl.ALWAYS );
  					break;

  				case LessDepth:

  					gl.depthFunc( gl.LESS );
  					break;

  				case LessEqualDepth:

  					gl.depthFunc( gl.LEQUAL );
  					break;

  				case EqualDepth:

  					gl.depthFunc( gl.EQUAL );
  					break;

  				case GreaterEqualDepth:

  					gl.depthFunc( gl.GEQUAL );
  					break;

  				case GreaterDepth:

  					gl.depthFunc( gl.GREATER );
  					break;

  				case NotEqualDepth:

  					gl.depthFunc( gl.NOTEQUAL );
  					break;

  				default:

  					gl.depthFunc( gl.LEQUAL );

  			}

  			this.currentDepthFunc = depthFunc;

  		}

  	}

  	setStencilTest( stencilTest ) {

  		const { gl } = this;

  		if ( stencilTest ) {

  			this.enable( gl.STENCIL_TEST );

  		} else {

  			this.disable( gl.STENCIL_TEST );

  		}

  	}

  	setStencilMask( stencilMask ) {

  		if ( this.currentStencilMask !== stencilMask ) {

  			this.gl.stencilMask( stencilMask );
  			this.currentStencilMask = stencilMask;

  		}

  	}

  	setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

  		if ( this.currentStencilFunc !== stencilFunc ||
  			 this.currentStencilRef !== stencilRef ||
  			 this.currentStencilFuncMask !== stencilMask ) {

  			this.gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

  			this.currentStencilFunc = stencilFunc;
  			this.currentStencilRef = stencilRef;
  			this.currentStencilFuncMask = stencilMask;

  		}

  	}

  	setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

  		if ( this.currentStencilFail !== stencilFail ||
  			 this.currentStencilZFail !== stencilZFail ||
  			 this.currentStencilZPass !== stencilZPass ) {

  			this.gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

  			this.currentStencilFail = stencilFail;
  			this.currentStencilZFail = stencilZFail;
  			this.currentStencilZPass = stencilZPass;

  		}

  	}

  	setMaterial( material, frontFaceCW ) {

  		const { gl } = this;

  		material.side === DoubleSide
  			? this.disable( gl.CULL_FACE )
  			: this.enable( gl.CULL_FACE );

  		let flipSided = ( material.side === BackSide );
  		if ( frontFaceCW ) flipSided = ! flipSided;

  		this.setFlipSided( flipSided );

  		( material.blending === NormalBlending && material.transparent === false )
  			? this.setBlending( NoBlending )
  			: this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

  		this.setDepthFunc( material.depthFunc );
  		this.setDepthTest( material.depthTest );
  		this.setDepthMask( material.depthWrite );
  		this.setColorMask( material.colorWrite );

  		const stencilWrite = material.stencilWrite;
  		this.setStencilTest( stencilWrite );
  		if ( stencilWrite ) {

  			this.setStencilMask( material.stencilWriteMask );
  			this.setStencilFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
  			this.setStencilOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

  		}

  		this.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  		material.alphaToCoverage === true && this.backend.renderer.samples > 1
  			? this.enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
  			: this.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

  	}

  	setPolygonOffset( polygonOffset, factor, units ) {

  		const { gl } = this;

  		if ( polygonOffset ) {

  			this.enable( gl.POLYGON_OFFSET_FILL );

  			if ( this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units ) {

  				gl.polygonOffset( factor, units );

  				this.currentPolygonOffsetFactor = factor;
  				this.currentPolygonOffsetUnits = units;

  			}

  		} else {

  			this.disable( gl.POLYGON_OFFSET_FILL );

  		}

  	}

  	useProgram( program ) {

  		if ( this.currentProgram !== program ) {

  			this.gl.useProgram( program );

  			this.currentProgram = program;

  			return true;

  		}

  		return false;

  	}

  	// framebuffer


  	bindFramebuffer( target, framebuffer ) {

  		const { gl, currentBoundFramebuffers } = this;

  		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

  			gl.bindFramebuffer( target, framebuffer );

  			currentBoundFramebuffers[ target ] = framebuffer;

  			// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

  			if ( target === gl.DRAW_FRAMEBUFFER ) {

  				currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

  			}

  			if ( target === gl.FRAMEBUFFER ) {

  				currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

  			}

  			return true;

  		}

  		return false;

  	}

  	drawBuffers( renderContext, framebuffer ) {

  		const { gl } = this;

  		let drawBuffers = [];

  		let needsUpdate = false;

  		if ( renderContext.textures !== null ) {

  			drawBuffers = this.currentDrawbuffers.get( framebuffer );

  			if ( drawBuffers === undefined ) {

  				drawBuffers = [];
  				this.currentDrawbuffers.set( framebuffer, drawBuffers );

  			}


  			const textures = renderContext.textures;

  			if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

  				for ( let i = 0, il = textures.length; i < il; i ++ ) {

  					drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

  				}

  				drawBuffers.length = textures.length;

  				needsUpdate = true;

  			}


  		} else {

  			if ( drawBuffers[ 0 ] !== gl.BACK ) {

  				drawBuffers[ 0 ] = gl.BACK;

  				needsUpdate = true;

  			}

  		}

  		if ( needsUpdate ) {

  			gl.drawBuffers( drawBuffers );

  		}

  	}


  	// texture

  	activeTexture( webglSlot ) {

  		const { gl, currentTextureSlot, maxTextures } = this;

  		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

  		if ( currentTextureSlot !== webglSlot ) {

  			gl.activeTexture( webglSlot );
  			this.currentTextureSlot = webglSlot;

  		}

  	}

  	bindTexture( webglType, webglTexture, webglSlot ) {

  		const { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;

  		if ( webglSlot === undefined ) {

  			if ( currentTextureSlot === null ) {

  				webglSlot = gl.TEXTURE0 + maxTextures - 1;

  			} else {

  				webglSlot = currentTextureSlot;

  			}

  		}

  		let boundTexture = currentBoundTextures[ webglSlot ];

  		if ( boundTexture === undefined ) {

  			boundTexture = { type: undefined, texture: undefined };
  			currentBoundTextures[ webglSlot ] = boundTexture;

  		}

  		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

  			if ( currentTextureSlot !== webglSlot ) {

  				gl.activeTexture( webglSlot );
  				this.currentTextureSlot = webglSlot;

  			}

  			gl.bindTexture( webglType, webglTexture );

  			boundTexture.type = webglType;
  			boundTexture.texture = webglTexture;

  		}

  	}

  	bindBufferBase( target, index, buffer ) {

  		const { gl } = this;

  		const key = `${target}-${index}`;

  		if ( this.currentBoundBufferBases[ key ] !== buffer ) {

  			gl.bindBufferBase( target, index, buffer );
  			this.currentBoundBufferBases[ key ] = buffer;

  			return true;

  		}

  		return false;

  	}


  	unbindTexture() {

  		const { gl, currentTextureSlot, currentBoundTextures } = this;

  		const boundTexture = currentBoundTextures[ currentTextureSlot ];

  		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

  			gl.bindTexture( boundTexture.type, null );

  			boundTexture.type = undefined;
  			boundTexture.texture = undefined;

  		}

  	}

  }

  class WebGLUtils {

  	constructor( backend ) {

  		this.backend = backend;

  		this.gl = this.backend.gl;
  		this.extensions = backend.extensions;

  	}

  	convert( p, colorSpace = NoColorSpace ) {

  		const { gl, extensions } = this;

  		let extension;

  		if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
  		if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
  		if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
  		if ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;

  		if ( p === ByteType ) return gl.BYTE;
  		if ( p === ShortType ) return gl.SHORT;
  		if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
  		if ( p === IntType ) return gl.INT;
  		if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
  		if ( p === FloatType ) return gl.FLOAT;

  		if ( p === HalfFloatType ) {

  			return gl.HALF_FLOAT;

  		}

  		if ( p === AlphaFormat ) return gl.ALPHA;
  		if ( p === RGBFormat ) return gl.RGB;
  		if ( p === RGBAFormat ) return gl.RGBA;
  		if ( p === LuminanceFormat ) return gl.LUMINANCE;
  		if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
  		if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
  		if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

  		// WebGL2 formats.

  		if ( p === RedFormat ) return gl.RED;
  		if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
  		if ( p === RGFormat ) return gl.RG;
  		if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
  		if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

  		// S3TC

  		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

  			if ( colorSpace === SRGBColorSpace ) {

  				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

  				if ( extension !== null ) {

  					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
  					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

  				} else {

  					return null;

  				}

  			} else {

  				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

  				if ( extension !== null ) {

  					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
  					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

  				} else {

  					return null;

  				}

  			}

  		}

  		// PVRTC

  		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  			if ( extension !== null ) {

  				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
  				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
  				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
  				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

  			} else {

  				return null;

  			}

  		}

  		// ETC

  		if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

  			if ( extension !== null ) {

  				if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
  				if ( p === RGBA_ETC2_EAC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

  			} else {

  				return null;

  			}

  		}

  		// ASTC

  		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
  			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
  			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
  			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
  			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

  			if ( extension !== null ) {

  				if ( p === RGBA_ASTC_4x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
  				if ( p === RGBA_ASTC_5x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
  				if ( p === RGBA_ASTC_5x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
  				if ( p === RGBA_ASTC_6x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
  				if ( p === RGBA_ASTC_6x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
  				if ( p === RGBA_ASTC_8x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
  				if ( p === RGBA_ASTC_8x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
  				if ( p === RGBA_ASTC_8x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
  				if ( p === RGBA_ASTC_10x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
  				if ( p === RGBA_ASTC_10x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
  				if ( p === RGBA_ASTC_10x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
  				if ( p === RGBA_ASTC_10x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
  				if ( p === RGBA_ASTC_12x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
  				if ( p === RGBA_ASTC_12x12_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

  			} else {

  				return null;

  			}

  		}

  		// BPTC

  		if ( p === RGBA_BPTC_Format ) {

  			extension = extensions.get( 'EXT_texture_compression_bptc' );

  			if ( extension !== null ) {

  				if ( p === RGBA_BPTC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

  			} else {

  				return null;

  			}

  		}

  		// RGTC

  		if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

  			extension = extensions.get( 'EXT_texture_compression_rgtc' );

  			if ( extension !== null ) {

  				if ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
  				if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
  				if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
  				if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

  			} else {

  				return null;

  			}

  		}

  		//

  		if ( p === UnsignedInt248Type ) {

  			return gl.UNSIGNED_INT_24_8;

  		}

  		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

  		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

  	}

  	_clientWaitAsync() {

  		const { gl } = this;

  		const sync = gl.fenceSync( gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );

  		gl.flush();

  		return new Promise( ( resolve, reject ) => {

  			function test() {

  				const res = gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 );

  				if ( res === gl.WAIT_FAILED ) {

  					gl.deleteSync( sync );

  					reject();
  					return;

  				}

  				if ( res === gl.TIMEOUT_EXPIRED ) {

  					requestAnimationFrame( test );
  					return;

  				}

  				gl.deleteSync( sync );

  				resolve();

  			}

  			test();

  		} );

  	}

  }

  let initialized = false, wrappingToGL, filterToGL, compareToGL;

  class WebGLTextureUtils {

  	constructor( backend ) {

  		this.backend = backend;

  		this.gl = backend.gl;
  		this.extensions = backend.extensions;
  		this.defaultTextures = {};

  		if ( initialized === false ) {

  			this._init( this.gl );

  			initialized = true;

  		}

  	}

  	_init( gl ) {

  		// Store only WebGL constants here.

  		wrappingToGL = {
  			[ RepeatWrapping ]: gl.REPEAT,
  			[ ClampToEdgeWrapping ]: gl.CLAMP_TO_EDGE,
  			[ MirroredRepeatWrapping ]: gl.MIRRORED_REPEAT
  		};

  		filterToGL = {
  			[ NearestFilter ]: gl.NEAREST,
  			[ NearestMipmapNearestFilter ]: gl.NEAREST_MIPMAP_NEAREST,
  			[ NearestMipmapLinearFilter ]: gl.NEAREST_MIPMAP_LINEAR,

  			[ LinearFilter ]: gl.LINEAR,
  			[ LinearMipmapNearestFilter ]: gl.LINEAR_MIPMAP_NEAREST,
  			[ LinearMipmapLinearFilter ]: gl.LINEAR_MIPMAP_LINEAR
  		};

  		compareToGL = {
  			[ NeverCompare ]: gl.NEVER,
  			[ AlwaysCompare ]: gl.ALWAYS,
  			[ LessCompare ]: gl.LESS,
  			[ LessEqualCompare ]: gl.LEQUAL,
  			[ EqualCompare ]: gl.EQUAL,
  			[ GreaterEqualCompare ]: gl.GEQUAL,
  			[ GreaterCompare ]: gl.GREATER,
  			[ NotEqualCompare ]: gl.NOTEQUAL
  		};

  	}

  	filterFallback( f ) {

  		const { gl } = this;

  		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

  			return gl.NEAREST;

  		}

  		return gl.LINEAR;

  	}

  	getGLTextureType( texture ) {

  		const { gl } = this;

  		let glTextureType;

  		if ( texture.isCubeTexture === true ) {

  			glTextureType = gl.TEXTURE_CUBE_MAP;

  		} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

  			glTextureType = gl.TEXTURE_2D_ARRAY;

  		} else if ( texture.isData3DTexture === true ) { // TODO: isCompressed3DTexture, wait for #26642

  			glTextureType = gl.TEXTURE_3D;

  		} else {

  			glTextureType = gl.TEXTURE_2D;


  		}

  		return glTextureType;

  	}

  	getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

  		const { gl, extensions } = this;

  		if ( internalFormatName !== null ) {

  			if ( gl[ internalFormatName ] !== undefined ) return gl[ internalFormatName ];

  			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

  		}

  		let internalFormat = glFormat;

  		if ( glFormat === gl.RED ) {

  			if ( glType === gl.FLOAT ) internalFormat = gl.R32F;
  			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.R16F;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.R8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.R16I;
  			if ( glType === gl.INT ) internalFormat = gl.R32I;

  		}

  		if ( glFormat === gl.RED_INTEGER ) {

  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8UI;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16UI;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.R8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.R16I;
  			if ( glType === gl.INT ) internalFormat = gl.R32I;

  		}

  		if ( glFormat === gl.RG ) {

  			if ( glType === gl.FLOAT ) internalFormat = gl.RG32F;
  			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RG16F;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RG8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RG16I;
  			if ( glType === gl.INT ) internalFormat = gl.RG32I;

  		}

  		if ( glFormat === gl.RG_INTEGER ) {

  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8UI;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16UI;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RG8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RG16I;
  			if ( glType === gl.INT ) internalFormat = gl.RG32I;

  		}

  		if ( glFormat === gl.RGB ) {

  			if ( glType === gl.FLOAT ) internalFormat = gl.RGB32F;
  			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGB16F;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RGB8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RGB16I;
  			if ( glType === gl.INT ) internalFormat = gl.RGB32I;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8 : gl.RGB8;
  			if ( glType === gl.UNSIGNED_SHORT_5_6_5 ) internalFormat = gl.RGB565;
  			if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;
  			if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGB4;
  			if ( glType === gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = gl.RGB9_E5;

  		}

  		if ( glFormat === gl.RGB_INTEGER ) {

  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8UI;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16UI;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RGB8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RGB16I;
  			if ( glType === gl.INT ) internalFormat = gl.RGB32I;

  		}

  		if ( glFormat === gl.RGBA ) {

  			if ( glType === gl.FLOAT ) internalFormat = gl.RGBA32F;
  			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGBA16F;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;
  			if ( glType === gl.INT ) internalFormat = gl.RGBA32I;
  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8_ALPHA8 : gl.RGBA8;
  			if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGBA4;
  			if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;

  		}

  		if ( glFormat === gl.RGBA_INTEGER ) {

  			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8UI;
  			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16UI;
  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;
  			if ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;
  			if ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;
  			if ( glType === gl.INT ) internalFormat = gl.RGBA32I;

  		}

  		if ( glFormat === gl.DEPTH_COMPONENT ) {

  			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.DEPTH24_STENCIL8;
  			if ( glType === gl.FLOAT ) internalFormat = gl.DEPTH_COMPONENT32F;

  		}

  		if ( glFormat === gl.DEPTH_STENCIL ) {

  			if ( glType === gl.UNSIGNED_INT_24_8 ) internalFormat = gl.DEPTH24_STENCIL8;

  		}

  		if ( internalFormat === gl.R16F || internalFormat === gl.R32F ||
  			internalFormat === gl.RG16F || internalFormat === gl.RG32F ||
  			internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F ) {

  			extensions.get( 'EXT_color_buffer_float' );

  		}

  		return internalFormat;

  	}

  	setTextureParameters( textureType, texture ) {

  		const { gl, extensions, backend } = this;


  		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
  		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
  		gl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
  		gl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE );

  		gl.texParameteri( textureType, gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
  		gl.texParameteri( textureType, gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

  		if ( textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY ) {

  			gl.texParameteri( textureType, gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

  		}

  		gl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );


  		const hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;

  		// follow WebGPU backend mapping for texture filtering
  		const minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;

  		gl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterToGL[ minFilter ] );

  		if ( texture.compareFunction ) {

  			gl.texParameteri( textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE );
  			gl.texParameteri( textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

  		}

  		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

  			if ( texture.magFilter === NearestFilter ) return;
  			if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
  			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2

  			if ( texture.anisotropy > 1 ) {

  				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );
  				gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, backend.getMaxAnisotropy() ) );

  			}

  		}

  	}

  	createDefaultTexture( texture ) {

  		const { gl, backend, defaultTextures } = this;


  		const glTextureType = this.getGLTextureType( texture );

  		let textureGPU = defaultTextures[ glTextureType ];

  		if ( textureGPU === undefined ) {

  			textureGPU = gl.createTexture();

  			backend.state.bindTexture( glTextureType, textureGPU );
  			gl.texParameteri( glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
  			gl.texParameteri( glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

  			// gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

  			defaultTextures[ glTextureType ] = textureGPU;

  		}

  		backend.set( texture, {
  			textureGPU,
  			glTextureType,
  			isDefault: true
  		} );

  	}

  	createTexture( texture, options ) {

  		const { gl, backend } = this;
  		const { levels, width, height, depth } = options;

  		const glFormat = backend.utils.convert( texture.format, texture.colorSpace );
  		const glType = backend.utils.convert( texture.type );
  		const glInternalFormat = this.getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );

  		const textureGPU = gl.createTexture();
  		const glTextureType = this.getGLTextureType( texture );

  		backend.state.bindTexture( glTextureType, textureGPU );

  		this.setTextureParameters( glTextureType, texture );

  		if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

  			gl.texStorage3D( gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth );

  		} else if ( texture.isData3DTexture ) {

  			gl.texStorage3D( gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth );

  		} else if ( ! texture.isVideoTexture ) {

  			gl.texStorage2D( glTextureType, levels, glInternalFormat, width, height );

  		}

  		backend.set( texture, {
  			textureGPU,
  			glTextureType,
  			glFormat,
  			glType,
  			glInternalFormat
  		} );

  	}

  	copyBufferToTexture( buffer, texture ) {

  		const { gl, backend } = this;

  		const { textureGPU, glTextureType, glFormat, glType } = backend.get( texture );

  		const { width, height } = texture.source.data;

  		gl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, buffer );

  		backend.state.bindTexture( glTextureType, textureGPU );

  		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );
  		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );
  		gl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, 0 );

  		gl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, null );

  		backend.state.unbindTexture();
  		// debug
  		// const framebuffer = gl.createFramebuffer();
  		// gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
  		// gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );

  		// const readout = new Float32Array( width * height * 4 );

  		// const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );
  		// const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );

  		// gl.readPixels( 0, 0, width, height, altFormat, altType, readout );
  		// gl.bindFramebuffer( gl.FRAMEBUFFER, null );
  		// console.log( readout );

  	}

  	updateTexture( texture, options ) {

  		const { gl } = this;
  		const { width, height } = options;
  		const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get( texture );

  		if ( texture.isRenderTargetTexture || ( textureGPU === undefined /* unsupported texture format */ ) )
  			return;

  		const getImage = ( source ) => {

  			if ( source.isDataTexture ) {

  				return source.image.data;

  			} else if ( source instanceof ImageBitmap || source instanceof OffscreenCanvas || source instanceof HTMLImageElement || source instanceof HTMLCanvasElement ) {

  				return source;

  			}

  			return source.data;

  		};

  		this.backend.state.bindTexture( glTextureType, textureGPU );

  		this.setTextureParameters( glTextureType, texture );

  		if ( texture.isCompressedTexture ) {

  			const mipmaps = texture.mipmaps;
  			const image = options.image;

  			for ( let i = 0; i < mipmaps.length; i ++ ) {

  				const mipmap = mipmaps[ i ];

  				if ( texture.isCompressedArrayTexture ) {


  					if ( texture.format !== gl.RGBA ) {

  						if ( glFormat !== null ) {

  							gl.compressedTexSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0 );


  						} else {

  							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

  						}

  					} else {

  						gl.texSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

  					}

  				} else {

  					if ( glFormat !== null ) {

  						gl.compressedTexSubImage2D( gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

  					} else {

  						console.warn( 'Unsupported compressed texture format' );

  					}

  				}

  			}


  		} else if ( texture.isCubeTexture ) {

  			const images = options.images;

  			for ( let i = 0; i < 6; i ++ ) {

  				const image = getImage( images[ i ] );

  				gl.texSubImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image );

  			}

  		} else if ( texture.isDataArrayTexture ) {

  			const image = options.image;

  			gl.texSubImage3D( gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

  		} else if ( texture.isData3DTexture ) {

  			const image = options.image;

  			gl.texSubImage3D( gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

  		} else if ( texture.isVideoTexture ) {

  			texture.update();

  			gl.texImage2D( glTextureType, 0, glInternalFormat, glFormat, glType, options.image );


  		} else {

  			const image = getImage( options.image );

  			gl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, image );

  		}

  	}

  	generateMipmaps( texture ) {

  		const { gl, backend } = this;
  		const { textureGPU, glTextureType } = backend.get( texture );

  		backend.state.bindTexture( glTextureType, textureGPU );
  		gl.generateMipmap( glTextureType );

  	}

  	deallocateRenderBuffers( renderTarget ) {

  		const { gl, backend } = this;

  		// remove framebuffer reference
  		if ( renderTarget ) {

  			const renderContextData = backend.get( renderTarget );

  			renderContextData.renderBufferStorageSetup = undefined;

  			if ( renderContextData.framebuffers ) {

  				for ( const cacheKey in renderContextData.framebuffers ) {

  					gl.deleteFramebuffer( renderContextData.framebuffers[ cacheKey ] );

  				}

  				delete renderContextData.framebuffers;

  			}

  			if ( renderContextData.depthRenderbuffer ) {

  				gl.deleteRenderbuffer( renderContextData.depthRenderbuffer );
  				delete renderContextData.depthRenderbuffer;

  			}

  			if ( renderContextData.stencilRenderbuffer ) {

  				gl.deleteRenderbuffer( renderContextData.stencilRenderbuffer );
  				delete renderContextData.stencilRenderbuffer;

  			}

  			if ( renderContextData.msaaFrameBuffer ) {

  				gl.deleteFramebuffer( renderContextData.msaaFrameBuffer );
  				delete renderContextData.msaaFrameBuffer;

  			}

  			if ( renderContextData.msaaRenderbuffers ) {

  				for ( let i = 0; i < renderContextData.msaaRenderbuffers.length; i ++ ) {

  					gl.deleteRenderbuffer( renderContextData.msaaRenderbuffers[ i ] );

  				}

  				delete renderContextData.msaaRenderbuffers;

  			}

  		}

  	}

  	destroyTexture( texture ) {

  		const { gl, backend } = this;
  		const { textureGPU, renderTarget } = backend.get( texture );

  		this.deallocateRenderBuffers( renderTarget );
  		gl.deleteTexture( textureGPU );

  		backend.delete( texture );

  	}

  	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

  		const { gl, backend } = this;
  		const { state } = this.backend;

  		const { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get( dstTexture );


  		let width, height, minX, minY;
  		let dstX, dstY;
  		if ( srcRegion !== null ) {

  			width = srcRegion.max.x - srcRegion.min.x;
  			height = srcRegion.max.y - srcRegion.min.y;
  			minX = srcRegion.min.x;
  			minY = srcRegion.min.y;

  		} else {

  			width = srcTexture.image.width;
  			height = srcTexture.image.height;
  			minX = 0;
  			minY = 0;

  		}

  		if ( dstPosition !== null ) {

  			dstX = dstPosition.x;
  			dstY = dstPosition.y;

  		} else {

  			dstX = 0;
  			dstY = 0;

  		}

  		state.bindTexture( glTextureType, dstTextureGPU );

  		// As another texture upload may have changed pixelStorei
  		// parameters, make sure they are correct for the dstTexture
  		gl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );
  		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
  		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
  		gl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

  		const currentUnpackRowLen = gl.getParameter( gl.UNPACK_ROW_LENGTH );
  		const currentUnpackImageHeight = gl.getParameter( gl.UNPACK_IMAGE_HEIGHT );
  		const currentUnpackSkipPixels = gl.getParameter( gl.UNPACK_SKIP_PIXELS );
  		const currentUnpackSkipRows = gl.getParameter( gl.UNPACK_SKIP_ROWS );
  		const currentUnpackSkipImages = gl.getParameter( gl.UNPACK_SKIP_IMAGES );

  		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;

  		gl.pixelStorei( gl.UNPACK_ROW_LENGTH, image.width );
  		gl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, image.height );
  		gl.pixelStorei( gl.UNPACK_SKIP_PIXELS, minX );
  		gl.pixelStorei( gl.UNPACK_SKIP_ROWS, minY );


  		if ( srcTexture.isDataTexture ) {

  			gl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data );

  		} else {

  			if ( srcTexture.isCompressedTexture ) {

  				gl.compressedTexSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data );

  			} else {

  				gl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image );

  			}

  		}

  		gl.pixelStorei( gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
  		gl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );
  		gl.pixelStorei( gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
  		gl.pixelStorei( gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );
  		gl.pixelStorei( gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );

  		// Generate mipmaps only when copying level 0
  		if ( level === 0 && dstTexture.generateMipmaps ) gl.generateMipmap( gl.TEXTURE_2D );

  		state.unbindTexture();

  	}

  	copyFramebufferToTexture( texture, renderContext, rectangle ) {

  		const { gl } = this;
  		const { state } = this.backend;

  		const { textureGPU } = this.backend.get( texture );

  		const { x, y, z: width, w: height } = rectangle;

  		const requireDrawFrameBuffer = texture.isDepthTexture === true || ( renderContext.renderTarget && renderContext.renderTarget.samples > 0 );

  		const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.gerDrawingBufferSize().y;

  		if ( requireDrawFrameBuffer ) {

  			const partial = ( x !== 0 || y !== 0 );
  			let mask;
  			let attachment;

  			if ( texture.isDepthTexture === true ) {

  				mask = gl.DEPTH_BUFFER_BIT;
  				attachment = gl.DEPTH_ATTACHMENT;

  				if ( renderContext.stencil ) {

  					mask |= gl.STENCIL_BUFFER_BIT;

  				}

  			} else {

  				mask = gl.COLOR_BUFFER_BIT;
  				attachment = gl.COLOR_ATTACHMENT0;

  			}

  			if ( partial ) {

  				const renderTargetContextData = this.backend.get( renderContext.renderTarget );

  				const fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];
  				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;

  				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );
  				state.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );

  				const flippedY = srcHeight - y - height;

  				gl.blitFramebuffer( x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST );

  				state.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );

  				state.bindTexture( gl.TEXTURE_2D, textureGPU );

  				gl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height );

  				state.unbindTexture();

  			} else {

  				const fb = gl.createFramebuffer();

  				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );

  				gl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0 );
  				gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST );

  				gl.deleteFramebuffer( fb );

  			}

  		} else {

  			state.bindTexture( gl.TEXTURE_2D, textureGPU );
  			gl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height );

  			state.unbindTexture();

  		}

  		if ( texture.generateMipmaps ) this.generateMipmaps( texture );

  		this.backend._setFramebuffer( renderContext );

  	}

  	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  	setupRenderBufferStorage( renderbuffer, renderContext ) {

  		const { gl } = this;
  		const renderTarget = renderContext.renderTarget;

  		const { samples, depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;

  		gl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );

  		if ( depthBuffer && ! stencilBuffer ) {

  			let glInternalFormat = gl.DEPTH_COMPONENT24;

  			if ( samples > 0 ) {

  				if ( depthTexture && depthTexture.isDepthTexture ) {

  					if ( depthTexture.type === gl.FLOAT ) {

  						glInternalFormat = gl.DEPTH_COMPONENT32F;

  					}

  				}

  				gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, glInternalFormat, width, height );

  			} else {

  				gl.renderbufferStorage( gl.RENDERBUFFER, glInternalFormat, width, height );

  			}

  			gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

  		} else if ( depthBuffer && stencilBuffer ) {

  			if ( samples > 0 ) {

  				gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height );

  			} else {

  				gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height );

  			}


  			gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

  		}

  	}

  	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

  		const { backend, gl } = this;

  		const { textureGPU, glFormat, glType } = this.backend.get( texture );

  		const fb = gl.createFramebuffer();

  		gl.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );

  		const target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;

  		gl.framebufferTexture2D( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0 );

  		const typedArrayType = this._getTypedArrayType( glType );
  		const bytesPerTexel = this._getBytesPerTexel( glType, glFormat );

  		const elementCount = width * height;
  		const byteLength = elementCount * bytesPerTexel;

  		const buffer = gl.createBuffer();

  		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );
  		gl.bufferData( gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ );
  		gl.readPixels( x, y, width, height, glFormat, glType, 0 );
  		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );

  		await backend.utils._clientWaitAsync();

  		const dstBuffer = new typedArrayType( byteLength / typedArrayType.BYTES_PER_ELEMENT );

  		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );
  		gl.getBufferSubData( gl.PIXEL_PACK_BUFFER, 0, dstBuffer );
  		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );

  		gl.deleteFramebuffer( fb );

  		return dstBuffer;

  	}

  	_getTypedArrayType( glType ) {

  		const { gl } = this;

  		if ( glType === gl.UNSIGNED_BYTE ) return Uint8Array;

  		if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) return Uint16Array;
  		if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) return Uint16Array;
  		if ( glType === gl.UNSIGNED_SHORT_5_6_5 ) return Uint16Array;
  		if ( glType === gl.UNSIGNED_SHORT ) return Uint16Array;
  		if ( glType === gl.UNSIGNED_INT ) return Uint32Array;

  		if ( glType === gl.HALF_FLOAT ) return Uint16Array;
  		if ( glType === gl.FLOAT ) return Float32Array;

  		throw new Error( `Unsupported WebGL type: ${glType}` );

  	}

  	_getBytesPerTexel( glType, glFormat ) {

  		const { gl } = this;

  		let bytesPerComponent = 0;

  		if ( glType === gl.UNSIGNED_BYTE ) bytesPerComponent = 1;

  		if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ||
  			glType === gl.UNSIGNED_SHORT_5_5_5_1 ||
  			glType === gl.UNSIGNED_SHORT_5_6_5 ||
  			glType === gl.UNSIGNED_SHORT ||
  			glType === gl.HALF_FLOAT ) bytesPerComponent = 2;

  		if ( glType === gl.UNSIGNED_INT ||
  			glType === gl.FLOAT ) bytesPerComponent = 4;

  		if ( glFormat === gl.RGBA ) return bytesPerComponent * 4;
  		if ( glFormat === gl.RGB ) return bytesPerComponent * 3;
  		if ( glFormat === gl.ALPHA ) return bytesPerComponent;

  	}

  }

  class WebGLExtensions {

  	constructor( backend ) {

  		this.backend = backend;

  		this.gl = this.backend.gl;
  		this.availableExtensions = this.gl.getSupportedExtensions();

  		this.extensions = {};

  	}

  	get( name ) {

  		let extension = this.extensions[ name ];

  		if ( extension === undefined ) {

  			extension = this.gl.getExtension( name );

  			this.extensions[ name ] = extension;

  		}

  		return extension;

  	}

  	has( name ) {

  		return this.availableExtensions.includes( name );

  	}

  }

  class WebGLCapabilities {

  	constructor( backend ) {

  		this.backend = backend;

  		this.maxAnisotropy = null;

  	}

  	getMaxAnisotropy() {

  		if ( this.maxAnisotropy !== null ) return this.maxAnisotropy;

  		const gl = this.backend.gl;
  		const extensions = this.backend.extensions;

  		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

  			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  			this.maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

  		} else {

  			this.maxAnisotropy = 0;

  		}

  		return this.maxAnisotropy;

  	}

  }

  const GLFeatureName = {

  	'WEBGL_multi_draw': 'WEBGL_multi_draw',
  	'WEBGL_compressed_texture_astc': 'texture-compression-astc',
  	'WEBGL_compressed_texture_etc': 'texture-compression-etc2',
  	'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',
  	'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
  	'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
  	'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',
  	'EXT_texture_compression_bptc': 'texture-compression-bptc',
  	'EXT_disjoint_timer_query_webgl2': 'timestamp-query',

  };

  class WebGLBufferRenderer {

  	constructor( backend ) {

  		this.gl = backend.gl;
  		this.extensions = backend.extensions;
  		this.info = backend.renderer.info;
  		this.mode = null;
  		this.index = 0;
  		this.type = null;
  		this.object = null;

  	}

  	render( start, count ) {

  		const { gl, mode, object, type, info, index } = this;

  		if ( index !== 0 ) {

  			gl.drawElements( mode, count, type, start );

  		} else {

  			gl.drawArrays( mode, start, count );

  		}

  		info.update( object, count, mode, 1 );

  	}

  	renderInstances( start, count, primcount ) {

  		const { gl, mode, type, index, object, info } = this;

  		if ( primcount === 0 ) return;

  		if ( index !== 0 ) {

  			gl.drawElementsInstanced( mode, count, type, start, primcount );

  		} else {

  			gl.drawArraysInstanced( mode, start, count, primcount );

  		}

  		info.update( object, count, mode, primcount );

  	}

  	renderMultiDraw( starts, counts, drawCount ) {

  		const { extensions, mode, object, info } = this;

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );

  		if ( extension === null ) {

  			for ( let i = 0; i < drawCount; i ++ ) {

  				this.render( starts[ i ], counts[ i ] );

  			}

  		} else {

  			if ( this.index !== 0 ) {

  				extension.multiDrawElementsWEBGL( mode, counts, 0, this.type, starts, 0, drawCount );

  			} else {

  				extension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );

  			}

  			let elementCount = 0;
  			for ( let i = 0; i < drawCount; i ++ ) {

  				elementCount += counts[ i ];

  			}

  			info.update( object, elementCount, mode, 1 );

  		}

  	}

  	renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

  		const { extensions, mode, object, info } = this;

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );

  		if ( extension === null ) {

  			for ( let i = 0; i < drawCount; i ++ ) {

  				this.renderInstances( starts[ i ], counts[ i ], primcount[ i ] );

  			}

  		} else {

  			if ( this.index !== 0 ) {

  				extension.multiDrawElementsInstancedWEBGL( mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount );

  			} else {

  				extension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );

  			}

  			let elementCount = 0;

  			for ( let i = 0; i < drawCount; i ++ ) {

  				elementCount += counts[ i ];

  			}

  			for ( let i = 0; i < primcount.length; i ++ ) {

  				info.update( object, elementCount, mode, primcount[ i ] );

  			}

  		}

  	}

  	//

  }

  //

  class WebGLBackend extends Backend {

  	constructor( parameters = {} ) {

  		super( parameters );

  		this.isWebGLBackend = true;

  	}

  	init( renderer ) {

  		super.init( renderer );

  		//

  		const parameters = this.parameters;

  		const glContext = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgl2' );

  		this.gl = glContext;

  		this.extensions = new WebGLExtensions( this );
  		this.capabilities = new WebGLCapabilities( this );
  		this.attributeUtils = new WebGLAttributeUtils( this );
  		this.textureUtils = new WebGLTextureUtils( this );
  		this.bufferRenderer = new WebGLBufferRenderer( this );

  		this.state = new WebGLState( this );
  		this.utils = new WebGLUtils( this );

  		this.vaoCache = {};
  		this.transformFeedbackCache = {};
  		this.discard = false;
  		this.trackTimestamp = ( parameters.trackTimestamp === true );

  		this.extensions.get( 'EXT_color_buffer_float' );
  		this.extensions.get( 'WEBGL_clip_cull_distance' );
  		this.extensions.get( 'OES_texture_float_linear' );
  		this.extensions.get( 'EXT_color_buffer_half_float' );
  		this.extensions.get( 'WEBGL_multisampled_render_to_texture' );
  		this.extensions.get( 'WEBGL_render_shared_exponent' );
  		this.extensions.get( 'WEBGL_multi_draw' );

  		this.disjoint = this.extensions.get( 'EXT_disjoint_timer_query_webgl2' );
  		this.parallel = this.extensions.get( 'KHR_parallel_shader_compile' );

  		this._currentContext = null;

  	}

  	get coordinateSystem() {

  		return WebGLCoordinateSystem;

  	}

  	async getArrayBufferAsync( attribute ) {

  		return await this.attributeUtils.getArrayBufferAsync( attribute );

  	}


  	initTimestampQuery( renderContext ) {

  		if ( ! this.disjoint || ! this.trackTimestamp ) return;

  		const renderContextData = this.get( renderContext );

  		if ( this.queryRunning ) {

  		  if ( ! renderContextData.queryQueue ) renderContextData.queryQueue = [];
  		  renderContextData.queryQueue.push( renderContext );
  		  return;

  		}

  		if ( renderContextData.activeQuery ) {

  		  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );
  		  renderContextData.activeQuery = null;

  		}

  		renderContextData.activeQuery = this.gl.createQuery();

  		if ( renderContextData.activeQuery !== null ) {

  		  this.gl.beginQuery( this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery );
  		  this.queryRunning = true;

  		}

  	}

  	// timestamp utils

  	prepareTimestampBuffer( renderContext ) {

  		if ( ! this.disjoint || ! this.trackTimestamp ) return;

  		const renderContextData = this.get( renderContext );

  		if ( renderContextData.activeQuery ) {

  		  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );

  		  if ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];
  		  renderContextData.gpuQueries.push( { query: renderContextData.activeQuery } );
  		  renderContextData.activeQuery = null;
  		  this.queryRunning = false;

  		  if ( renderContextData.queryQueue && renderContextData.queryQueue.length > 0 ) {

  				const nextRenderContext = renderContextData.queryQueue.shift();
  				this.initTimestampQuery( nextRenderContext );

  			}

  		}

  	}

  	  async resolveTimestampAsync( renderContext, type = 'render' ) {

  		if ( ! this.disjoint || ! this.trackTimestamp ) return;

  		const renderContextData = this.get( renderContext );

  		if ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];

  		for ( let i = 0; i < renderContextData.gpuQueries.length; i ++ ) {

  		  const queryInfo = renderContextData.gpuQueries[ i ];
  		  const available = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE );
  		  const disjoint = this.gl.getParameter( this.disjoint.GPU_DISJOINT_EXT );

  		  if ( available && ! disjoint ) {

  				const elapsed = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT );
  				const duration = Number( elapsed ) / 1000000; // Convert nanoseconds to milliseconds
  				this.gl.deleteQuery( queryInfo.query );
  				renderContextData.gpuQueries.splice( i, 1 ); // Remove the processed query
  				i --;
  				this.renderer.info.updateTimestamp( type, duration );

  			}

  		}

  	}

  	getContext() {

  		return this.gl;

  	}

  	beginRender( renderContext ) {

  		const { gl } = this;
  		const renderContextData = this.get( renderContext );

  		//

  		//

  		this.initTimestampQuery( renderContext );

  		renderContextData.previousContext = this._currentContext;
  		this._currentContext = renderContext;

  		this._setFramebuffer( renderContext );

  		this.clear( renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false );

  		//
  		if ( renderContext.viewport ) {

  			this.updateViewport( renderContext );

  		} else {

  			gl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );

  		}

  		if ( renderContext.scissor ) {

  			const { x, y, width, height } = renderContext.scissorValue;

  			gl.scissor( x, renderContext.height - height - y, width, height );

  		}

  		const occlusionQueryCount = renderContext.occlusionQueryCount;

  		if ( occlusionQueryCount > 0 ) {

  			// Get a reference to the array of objects with queries. The renderContextData property
  			// can be changed by another render pass before the async reading of all previous queries complete
  			renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
  			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;

  			renderContextData.lastOcclusionObject = null;
  			renderContextData.occlusionQueries = new Array( occlusionQueryCount );
  			renderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );
  			renderContextData.occlusionQueryIndex = 0;

  		}

  	}

  	finishRender( renderContext ) {

  		const { gl, state } = this;
  		const renderContextData = this.get( renderContext );
  		const previousContext = renderContextData.previousContext;

  		const occlusionQueryCount = renderContext.occlusionQueryCount;

  		if ( occlusionQueryCount > 0 ) {

  			if ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {

  				gl.endQuery( gl.ANY_SAMPLES_PASSED );

  			}

  			this.resolveOccludedAsync( renderContext );

  		}

  		const textures = renderContext.textures;

  		if ( textures !== null ) {

  			for ( let i = 0; i < textures.length; i ++ ) {

  				const texture = textures[ i ];

  				if ( texture.generateMipmaps ) {

  					this.generateMipmaps( texture );

  				}

  			}

  		}

  		this._currentContext = previousContext;

  		if ( renderContext.textures !== null && renderContext.renderTarget ) {

  			const renderTargetContextData = this.get( renderContext.renderTarget );

  			const { samples } = renderContext.renderTarget;

  			if ( samples > 0 ) {

  				const fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];

  				const mask = gl.COLOR_BUFFER_BIT;

  				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;

  				const textures = renderContext.textures;

  				state.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );
  				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );

  				for ( let i = 0; i < textures.length; i ++ ) {

  					// TODO Add support for MRT

  					if ( renderContext.scissor ) {

  						const { x, y, width, height } = renderContext.scissorValue;

  						const viewY = renderContext.height - height - y;

  						gl.blitFramebuffer( x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST );
  						gl.invalidateSubFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height );

  					} else {

  						gl.blitFramebuffer( 0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST );
  						gl.invalidateFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray );

  					}

  				}

  			}


  		}

  		if ( previousContext !== null ) {

  			this._setFramebuffer( previousContext );

  			if ( previousContext.viewport ) {

  				this.updateViewport( previousContext );

  			} else {

  				gl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );

  			}

  		}

  		this.prepareTimestampBuffer( renderContext );

  	}

  	resolveOccludedAsync( renderContext ) {

  		const renderContextData = this.get( renderContext );

  		// handle occlusion query results

  		const { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;

  		if ( currentOcclusionQueries && currentOcclusionQueryObjects ) {

  			const occluded = new WeakSet();
  			const { gl } = this;

  			renderContextData.currentOcclusionQueryObjects = null;
  			renderContextData.currentOcclusionQueries = null;

  			const check = () => {

  				let completed = 0;

  				// check all queries and requeue as appropriate
  				for ( let i = 0; i < currentOcclusionQueries.length; i ++ ) {

  					const query = currentOcclusionQueries[ i ];

  					if ( query === null ) continue;

  					if ( gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE ) ) {

  						if ( gl.getQueryParameter( query, gl.QUERY_RESULT ) > 0 ) occluded.add( currentOcclusionQueryObjects[ i ] );

  						currentOcclusionQueries[ i ] = null;
  						gl.deleteQuery( query );

  						completed ++;

  					}

  				}

  				if ( completed < currentOcclusionQueries.length ) {

  					requestAnimationFrame( check );

  				} else {

  					renderContextData.occluded = occluded;

  				}

  			};

  			check();

  		}

  	}

  	isOccluded( renderContext, object ) {

  		const renderContextData = this.get( renderContext );

  		return renderContextData.occluded && renderContextData.occluded.has( object );

  	}

  	updateViewport( renderContext ) {

  		const gl = this.gl;
  		const { x, y, width, height } = renderContext.viewportValue;

  		gl.viewport( x, renderContext.height - height - y, width, height );

  	}

  	setScissorTest( boolean ) {

  		const gl = this.gl;

  		if ( boolean ) {

  			gl.enable( gl.SCISSOR_TEST );

  		} else {

  			gl.disable( gl.SCISSOR_TEST );

  		}

  	}

  	clear( color, depth, stencil, descriptor = null, setFrameBuffer = true ) {

  		const { gl } = this;

  		if ( descriptor === null ) {

  			descriptor = {
  				textures: null,
  				clearColorValue: this.getClearColor()
  			};

  		}

  		//

  		let clear = 0;

  		if ( color ) clear |= gl.COLOR_BUFFER_BIT;
  		if ( depth ) clear |= gl.DEPTH_BUFFER_BIT;
  		if ( stencil ) clear |= gl.STENCIL_BUFFER_BIT;

  		if ( clear !== 0 ) {

  			const clearColor = descriptor.clearColorValue || this.getClearColor();

  			// premultiply alpha

  			clearColor.r *= clearColor.a;
  			clearColor.g *= clearColor.a;
  			clearColor.b *= clearColor.a;

  			if ( depth ) this.state.setDepthMask( true );

  			if ( descriptor.textures === null ) {

  				gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearColor.a );
  				gl.clear( clear );

  			} else {

  				if ( setFrameBuffer ) this._setFramebuffer( descriptor );

  				if ( color ) {

  					for ( let i = 0; i < descriptor.textures.length; i ++ ) {

  						gl.clearBufferfv( gl.COLOR, i, [ clearColor.r, clearColor.g, clearColor.b, clearColor.a ] );

  					}

  				}

  				if ( depth && stencil ) {

  					gl.clearBufferfi( gl.DEPTH_STENCIL, 0, 1, 0 );

  				} else if ( depth ) {

  					gl.clearBufferfv( gl.DEPTH, 0, [ 1.0 ] );

  				} else if ( stencil ) {

  					gl.clearBufferiv( gl.STENCIL, 0, [ 0 ] );

  				}

  			}

  		}

  	}

  	beginCompute( computeGroup ) {

  		const { state, gl } = this;

  		state.bindFramebuffer( gl.FRAMEBUFFER, null );
  		this.initTimestampQuery( computeGroup );

  	}

  	compute( computeGroup, computeNode, bindings, pipeline ) {

  		const { state, gl } = this;

  		if ( ! this.discard ) {

  			// required here to handle async behaviour of render.compute()
  			gl.enable( gl.RASTERIZER_DISCARD );
  			this.discard = true;

  		}

  		const { programGPU, transformBuffers, attributes } = this.get( pipeline );

  		const vaoKey = this._getVaoKey( null, attributes );

  		const vaoGPU = this.vaoCache[ vaoKey ];

  		if ( vaoGPU === undefined ) {

  			this._createVao( null, attributes );

  		} else {

  			gl.bindVertexArray( vaoGPU );

  		}

  		state.useProgram( programGPU );

  		this._bindUniforms( bindings );

  		const transformFeedbackGPU = this._getTransformFeedback( transformBuffers );

  		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );
  		gl.beginTransformFeedback( gl.POINTS );

  		if ( attributes[ 0 ].isStorageInstancedBufferAttribute ) {

  			gl.drawArraysInstanced( gl.POINTS, 0, 1, computeNode.count );

  		} else {

  			gl.drawArrays( gl.POINTS, 0, computeNode.count );

  		}

  		gl.endTransformFeedback();
  		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );

  		// switch active buffers

  		for ( let i = 0; i < transformBuffers.length; i ++ ) {

  			const dualAttributeData = transformBuffers[ i ];

  			if ( dualAttributeData.pbo ) {

  				this.textureUtils.copyBufferToTexture( dualAttributeData.transformBuffer, dualAttributeData.pbo );

  			}

  			dualAttributeData.switchBuffers();


  		}

  	}

  	finishCompute( computeGroup ) {

  		const gl = this.gl;

  		this.discard = false;

  		gl.disable( gl.RASTERIZER_DISCARD );

  		this.prepareTimestampBuffer( computeGroup );

  	}

  	draw( renderObject/*, info*/ ) {

  		const { object, pipeline, material, context } = renderObject;
  		const { programGPU } = this.get( pipeline );

  		const { gl, state } = this;

  		const contextData = this.get( context );

  		const drawParms = renderObject.getDrawParameters();

  		if ( drawParms === null ) return;

  		//

  		this._bindUniforms( renderObject.getBindings() );

  		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

  		state.setMaterial( material, frontFaceCW );

  		state.useProgram( programGPU );

  		//

  		let vaoGPU = renderObject.staticVao;

  		if ( vaoGPU === undefined ) {

  			const vaoKey = this._getVaoKey( renderObject.getIndex(), renderObject.getAttributes() );

  			vaoGPU = this.vaoCache[ vaoKey ];

  			if ( vaoGPU === undefined ) {

  				let staticVao;

  				( { vaoGPU, staticVao } = this._createVao( renderObject.getIndex(), renderObject.getAttributes() ) );

  				if ( staticVao ) renderObject.staticVao = vaoGPU;

  			}

  		}

  		gl.bindVertexArray( vaoGPU );

  		//

  		const index = renderObject.getIndex();

  		//

  		const lastObject = contextData.lastOcclusionObject;

  		if ( lastObject !== object && lastObject !== undefined ) {

  			if ( lastObject !== null && lastObject.occlusionTest === true ) {

  				gl.endQuery( gl.ANY_SAMPLES_PASSED );

  				contextData.occlusionQueryIndex ++;

  			}

  			if ( object.occlusionTest === true ) {

  				const query = gl.createQuery();

  				gl.beginQuery( gl.ANY_SAMPLES_PASSED, query );

  				contextData.occlusionQueries[ contextData.occlusionQueryIndex ] = query;
  				contextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;

  			}

  			contextData.lastOcclusionObject = object;

  		}

  		//
  		const renderer = this.bufferRenderer;

  		if ( object.isPoints ) renderer.mode = gl.POINTS;
  		else if ( object.isLineSegments ) renderer.mode = gl.LINES;
  		else if ( object.isLine ) renderer.mode = gl.LINE_STRIP;
  		else if ( object.isLineLoop ) renderer.mode = gl.LINE_LOOP;
  		else {

  			if ( material.wireframe === true ) {

  				state.setLineWidth( material.wireframeLinewidth * this.renderer.getPixelRatio() );
  				renderer.mode = gl.LINES;

  			} else {

  				renderer.mode = gl.TRIANGLES;

  			}

  		}

  		//

  		const { vertexCount, instanceCount } = drawParms;
  		let { firstVertex } = drawParms;

  		renderer.object = object;

  		if ( index !== null ) {

  			firstVertex *= index.array.BYTES_PER_ELEMENT;

  			const indexData = this.get( index );

  			renderer.index = index.count;
  			renderer.type = indexData.type;

  		} else {

  			renderer.index = 0;

  		}

  		if ( object.isBatchedMesh ) {

  			if ( object._multiDrawInstances !== null ) {

  				renderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );

  			} else if ( ! this.hasFeature( 'WEBGL_multi_draw' ) ) {

  				warnOnce( 'THREE.WebGLRenderer: WEBGL_multi_draw not supported.' );

  			} else {

  				renderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );

  			}

  		} else if ( instanceCount > 1 ) {

  			renderer.renderInstances( firstVertex, vertexCount, instanceCount );

  		} else {

  			renderer.render( firstVertex, vertexCount );

  		}
  		//

  		gl.bindVertexArray( null );

  	}

  	needsRenderUpdate( /*renderObject*/ ) {

  		return false;

  	}

  	getRenderCacheKey( /*renderObject*/ ) {

  		return '';

  	}

  	// textures

  	createDefaultTexture( texture ) {

  		this.textureUtils.createDefaultTexture( texture );

  	}

  	createTexture( texture, options ) {

  		this.textureUtils.createTexture( texture, options );

  	}

  	updateTexture( texture, options ) {

  		this.textureUtils.updateTexture( texture, options );

  	}

  	generateMipmaps( texture ) {

  		this.textureUtils.generateMipmaps( texture );

  	}


  	destroyTexture( texture ) {

  		this.textureUtils.destroyTexture( texture );

  	}

  	copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

  		return this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );

  	}

  	createSampler( /*texture*/ ) {

  		//console.warn( 'Abstract class.' );

  	}

  	destroySampler() {}

  	// node builder

  	createNodeBuilder( object, renderer ) {

  		return new GLSLNodeBuilder( object, renderer );

  	}

  	// program

  	createProgram( program ) {

  		const gl = this.gl;
  		const { stage, code } = program;

  		const shader = stage === 'fragment' ? gl.createShader( gl.FRAGMENT_SHADER ) : gl.createShader( gl.VERTEX_SHADER );

  		gl.shaderSource( shader, code );
  		gl.compileShader( shader );

  		this.set( program, {
  			shaderGPU: shader
  		} );

  	}

  	destroyProgram( /*program*/ ) {

  		console.warn( 'Abstract class.' );

  	}

  	createRenderPipeline( renderObject, promises ) {

  		const gl = this.gl;
  		const pipeline = renderObject.pipeline;

  		// Program

  		const { fragmentProgram, vertexProgram } = pipeline;

  		const programGPU = gl.createProgram();

  		const fragmentShader = this.get( fragmentProgram ).shaderGPU;
  		const vertexShader = this.get( vertexProgram ).shaderGPU;

  		gl.attachShader( programGPU, fragmentShader );
  		gl.attachShader( programGPU, vertexShader );
  		gl.linkProgram( programGPU );

  		this.set( pipeline, {
  			programGPU,
  			fragmentShader,
  			vertexShader
  		} );

  		if ( promises !== null && this.parallel ) {

  			const p = new Promise( ( resolve /*, reject*/ ) => {

  				const parallel = this.parallel;
  				const checkStatus = () => {

  					if ( gl.getProgramParameter( programGPU, parallel.COMPLETION_STATUS_KHR ) ) {

  						this._completeCompile( renderObject, pipeline );
  						resolve();

  					} else {

  						requestAnimationFrame( checkStatus );

  					}

  				};

  				checkStatus();

  			} );

  			promises.push( p );

  			return;

  		}

  		this._completeCompile( renderObject, pipeline );

  	}

  	_handleSource( string, errorLine ) {

  		const lines = string.split( '\n' );
  		const lines2 = [];

  		const from = Math.max( errorLine - 6, 0 );
  		const to = Math.min( errorLine + 6, lines.length );

  		for ( let i = from; i < to; i ++ ) {

  			const line = i + 1;
  			lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

  		}

  		return lines2.join( '\n' );

  	}

  	_getShaderErrors( gl, shader, type ) {

  		const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
  		const errors = gl.getShaderInfoLog( shader ).trim();

  		if ( status && errors === '' ) return '';

  		const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
  		if ( errorMatches ) {

  			const errorLine = parseInt( errorMatches[ 1 ] );
  			return type.toUpperCase() + '\n\n' + errors + '\n\n' + this._handleSource( gl.getShaderSource( shader ), errorLine );

  		} else {

  			return errors;

  		}

  	}

  	_logProgramError( programGPU, glFragmentShader, glVertexShader ) {

  		if ( this.renderer.debug.checkShaderErrors ) {

  			const gl = this.gl;

  			const programLog = gl.getProgramInfoLog( programGPU ).trim();

  			if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {


  				if ( typeof this.renderer.debug.onShaderError === 'function' ) {

  					this.renderer.debug.onShaderError( gl, programGPU, glVertexShader, glFragmentShader );

  				} else {

  					// default error reporting

  					const vertexErrors = this._getShaderErrors( gl, glVertexShader, 'vertex' );
  					const fragmentErrors = this._getShaderErrors( gl, glFragmentShader, 'fragment' );

  					console.error(
  						'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
  						'VALIDATE_STATUS ' + gl.getProgramParameter( programGPU, gl.VALIDATE_STATUS ) + '\n\n' +
  						'Program Info Log: ' + programLog + '\n' +
  						vertexErrors + '\n' +
  						fragmentErrors
  					);

  				}

  			} else if ( programLog !== '' ) {

  				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

  			}

  		}

  	}

  	_completeCompile( renderObject, pipeline ) {

  		const { state, gl } = this;
  		const pipelineData = this.get( pipeline );
  		const { programGPU, fragmentShader, vertexShader } = pipelineData;

  		if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {

  			this._logProgramError( programGPU, fragmentShader, vertexShader );

  		}

  		state.useProgram( programGPU );

  		// Bindings

  		const bindings = renderObject.getBindings();

  		this._setupBindings( bindings, programGPU );

  		//

  		this.set( pipeline, {
  			programGPU
  		} );

  	}

  	createComputePipeline( computePipeline, bindings ) {

  		const { state, gl } = this;

  		// Program

  		const fragmentProgram = {
  			stage: 'fragment',
  			code: '#version 300 es\nprecision highp float;\nvoid main() {}'
  		};

  		this.createProgram( fragmentProgram );

  		const { computeProgram } = computePipeline;

  		const programGPU = gl.createProgram();

  		const fragmentShader = this.get( fragmentProgram ).shaderGPU;
  		const vertexShader = this.get( computeProgram ).shaderGPU;

  		const transforms = computeProgram.transforms;

  		const transformVaryingNames = [];
  		const transformAttributeNodes = [];

  		for ( let i = 0; i < transforms.length; i ++ ) {

  			const transform = transforms[ i ];

  			transformVaryingNames.push( transform.varyingName );
  			transformAttributeNodes.push( transform.attributeNode );

  		}

  		gl.attachShader( programGPU, fragmentShader );
  		gl.attachShader( programGPU, vertexShader );

  		gl.transformFeedbackVaryings(
  			programGPU,
  			transformVaryingNames,
  			gl.SEPARATE_ATTRIBS
  		);

  		gl.linkProgram( programGPU );

  		if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {

  			this._logProgramError( programGPU, fragmentShader, vertexShader );


  		}

  		state.useProgram( programGPU );

  		// Bindings

  		this.createBindings( null, bindings );

  		this._setupBindings( bindings, programGPU );

  		const attributeNodes = computeProgram.attributes;
  		const attributes = [];
  		const transformBuffers = [];

  		for ( let i = 0; i < attributeNodes.length; i ++ ) {

  			const attribute = attributeNodes[ i ].node.attribute;

  			attributes.push( attribute );

  			if ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

  		}

  		for ( let i = 0; i < transformAttributeNodes.length; i ++ ) {

  			const attribute = transformAttributeNodes[ i ].attribute;

  			if ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

  			const attributeData = this.get( attribute );

  			transformBuffers.push( attributeData );

  		}

  		//

  		this.set( computePipeline, {
  			programGPU,
  			transformBuffers,
  			attributes
  		} );

  	}

  	createBindings( bindGroup, bindings ) {

  		this.updateBindings( bindGroup, bindings );

  	}

  	updateBindings( bindGroup, bindings ) {

  		if ( ! bindGroup ) return;

  		const { gl } = this;

  		const bindingsData = this.get( bindings );
  		const bindGroupData = this.get( bindGroup );

  		if ( bindingsData.textureIndex === undefined ) bindingsData.textureIndex = 0;

  		if ( bindGroupData.textureIndex === undefined ) {

  			bindGroupData.textureIndex = bindingsData.textureIndex;

  		} else {

  			// reset textureIndex to match previous mappimgs when rebuilt
  			bindingsData.textureIndex = bindGroupData.textureIndex;

  		}

  		let i = 0;

  		for ( const binding of bindGroup.bindings ) {

  			if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

  				const data = binding.buffer;
  				const bufferGPU = gl.createBuffer();

  				gl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );
  				gl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );

  				this.set( binding, {
  					index: bindGroup.index * 2 + i ++,
  					bufferGPU
  				} );

  			} else if ( binding.isSampledTexture ) {

  				const { textureGPU, glTextureType } = this.get( binding.texture );

  				this.set( binding, {
  					index: bindingsData.textureIndex ++,
  					textureGPU,
  					glTextureType
  				} );

  			}

  		}

  	}

  	updateBinding( binding ) {

  		const gl = this.gl;

  		if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

  			const bindingData = this.get( binding );
  			const bufferGPU = bindingData.bufferGPU;
  			const data = binding.buffer;

  			gl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );
  			gl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );

  		}

  	}

  	// attributes

  	createIndexAttribute( attribute ) {

  		const gl = this.gl;

  		this.attributeUtils.createAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

  	}

  	createAttribute( attribute ) {

  		if ( this.has( attribute ) ) return;

  		const gl = this.gl;

  		this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

  	}

  	createStorageAttribute( attribute ) {

  		if ( this.has( attribute ) ) return;

  		const gl = this.gl;

  		this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

  	}

  	updateAttribute( attribute ) {

  		this.attributeUtils.updateAttribute( attribute );

  	}

  	destroyAttribute( attribute ) {

  		this.attributeUtils.destroyAttribute( attribute );

  	}

  	updateSize() {

  		//console.warn( 'Abstract class.' );

  	}

  	hasFeature( name ) {

  		const keysMatching = Object.keys( GLFeatureName ).filter( key => GLFeatureName[ key ] === name );

  		const extensions = this.extensions;

  		for ( let i = 0; i < keysMatching.length; i ++ ) {

  			if ( extensions.has( keysMatching[ i ] ) ) return true;

  		}

  		return false;

  	}

  	getMaxAnisotropy() {

  		return this.capabilities.getMaxAnisotropy();

  	}

  	copyTextureToTexture( position, srcTexture, dstTexture, level ) {

  		this.textureUtils.copyTextureToTexture( position, srcTexture, dstTexture, level );

  	}

  	copyFramebufferToTexture( texture, renderContext, rectangle ) {

  		this.textureUtils.copyFramebufferToTexture( texture, renderContext, rectangle );

  	}

  	_setFramebuffer( descriptor ) {

  		const { gl, state } = this;

  		let currentFrameBuffer = null;

  		if ( descriptor.textures !== null ) {

  			const renderTarget = descriptor.renderTarget;
  			const renderTargetContextData = this.get( renderTarget );
  			const { samples, depthBuffer, stencilBuffer } = renderTarget;

  			const isCube = renderTarget.isWebGLCubeRenderTarget === true;

  			let msaaFb = renderTargetContextData.msaaFrameBuffer;
  			let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;

  			const cacheKey = getCacheKey( descriptor );

  			let fb;

  			if ( isCube ) {

  				renderTargetContextData.cubeFramebuffers || ( renderTargetContextData.cubeFramebuffers = {} );

  				fb = renderTargetContextData.cubeFramebuffers[ cacheKey ];

  			} else {

  				renderTargetContextData.framebuffers || ( renderTargetContextData.framebuffers = {} );

  				fb = renderTargetContextData.framebuffers[ cacheKey ];

  			}

  			if ( fb === undefined ) {

  				fb = gl.createFramebuffer();

  				state.bindFramebuffer( gl.FRAMEBUFFER, fb );

  				const textures = descriptor.textures;

  				if ( isCube ) {

  					renderTargetContextData.cubeFramebuffers[ cacheKey ] = fb;

  					const { textureGPU } = this.get( textures[ 0 ] );

  					const cubeFace = this.renderer._activeCubeFace;

  					gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0 );

  				} else {

  					renderTargetContextData.framebuffers[ cacheKey ] = fb;

  					for ( let i = 0; i < textures.length; i ++ ) {

  						const texture = textures[ i ];
  						const textureData = this.get( texture );
  						textureData.renderTarget = descriptor.renderTarget;

  						const attachment = gl.COLOR_ATTACHMENT0 + i;

  						gl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0 );

  					}

  					state.drawBuffers( descriptor, fb );

  				}

  				if ( descriptor.depthTexture !== null ) {

  					const textureData = this.get( descriptor.depthTexture );
  					const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

  					gl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );

  				}

  			}

  			if ( samples > 0 ) {

  				if ( msaaFb === undefined ) {

  					const invalidationArray = [];

  					msaaFb = gl.createFramebuffer();

  					state.bindFramebuffer( gl.FRAMEBUFFER, msaaFb );

  					const msaaRenderbuffers = [];

  					const textures = descriptor.textures;

  					for ( let i = 0; i < textures.length; i ++ ) {

  						msaaRenderbuffers[ i ] = gl.createRenderbuffer();

  						gl.bindRenderbuffer( gl.RENDERBUFFER, msaaRenderbuffers[ i ] );

  						invalidationArray.push( gl.COLOR_ATTACHMENT0 + i );

  						if ( depthBuffer ) {

  							const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
  							invalidationArray.push( depthStyle );

  						}

  						const texture = descriptor.textures[ i ];
  						const textureData = this.get( texture );

  						gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height );
  						gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );


  					}

  					renderTargetContextData.msaaFrameBuffer = msaaFb;
  					renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;

  					if ( depthRenderbuffer === undefined ) {

  						depthRenderbuffer = gl.createRenderbuffer();
  						this.textureUtils.setupRenderBufferStorage( depthRenderbuffer, descriptor );

  						renderTargetContextData.depthRenderbuffer = depthRenderbuffer;

  						const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
  						invalidationArray.push( depthStyle );

  					}

  					renderTargetContextData.invalidationArray = invalidationArray;

  				}

  				currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;

  			} else {

  				currentFrameBuffer = fb;

  			}

  		}

  		state.bindFramebuffer( gl.FRAMEBUFFER, currentFrameBuffer );

  	}


  	_getVaoKey( index, attributes ) {

  		let key = [];

  		if ( index !== null ) {

  			const indexData = this.get( index );

  			key += ':' + indexData.id;

  		}

  		for ( let i = 0; i < attributes.length; i ++ ) {

  			const attributeData = this.get( attributes[ i ] );

  			key += ':' + attributeData.id;

  		}

  		return key;

  	}

  	_createVao( index, attributes ) {

  		const { gl } = this;

  		const vaoGPU = gl.createVertexArray();
  		let key = '';

  		let staticVao = true;

  		gl.bindVertexArray( vaoGPU );

  		if ( index !== null ) {

  			const indexData = this.get( index );

  			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU );

  			key += ':' + indexData.id;

  		}

  		for ( let i = 0; i < attributes.length; i ++ ) {

  			const attribute = attributes[ i ];
  			const attributeData = this.get( attribute );

  			key += ':' + attributeData.id;

  			gl.bindBuffer( gl.ARRAY_BUFFER, attributeData.bufferGPU );
  			gl.enableVertexAttribArray( i );

  			if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) staticVao = false;

  			let stride, offset;

  			if ( attribute.isInterleavedBufferAttribute === true ) {

  				stride = attribute.data.stride * attributeData.bytesPerElement;
  				offset = attribute.offset * attributeData.bytesPerElement;

  			} else {

  				stride = 0;
  				offset = 0;

  			}

  			if ( attributeData.isInteger ) {

  				gl.vertexAttribIPointer( i, attribute.itemSize, attributeData.type, stride, offset );

  			} else {

  				gl.vertexAttribPointer( i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset );

  			}

  			if ( attribute.isInstancedBufferAttribute && ! attribute.isInterleavedBufferAttribute ) {

  				gl.vertexAttribDivisor( i, attribute.meshPerAttribute );

  			} else if ( attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer ) {

  				gl.vertexAttribDivisor( i, attribute.data.meshPerAttribute );

  			}

  		}

  		gl.bindBuffer( gl.ARRAY_BUFFER, null );

  		this.vaoCache[ key ] = vaoGPU;

  		return { vaoGPU, staticVao };

  	}

  	_getTransformFeedback( transformBuffers ) {

  		let key = '';

  		for ( let i = 0; i < transformBuffers.length; i ++ ) {

  			key += ':' + transformBuffers[ i ].id;

  		}

  		let transformFeedbackGPU = this.transformFeedbackCache[ key ];

  		if ( transformFeedbackGPU !== undefined ) {

  			return transformFeedbackGPU;

  		}

  		const { gl } = this;

  		transformFeedbackGPU = gl.createTransformFeedback();

  		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );

  		for ( let i = 0; i < transformBuffers.length; i ++ ) {

  			const attributeData = transformBuffers[ i ];

  			gl.bindBufferBase( gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer );

  		}

  		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );

  		this.transformFeedbackCache[ key ] = transformFeedbackGPU;

  		return transformFeedbackGPU;

  	}


  	_setupBindings( bindings, programGPU ) {

  		const gl = this.gl;

  		for ( const bindGroup of bindings ) {

  			for ( const binding of bindGroup.bindings ) {

  				const bindingData = this.get( binding );
  				const index = bindingData.index;

  				if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

  					const location = gl.getUniformBlockIndex( programGPU, binding.name );
  					gl.uniformBlockBinding( programGPU, location, index );

  				} else if ( binding.isSampledTexture ) {

  					const location = gl.getUniformLocation( programGPU, binding.name );
  					gl.uniform1i( location, index );

  				}

  			}

  		}

  	}

  	_bindUniforms( bindings ) {

  		const { gl, state } = this;

  		for ( const bindGroup of bindings ) {

  			for ( const binding of bindGroup.bindings ) {

  				const bindingData = this.get( binding );
  				const index = bindingData.index;

  				if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

  					// TODO USE bindBufferRange to group multiple uniform buffers
  					state.bindBufferBase( gl.UNIFORM_BUFFER, index, bindingData.bufferGPU );

  				} else if ( binding.isSampledTexture ) {

  					state.bindTexture( bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index );

  				}

  			}

  		}

  	}

  }

  class Sampler extends Binding {

  	constructor( name, texture ) {

  		super( name );

  		this.texture = texture;
  		this.version = texture ? texture.version : 0;

  		this.isSampler = true;

  	}

  }

  class NodeSampler extends Sampler {

  	constructor( name, textureNode, groupNode ) {

  		super( name, textureNode ? textureNode.value : null );

  		this.textureNode = textureNode;
  		this.groupNode = groupNode;

  	}

  	update() {

  		this.texture = this.textureNode.value;

  	}

  }

  class StorageBuffer extends Buffer {

  	constructor( name, attribute ) {

  		super( name, attribute ? attribute.array : null );

  		this.attribute = attribute;

  		this.isStorageBuffer = true;

  	}

  }

  let _id = 0;

  class NodeStorageBuffer extends StorageBuffer {

  	constructor( nodeUniform, groupNode ) {

  		super( 'StorageBuffer_' + _id ++, nodeUniform ? nodeUniform.value : null );

  		this.nodeUniform = nodeUniform;
  		this.access = nodeUniform ? nodeUniform.access : GPUBufferBindingType.Storage;
  		this.groupNode = groupNode;


  	}

  	get buffer() {

  		return this.nodeUniform.value;

  	}

  }

  class WebGPUTexturePassUtils extends DataMap {

  	constructor( device ) {

  		super();

  		this.device = device;

  		const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;

  		const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;

  		const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
  		this.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );
  		this.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()

  		// We'll need a new pipeline for every texture format used.
  		this.transferPipelines = {};
  		this.flipYPipelines = {};

  		this.mipmapVertexShaderModule = device.createShaderModule( {
  			label: 'mipmapVertex',
  			code: mipmapVertexSource
  		} );

  		this.mipmapFragmentShaderModule = device.createShaderModule( {
  			label: 'mipmapFragment',
  			code: mipmapFragmentSource
  		} );

  		this.flipYFragmentShaderModule = device.createShaderModule( {
  			label: 'flipYFragment',
  			code: flipYFragmentSource
  		} );

  	}

  	getTransferPipeline( format ) {

  		let pipeline = this.transferPipelines[ format ];

  		if ( pipeline === undefined ) {

  			pipeline = this.device.createRenderPipeline( {
  				label: `mipmap-${ format }`,
  				vertex: {
  					module: this.mipmapVertexShaderModule,
  					entryPoint: 'main'
  				},
  				fragment: {
  					module: this.mipmapFragmentShaderModule,
  					entryPoint: 'main',
  					targets: [ { format } ]
  				},
  				primitive: {
  					topology: GPUPrimitiveTopology.TriangleStrip,
  					stripIndexFormat: GPUIndexFormat.Uint32
  				},
  				layout: 'auto'
  			} );

  			this.transferPipelines[ format ] = pipeline;

  		}

  		return pipeline;

  	}

  	getFlipYPipeline( format ) {

  		let pipeline = this.flipYPipelines[ format ];

  		if ( pipeline === undefined ) {

  			pipeline = this.device.createRenderPipeline( {
  				label: `flipY-${ format }`,
  				vertex: {
  					module: this.mipmapVertexShaderModule,
  					entryPoint: 'main'
  				},
  				fragment: {
  					module: this.flipYFragmentShaderModule,
  					entryPoint: 'main',
  					targets: [ { format } ]
  				},
  				primitive: {
  					topology: GPUPrimitiveTopology.TriangleStrip,
  					stripIndexFormat: GPUIndexFormat.Uint32
  				},
  				layout: 'auto'
  			} );

  			this.flipYPipelines[ format ] = pipeline;

  		}

  		return pipeline;

  	}

  	flipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {

  		const format = textureGPUDescriptor.format;
  		const { width, height } = textureGPUDescriptor.size;

  		const transferPipeline = this.getTransferPipeline( format );
  		const flipYPipeline = this.getFlipYPipeline( format );

  		const tempTexture = this.device.createTexture( {
  			size: { width, height, depthOrArrayLayers: 1 },
  			format,
  			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
  		} );

  		const srcView = textureGPU.createView( {
  			baseMipLevel: 0,
  			mipLevelCount: 1,
  			dimension: GPUTextureViewDimension.TwoD,
  			baseArrayLayer
  		} );

  		const dstView = tempTexture.createView( {
  			baseMipLevel: 0,
  			mipLevelCount: 1,
  			dimension: GPUTextureViewDimension.TwoD,
  			baseArrayLayer: 0
  		} );

  		const commandEncoder = this.device.createCommandEncoder( {} );

  		const pass = ( pipeline, sourceView, destinationView ) => {

  			const bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.

  			const bindGroup = this.device.createBindGroup( {
  				layout: bindGroupLayout,
  				entries: [ {
  					binding: 0,
  					resource: this.flipYSampler
  				}, {
  					binding: 1,
  					resource: sourceView
  				} ]
  			} );

  			const passEncoder = commandEncoder.beginRenderPass( {
  				colorAttachments: [ {
  					view: destinationView,
  					loadOp: GPULoadOp.Clear,
  					storeOp: GPUStoreOp.Store,
  					clearValue: [ 0, 0, 0, 0 ]
  				} ]
  			} );

  			passEncoder.setPipeline( pipeline );
  			passEncoder.setBindGroup( 0, bindGroup );
  			passEncoder.draw( 4, 1, 0, 0 );
  			passEncoder.end();

  		};

  		pass( transferPipeline, srcView, dstView );
  		pass( flipYPipeline, dstView, srcView );

  		this.device.queue.submit( [ commandEncoder.finish() ] );

  		tempTexture.destroy();

  	}

  	generateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {

  		const textureData = this.get( textureGPU );

  		if ( textureData.useCount === undefined ) {

  			textureData.useCount = 0;
  			textureData.layers = [];

  		}

  		const passes = textureData.layers[ baseArrayLayer ] || this._mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer );

  		const commandEncoder = this.device.createCommandEncoder( {} );

  		this._mipmapRunBundles( commandEncoder, passes );

  		this.device.queue.submit( [ commandEncoder.finish() ] );

  		if ( textureData.useCount !== 0 ) textureData.layers[ baseArrayLayer ] = passes;

  		textureData.useCount ++;

  	}

  	_mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer ) {

  		const pipeline = this.getTransferPipeline( textureGPUDescriptor.format );

  		const bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.

  		let srcView = textureGPU.createView( {
  			baseMipLevel: 0,
  			mipLevelCount: 1,
  			dimension: GPUTextureViewDimension.TwoD,
  			baseArrayLayer
  		} );

  		const passes = [];

  		for ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {

  			const bindGroup = this.device.createBindGroup( {
  				layout: bindGroupLayout,
  				entries: [ {
  					binding: 0,
  					resource: this.mipmapSampler
  				}, {
  					binding: 1,
  					resource: srcView
  				} ]
  			} );

  			const dstView = textureGPU.createView( {
  				baseMipLevel: i,
  				mipLevelCount: 1,
  				dimension: GPUTextureViewDimension.TwoD,
  				baseArrayLayer
  			} );

  			const passDescriptor = {
  				colorAttachments: [ {
  					view: dstView,
  					loadOp: GPULoadOp.Clear,
  					storeOp: GPUStoreOp.Store,
  					clearValue: [ 0, 0, 0, 0 ]
  				} ]
  			};

  			const passEncoder = this.device.createRenderBundleEncoder( {
  				colorFormats: [ textureGPUDescriptor.format ]
  			} );

  			passEncoder.setPipeline( pipeline );
  			passEncoder.setBindGroup( 0, bindGroup );
  			passEncoder.draw( 4, 1, 0, 0 );

  			passes.push( {
  				renderBundles: [ passEncoder.finish() ],
  				passDescriptor
  			} );

  			srcView = dstView;

  		}

  		return passes;

  	}

  	_mipmapRunBundles( commandEncoder, passes ) {

  		const levels = passes.length;

  		for ( let i = 0; i < levels; i ++ ) {

  			const pass = passes[ i ];

  			const passEncoder = commandEncoder.beginRenderPass( pass.passDescriptor );

  			passEncoder.executeBundles( pass.renderBundles );

  			passEncoder.end();

  		}

  	}

  }

  const _compareToWebGPU = {
  	[ NeverCompare ]: 'never',
  	[ LessCompare ]: 'less',
  	[ EqualCompare ]: 'equal',
  	[ LessEqualCompare ]: 'less-equal',
  	[ GreaterCompare ]: 'greater',
  	[ GreaterEqualCompare ]: 'greater-equal',
  	[ AlwaysCompare ]: 'always',
  	[ NotEqualCompare ]: 'not-equal'
  };

  const _flipMap = [ 0, 1, 3, 2, 4, 5 ];

  class WebGPUTextureUtils {

  	constructor( backend ) {

  		this.backend = backend;

  		this._passUtils = null;

  		this.defaultTexture = {};
  		this.defaultCubeTexture = {};
  		this.defaultVideoFrame = null;

  		this.colorBuffer = null;

  		this.depthTexture = new DepthTexture();
  		this.depthTexture.name = 'depthBuffer';

  	}

  	createSampler( texture ) {

  		const backend = this.backend;
  		const device = backend.device;

  		const textureGPU = backend.get( texture );

  		const samplerDescriptorGPU = {
  			addressModeU: this._convertAddressMode( texture.wrapS ),
  			addressModeV: this._convertAddressMode( texture.wrapT ),
  			addressModeW: this._convertAddressMode( texture.wrapR ),
  			magFilter: this._convertFilterMode( texture.magFilter ),
  			minFilter: this._convertFilterMode( texture.minFilter ),
  			mipmapFilter: this._convertFilterMode( texture.minFilter ),
  			maxAnisotropy: texture.anisotropy
  		};

  		if ( texture.isDepthTexture && texture.compareFunction !== null ) {

  			samplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];

  		}

  		textureGPU.sampler = device.createSampler( samplerDescriptorGPU );

  	}

  	createDefaultTexture( texture ) {

  		let textureGPU;

  		const format = getFormat( texture );

  		if ( texture.isCubeTexture ) {

  			textureGPU = this._getDefaultCubeTextureGPU( format );

  		} else if ( texture.isVideoTexture ) {

  			this.backend.get( texture ).externalTexture = this._getDefaultVideoFrame();

  		} else {

  			textureGPU = this._getDefaultTextureGPU( format );

  		}

  		this.backend.get( texture ).texture = textureGPU;

  	}

  	createTexture( texture, options = {} ) {

  		const backend = this.backend;
  		const textureData = backend.get( texture );

  		if ( textureData.initialized ) {

  			throw new Error( 'WebGPUTextureUtils: Texture already initialized.' );

  		}

  		if ( options.needsMipmaps === undefined ) options.needsMipmaps = false;
  		if ( options.levels === undefined ) options.levels = 1;
  		if ( options.depth === undefined ) options.depth = 1;

  		const { width, height, depth, levels } = options;

  		const dimension = this._getDimension( texture );
  		const format = texture.internalFormat || options.format || getFormat( texture, backend.device );

  		textureData.format = format;

  		let sampleCount = options.sampleCount !== undefined ? options.sampleCount : 1;

  		sampleCount = backend.utils.getSampleCount( sampleCount );

  		const primarySampleCount = texture.isRenderTargetTexture && ! texture.isMultisampleRenderTargetTexture ? 1 : sampleCount;

  		let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;

  		if ( texture.isStorageTexture === true ) {

  			usage |= GPUTextureUsage.STORAGE_BINDING;

  		}

  		if ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true ) {

  			usage |= GPUTextureUsage.RENDER_ATTACHMENT;

  		}

  		const textureDescriptorGPU = {
  			label: texture.name,
  			size: {
  				width: width,
  				height: height,
  				depthOrArrayLayers: depth,
  			},
  			mipLevelCount: levels,
  			sampleCount: primarySampleCount,
  			dimension: dimension,
  			format: format,
  			usage: usage
  		};

  		// texture creation

  		if ( texture.isVideoTexture ) {

  			const video = texture.source.data;
  			const videoFrame = new VideoFrame( video );

  			textureDescriptorGPU.size.width = videoFrame.displayWidth;
  			textureDescriptorGPU.size.height = videoFrame.displayHeight;

  			videoFrame.close();

  			textureData.externalTexture = video;

  		} else {

  			if ( format === undefined ) {

  				console.warn( 'WebGPURenderer: Texture format not supported.' );

  				return this.createDefaultTexture( texture );

  			}

  			textureData.texture = backend.device.createTexture( textureDescriptorGPU );

  		}

  		if ( texture.isRenderTargetTexture && sampleCount > 1 && ! texture.isMultisampleRenderTargetTexture ) {

  			const msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );

  			msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';
  			msaaTextureDescriptorGPU.sampleCount = sampleCount;

  			textureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );

  		}

  		textureData.initialized = true;

  		textureData.textureDescriptorGPU = textureDescriptorGPU;

  	}

  	destroyTexture( texture ) {

  		const backend = this.backend;
  		const textureData = backend.get( texture );

  		textureData.texture.destroy();

  		if ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();

  		backend.delete( texture );

  	}

  	destroySampler( texture ) {

  		const backend = this.backend;
  		const textureData = backend.get( texture );

  		delete textureData.sampler;

  	}

  	generateMipmaps( texture ) {

  		const textureData = this.backend.get( texture );

  		if ( texture.isCubeTexture ) {

  			for ( let i = 0; i < 6; i ++ ) {

  				this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );

  			}

  		} else {

  			const depth = texture.image.depth || 1;

  			for ( let i = 0; i < depth; i ++ ) {

  				this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );

  			}

  		}

  	}

  	getColorBuffer() {

  		if ( this.colorBuffer ) this.colorBuffer.destroy();

  		const backend = this.backend;
  		const { width, height } = backend.getDrawingBufferSize();

  		this.colorBuffer = backend.device.createTexture( {
  			label: 'colorBuffer',
  			size: {
  				width: width,
  				height: height,
  				depthOrArrayLayers: 1
  			},
  			sampleCount: backend.utils.getSampleCount( backend.renderer.samples ),
  			format: backend.utils.getPreferredCanvasFormat(),
  			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
  		} );

  		return this.colorBuffer;

  	}

  	getDepthBuffer( depth = true, stencil = false ) {

  		const backend = this.backend;
  		const { width, height } = backend.getDrawingBufferSize();

  		const depthTexture = this.depthTexture;
  		const depthTextureGPU = backend.get( depthTexture ).texture;

  		let format, type;

  		if ( stencil ) {

  			format = DepthStencilFormat;
  			type = UnsignedInt248Type;

  		} else if ( depth ) {

  			format = DepthFormat;
  			type = UnsignedIntType;

  		}

  		if ( depthTextureGPU !== undefined ) {

  			if ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {

  				return depthTextureGPU;

  			}

  			this.destroyTexture( depthTexture );

  		}

  		depthTexture.name = 'depthBuffer';
  		depthTexture.format = format;
  		depthTexture.type = type;
  		depthTexture.image.width = width;
  		depthTexture.image.height = height;

  		this.createTexture( depthTexture, { sampleCount: backend.utils.getSampleCount( backend.renderer.samples ), width, height } );

  		return backend.get( depthTexture ).texture;

  	}

  	updateTexture( texture, options ) {

  		const textureData = this.backend.get( texture );

  		const { textureDescriptorGPU } = textureData;

  		if ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )
  			return;

  		// transfer texture data

  		if ( texture.isDataTexture ) {

  			this._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );

  		} else if ( texture.isDataArrayTexture || texture.isData3DTexture ) {

  			for ( let i = 0; i < options.image.depth; i ++ ) {

  				this._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );

  			}

  		} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {

  			this._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );

  		} else if ( texture.isCubeTexture ) {

  			this._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY );

  		} else if ( texture.isVideoTexture ) {

  			const video = texture.source.data;

  			textureData.externalTexture = video;

  		} else {

  			this._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );

  		}

  		//

  		textureData.version = texture.version;

  		if ( texture.onUpdate ) texture.onUpdate( texture );

  	}

  	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

  		const device = this.backend.device;

  		const textureData = this.backend.get( texture );
  		const textureGPU = textureData.texture;
  		const format = textureData.textureDescriptorGPU.format;
  		const bytesPerTexel = this._getBytesPerTexel( format );

  		let bytesPerRow = width * bytesPerTexel;
  		bytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes

  		const readBuffer = device.createBuffer(
  			{
  				size: width * height * bytesPerTexel,
  				usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  			}
  		);

  		const encoder = device.createCommandEncoder();

  		encoder.copyTextureToBuffer(
  			{
  				texture: textureGPU,
  				origin: { x, y, z: faceIndex },
  			},
  			{
  				buffer: readBuffer,
  				bytesPerRow: bytesPerRow
  			},
  			{
  				width: width,
  				height: height
  			}

  		);

  		const typedArrayType = this._getTypedArrayType( format );

  		device.queue.submit( [ encoder.finish() ] );

  		await readBuffer.mapAsync( GPUMapMode.READ );

  		const buffer = readBuffer.getMappedRange();

  		return new typedArrayType( buffer );

  	}

  	_isEnvironmentTexture( texture ) {

  		const mapping = texture.mapping;

  		return ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

  	}

  	_getDefaultTextureGPU( format ) {

  		let defaultTexture = this.defaultTexture[ format ];

  		if ( defaultTexture === undefined ) {

  			const texture = new Texture();
  			texture.minFilter = NearestFilter;
  			texture.magFilter = NearestFilter;

  			this.createTexture( texture, { width: 1, height: 1, format } );

  			this.defaultTexture[ format ] = defaultTexture = texture;

  		}

  		return this.backend.get( defaultTexture ).texture;

  	}

  	_getDefaultCubeTextureGPU( format ) {

  		let defaultCubeTexture = this.defaultTexture[ format ];

  		if ( defaultCubeTexture === undefined ) {

  			const texture = new CubeTexture();
  			texture.minFilter = NearestFilter;
  			texture.magFilter = NearestFilter;

  			this.createTexture( texture, { width: 1, height: 1, depth: 6 } );

  			this.defaultCubeTexture[ format ] = defaultCubeTexture = texture;

  		}

  		return this.backend.get( defaultCubeTexture ).texture;

  	}

  	_getDefaultVideoFrame() {

  		let defaultVideoFrame = this.defaultVideoFrame;

  		if ( defaultVideoFrame === null ) {

  			const init = {
  				timestamp: 0,
  				codedWidth: 1,
  				codedHeight: 1,
  				format: 'RGBA',
  			};

  			this.defaultVideoFrame = defaultVideoFrame = new VideoFrame( new Uint8Array( [ 0, 0, 0, 0xff ] ), init );

  		}

  		return defaultVideoFrame;

  	}

  	_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY ) {

  		for ( let i = 0; i < 6; i ++ ) {

  			const image = images[ i ];

  			const flipIndex = flipY === true ? _flipMap[ i ] : i;

  			if ( image.isDataTexture ) {

  				this._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );

  			} else {

  				this._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY );

  			}

  		}

  	}

  	_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY ) {

  		const device = this.backend.device;

  		device.queue.copyExternalImageToTexture(
  			{
  				source: image
  			}, {
  				texture: textureGPU,
  				mipLevel: 0,
  				origin: { x: 0, y: 0, z: originDepth }
  			}, {
  				width: image.width,
  				height: image.height,
  				depthOrArrayLayers: 1
  			}
  		);

  		if ( flipY === true ) {

  			this._flipY( textureGPU, textureDescriptorGPU, originDepth );

  		}

  	}

  	_getPassUtils() {

  		let passUtils = this._passUtils;

  		if ( passUtils === null ) {

  			this._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );

  		}

  		return passUtils;

  	}

  	_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {

  		this._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );

  	}

  	_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {

  		this._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );

  	}

  	_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0 ) {

  		// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()
  		// @TODO: Consider to support valid buffer layouts with other formats like RGB

  		const device = this.backend.device;

  		const data = image.data;

  		const bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );
  		const bytesPerRow = image.width * bytesPerTexel;

  		device.queue.writeTexture(
  			{
  				texture: textureGPU,
  				mipLevel: 0,
  				origin: { x: 0, y: 0, z: originDepth }
  			},
  			data,
  			{
  				offset: image.width * image.height * bytesPerTexel * depth,
  				bytesPerRow
  			},
  			{
  				width: image.width,
  				height: image.height,
  				depthOrArrayLayers: 1
  			} );

  		if ( flipY === true ) {

  			this._flipY( textureGPU, textureDescriptorGPU, originDepth );

  		}

  	}

  	_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {

  		// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()

  		const device = this.backend.device;

  		const blockData = this._getBlockData( textureDescriptorGPU.format );
  		const isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;

  		for ( let i = 0; i < mipmaps.length; i ++ ) {

  			const mipmap = mipmaps[ i ];

  			const width = mipmap.width;
  			const height = mipmap.height;
  			const depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;

  			const bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;
  			const bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );

  			for ( let j = 0; j < depth; j ++ ) {

  				device.queue.writeTexture(
  					{
  						texture: textureGPU,
  						mipLevel: i,
  						origin: { x: 0, y: 0, z: j }
  					},
  					mipmap.data,
  					{
  						offset: j * bytesPerImage,
  						bytesPerRow,
  						rowsPerImage: Math.ceil( height / blockData.height )
  					},
  					{
  						width: Math.ceil( width / blockData.width ) * blockData.width,
  						height: Math.ceil( height / blockData.height ) * blockData.height,
  						depthOrArrayLayers: 1
  					}
  				);

  			}

  		}

  	}

  	_getBlockData( format ) {

  		// this method is only relevant for compressed texture formats

  		if ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1
  		if ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3
  		if ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5
  		if ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1
  		if ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2
  		if ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)
  		if ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)

  		if ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };

  		if ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
  		if ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };
  		if ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };
  		if ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };
  		if ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };
  		if ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };
  		if ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };
  		if ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };
  		if ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };
  		if ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };
  		if ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };
  		if ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };
  		if ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };
  		if ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };

  	}

  	_convertAddressMode( value ) {

  		let addressMode = GPUAddressMode.ClampToEdge;

  		if ( value === RepeatWrapping ) {

  			addressMode = GPUAddressMode.Repeat;

  		} else if ( value === MirroredRepeatWrapping ) {

  			addressMode = GPUAddressMode.MirrorRepeat;

  		}

  		return addressMode;

  	}

  	_convertFilterMode( value ) {

  		let filterMode = GPUFilterMode.Linear;

  		if ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {

  			filterMode = GPUFilterMode.Nearest;

  		}

  		return filterMode;

  	}

  	_getBytesPerTexel( format ) {

  		// 8-bit formats
  		if ( format === GPUTextureFormat.R8Unorm ||
  			format === GPUTextureFormat.R8Snorm ||
  			format === GPUTextureFormat.R8Uint ||
  			format === GPUTextureFormat.R8Sint ) return 1;

  		// 16-bit formats
  		if ( format === GPUTextureFormat.R16Uint ||
  			format === GPUTextureFormat.R16Sint ||
  			format === GPUTextureFormat.R16Float ||
  			format === GPUTextureFormat.RG8Unorm ||
  			format === GPUTextureFormat.RG8Snorm ||
  			format === GPUTextureFormat.RG8Uint ||
  			format === GPUTextureFormat.RG8Sint ) return 2;

  		// 32-bit formats
  		if ( format === GPUTextureFormat.R32Uint ||
  			format === GPUTextureFormat.R32Sint ||
  			format === GPUTextureFormat.R32Float ||
  			format === GPUTextureFormat.RG16Uint ||
  			format === GPUTextureFormat.RG16Sint ||
  			format === GPUTextureFormat.RG16Float ||
  			format === GPUTextureFormat.RGBA8Unorm ||
  			format === GPUTextureFormat.RGBA8UnormSRGB ||
  			format === GPUTextureFormat.RGBA8Snorm ||
  			format === GPUTextureFormat.RGBA8Uint ||
  			format === GPUTextureFormat.RGBA8Sint ||
  			format === GPUTextureFormat.BGRA8Unorm ||
  			format === GPUTextureFormat.BGRA8UnormSRGB ||
  			// Packed 32-bit formats
  			format === GPUTextureFormat.RGB9E5UFloat ||
  			format === GPUTextureFormat.RGB10A2Unorm ||
  			format === GPUTextureFormat.RG11B10UFloat ||
  			format === GPUTextureFormat.Depth32Float ||
  			format === GPUTextureFormat.Depth24Plus ||
  			format === GPUTextureFormat.Depth24PlusStencil8 ||
  			format === GPUTextureFormat.Depth32FloatStencil8 ) return 4;

  		// 64-bit formats
  		if ( format === GPUTextureFormat.RG32Uint ||
  			format === GPUTextureFormat.RG32Sint ||
  			format === GPUTextureFormat.RG32Float ||
  			format === GPUTextureFormat.RGBA16Uint ||
  			format === GPUTextureFormat.RGBA16Sint ||
  			format === GPUTextureFormat.RGBA16Float ) return 8;

  		// 128-bit formats
  		if ( format === GPUTextureFormat.RGBA32Uint ||
  			format === GPUTextureFormat.RGBA32Sint ||
  			format === GPUTextureFormat.RGBA32Float ) return 16;


  	}

  	_getTypedArrayType( format ) {

  		if ( format === GPUTextureFormat.R8Uint ) return Uint8Array;
  		if ( format === GPUTextureFormat.R8Sint ) return Int8Array;
  		if ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;
  		if ( format === GPUTextureFormat.R8Snorm ) return Int8Array;
  		if ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;
  		if ( format === GPUTextureFormat.RG8Sint ) return Int8Array;
  		if ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;
  		if ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;
  		if ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;
  		if ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;
  		if ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;
  		if ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;


  		if ( format === GPUTextureFormat.R16Uint ) return Uint16Array;
  		if ( format === GPUTextureFormat.R16Sint ) return Int16Array;
  		if ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;
  		if ( format === GPUTextureFormat.RG16Sint ) return Int16Array;
  		if ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;
  		if ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;
  		if ( format === GPUTextureFormat.R16Float ) return Uint16Array;
  		if ( format === GPUTextureFormat.RG16Float ) return Uint16Array;
  		if ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;


  		if ( format === GPUTextureFormat.R32Uint ) return Uint32Array;
  		if ( format === GPUTextureFormat.R32Sint ) return Int32Array;
  		if ( format === GPUTextureFormat.R32Float ) return Float32Array;
  		if ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;
  		if ( format === GPUTextureFormat.RG32Sint ) return Int32Array;
  		if ( format === GPUTextureFormat.RG32Float ) return Float32Array;
  		if ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;
  		if ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;
  		if ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;

  		if ( format === GPUTextureFormat.BGRA8Unorm ) return Uint8Array;
  		if ( format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;
  		if ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;
  		if ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;
  		if ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;

  		if ( format === GPUTextureFormat.Depth32Float ) return Float32Array;
  		if ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;
  		if ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;
  		if ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;

  	}

  	_getDimension( texture ) {

  		let dimension;

  		if ( texture.isData3DTexture ) {

  			dimension = GPUTextureDimension.ThreeD;

  		} else {

  			dimension = GPUTextureDimension.TwoD;

  		}

  		return dimension;

  	}

  }

  function getFormat( texture, device = null ) {

  	const format = texture.format;
  	const type = texture.type;
  	const colorSpace = texture.colorSpace;

  	let formatGPU;

  	if ( texture.isFramebufferTexture === true && texture.type === UnsignedByteType ) {

  		formatGPU = GPUTextureFormat.BGRA8Unorm;

  	} else if ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {

  		switch ( format ) {

  			case RGBA_S3TC_DXT1_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
  				break;

  			case RGBA_S3TC_DXT3_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
  				break;

  			case RGBA_S3TC_DXT5_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
  				break;

  			case RGB_ETC2_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
  				break;

  			case RGBA_ETC2_EAC_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
  				break;

  			case RGBA_ASTC_4x4_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
  				break;

  			case RGBA_ASTC_5x4_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
  				break;

  			case RGBA_ASTC_5x5_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
  				break;

  			case RGBA_ASTC_6x5_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
  				break;

  			case RGBA_ASTC_6x6_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
  				break;

  			case RGBA_ASTC_8x5_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
  				break;

  			case RGBA_ASTC_8x6_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
  				break;

  			case RGBA_ASTC_8x8_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
  				break;

  			case RGBA_ASTC_10x5_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
  				break;

  			case RGBA_ASTC_10x6_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
  				break;

  			case RGBA_ASTC_10x8_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
  				break;

  			case RGBA_ASTC_10x10_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
  				break;

  			case RGBA_ASTC_12x10_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
  				break;

  			case RGBA_ASTC_12x12_Format:
  				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
  				break;

  			default:
  				console.error( 'WebGPURenderer: Unsupported texture format.', format );

  		}

  	} else {

  		switch ( format ) {

  			case RGBAFormat:

  				switch ( type ) {

  					case ByteType:
  						formatGPU = GPUTextureFormat.RGBA8Snorm;
  						break;

  					case ShortType:
  						formatGPU = GPUTextureFormat.RGBA16Sint;
  						break;

  					case UnsignedShortType:
  						formatGPU = GPUTextureFormat.RGBA16Uint;
  						break;
  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.RGBA32Uint;
  						break;

  					case IntType:
  						formatGPU = GPUTextureFormat.RGBA32Sint;
  						break;

  					case UnsignedByteType:
  						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
  						break;

  					case HalfFloatType:
  						formatGPU = GPUTextureFormat.RGBA16Float;
  						break;

  					case FloatType:
  						formatGPU = GPUTextureFormat.RGBA32Float;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );

  				}

  				break;

  			case RGBFormat:

  				switch ( type ) {

  					case UnsignedInt5999Type:
  						formatGPU = GPUTextureFormat.RGB9E5UFloat;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );

  				}

  				break;

  			case RedFormat:

  				switch ( type ) {

  					case ByteType:
  						formatGPU = GPUTextureFormat.R8Snorm;
  						break;

  					case ShortType:
  						formatGPU = GPUTextureFormat.R16Sint;
  						break;

  					case UnsignedShortType:
  						formatGPU = GPUTextureFormat.R16Uint;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.R32Uint;
  						break;

  					case IntType:
  						formatGPU = GPUTextureFormat.R32Sint;
  						break;

  					case UnsignedByteType:
  						formatGPU = GPUTextureFormat.R8Unorm;
  						break;

  					case HalfFloatType:
  						formatGPU = GPUTextureFormat.R16Float;
  						break;

  					case FloatType:
  						formatGPU = GPUTextureFormat.R32Float;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );

  				}

  				break;

  			case RGFormat:

  				switch ( type ) {

  					case ByteType:
  						formatGPU = GPUTextureFormat.RG8Snorm;
  						break;

  					case ShortType:
  						formatGPU = GPUTextureFormat.RG16Sint;
  						break;

  					case UnsignedShortType:
  						formatGPU = GPUTextureFormat.RG16Uint;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.RG32Uint;
  						break;

  					case IntType:
  						formatGPU = GPUTextureFormat.RG32Sint;
  						break;

  					case UnsignedByteType:
  						formatGPU = GPUTextureFormat.RG8Unorm;
  						break;

  					case HalfFloatType:
  						formatGPU = GPUTextureFormat.RG16Float;
  						break;

  					case FloatType:
  						formatGPU = GPUTextureFormat.RG32Float;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );

  				}

  				break;

  			case DepthFormat:

  				switch ( type ) {

  					case UnsignedShortType:
  						formatGPU = GPUTextureFormat.Depth16Unorm;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.Depth24Plus;
  						break;

  					case FloatType:
  						formatGPU = GPUTextureFormat.Depth32Float;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );

  				}

  				break;

  			case DepthStencilFormat:

  				switch ( type ) {

  					case UnsignedInt248Type:
  						formatGPU = GPUTextureFormat.Depth24PlusStencil8;
  						break;

  					case FloatType:

  						if ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {

  							console.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.' );

  						}

  						formatGPU = GPUTextureFormat.Depth32FloatStencil8;

  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );

  				}

  				break;

  			case RedIntegerFormat:

  				switch ( type ) {

  					case IntType:
  						formatGPU = GPUTextureFormat.R32Sint;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.R32Uint;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );

  				}

  				break;

  			case RGIntegerFormat:

  				switch ( type ) {

  					case IntType:
  						formatGPU = GPUTextureFormat.RG32Sint;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.RG32Uint;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );

  				}

  				break;

  			case RGBAIntegerFormat:

  				switch ( type ) {

  					case IntType:
  						formatGPU = GPUTextureFormat.RGBA32Sint;
  						break;

  					case UnsignedIntType:
  						formatGPU = GPUTextureFormat.RGBA32Uint;
  						break;

  					default:
  						console.error( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );

  				}

  				break;

  			default:
  				console.error( 'WebGPURenderer: Unsupported texture format.', format );

  		}

  	}

  	return formatGPU;

  }

  const declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i;
  const propertiesRegexp = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig;

  const wgslTypeLib$1 = {
  	'f32': 'float',
  	'i32': 'int',
  	'u32': 'uint',
  	'bool': 'bool',

  	'vec2<f32>': 'vec2',
   	'vec2<i32>': 'ivec2',
   	'vec2<u32>': 'uvec2',
   	'vec2<bool>': 'bvec2',

  	'vec2f': 'vec2',
  	'vec2i': 'ivec2',
  	'vec2u': 'uvec2',
  	'vec2b': 'bvec2',

  	'vec3<f32>': 'vec3',
  	'vec3<i32>': 'ivec3',
  	'vec3<u32>': 'uvec3',
  	'vec3<bool>': 'bvec3',

  	'vec3f': 'vec3',
  	'vec3i': 'ivec3',
  	'vec3u': 'uvec3',
  	'vec3b': 'bvec3',

  	'vec4<f32>': 'vec4',
  	'vec4<i32>': 'ivec4',
  	'vec4<u32>': 'uvec4',
  	'vec4<bool>': 'bvec4',

  	'vec4f': 'vec4',
  	'vec4i': 'ivec4',
  	'vec4u': 'uvec4',
  	'vec4b': 'bvec4',

  	'mat2x2<f32>': 'mat2',
  	'mat2x2f': 'mat2',

  	'mat3x3<f32>': 'mat3',
  	'mat3x3f': 'mat3',

  	'mat4x4<f32>': 'mat4',
  	'mat4x4f': 'mat4',

  	'sampler': 'sampler',

  	'texture_1d': 'texture',

  	'texture_2d': 'texture',
  	'texture_2d_array': 'texture',
  	'texture_multisampled_2d': 'cubeTexture',

  	'texture_depth_2d': 'depthTexture',

  	'texture_3d': 'texture3D',

  	'texture_cube': 'cubeTexture',
  	'texture_cube_array': 'cubeTexture',

  	'texture_storage_1d': 'storageTexture',
  	'texture_storage_2d': 'storageTexture',
  	'texture_storage_2d_array': 'storageTexture',
  	'texture_storage_3d': 'storageTexture'

  };

  const parse = ( source ) => {

  	source = source.trim();

  	const declaration = source.match( declarationRegexp );

  	if ( declaration !== null && declaration.length === 4 ) {

  		const inputsCode = declaration[ 2 ];
  		const propsMatches = [];
  		let match = null;

  		while ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {

  			propsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );

  		}

  		// Process matches to correctly pair names and types
  		const inputs = [];
  		for ( let i = 0; i < propsMatches.length; i ++ ) {

  			const { name, type } = propsMatches[ i ];

  			let resolvedType = type;

  			if ( resolvedType.startsWith( 'texture' ) ) {

  				resolvedType = type.split( '<' )[ 0 ];

  			}

  			resolvedType = wgslTypeLib$1[ resolvedType ] || resolvedType;

  			inputs.push( new NodeFunctionInput( resolvedType, name ) );

  		}

  		const blockCode = source.substring( declaration[ 0 ].length );
  		const outputType = declaration[ 3 ] || 'void';

  		const name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';
  		const type = wgslTypeLib$1[ outputType ] || outputType;

  		return {
  			type,
  			inputs,
  			name,
  			inputsCode,
  			blockCode,
  			outputType
  		};

  	} else {

  		throw new Error( 'FunctionNode: Function is not a WGSL code.' );

  	}

  };

  class WGSLNodeFunction extends NodeFunction {

  	constructor( source ) {

  		const { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );

  		super( type, inputs, name );

  		this.inputsCode = inputsCode;
  		this.blockCode = blockCode;
  		this.outputType = outputType;

  	}

  	getCode( name = this.name ) {

  		const outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';

  		return `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;

  	}

  }

  class WGSLNodeParser extends NodeParser {

  	parseFunction( source ) {

  		return new WGSLNodeFunction( source );

  	}

  }

  // GPUShaderStage is not defined in browsers not supporting WebGPU
  const GPUShaderStage = self.GPUShaderStage;

  const gpuShaderStageLib = {
  	'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,
  	'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
  	'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4
  };

  const supports = {
  	instance: true,
  	swizzleAssign: false,
  	storageBuffer: true
  };

  const wgslFnOpLib = {
  	'^^': 'tsl_xor'
  };

  const wgslTypeLib = {
  	float: 'f32',
  	int: 'i32',
  	uint: 'u32',
  	bool: 'bool',
  	color: 'vec3<f32>',

  	vec2: 'vec2<f32>',
  	ivec2: 'vec2<i32>',
  	uvec2: 'vec2<u32>',
  	bvec2: 'vec2<bool>',

  	vec3: 'vec3<f32>',
  	ivec3: 'vec3<i32>',
  	uvec3: 'vec3<u32>',
  	bvec3: 'vec3<bool>',

  	vec4: 'vec4<f32>',
  	ivec4: 'vec4<i32>',
  	uvec4: 'vec4<u32>',
  	bvec4: 'vec4<bool>',

  	mat2: 'mat2x2<f32>',
  	imat2: 'mat2x2<i32>',
  	umat2: 'mat2x2<u32>',
  	bmat2: 'mat2x2<bool>',

  	mat3: 'mat3x3<f32>',
  	imat3: 'mat3x3<i32>',
  	umat3: 'mat3x3<u32>',
  	bmat3: 'mat3x3<bool>',

  	mat4: 'mat4x4<f32>',
  	imat4: 'mat4x4<i32>',
  	umat4: 'mat4x4<u32>',
  	bmat4: 'mat4x4<bool>'
  };

  const wgslPolyfill = {
  	tsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),
  	mod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),
  	mod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),
  	mod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),
  	mod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),
  	equals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),
  	equals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),
  	equals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),
  	equals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),
  	repeatWrapping: new CodeNode( `
fn tsl_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {

	let uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );

	return ( ( uvScaled % dimension ) + dimension ) % dimension;

}
` ),
  	biquadraticTexture: new CodeNode( `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, level : i32 ) -> vec4f {

	let iRes = vec2i( textureDimensions( map, level ) );
	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2i( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2i( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2i( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2i( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
` )
  };

  const wgslMethods = {
  	dFdx: 'dpdx',
  	dFdy: '- dpdy',
  	mod_float: 'tsl_mod_float',
  	mod_vec2: 'tsl_mod_vec2',
  	mod_vec3: 'tsl_mod_vec3',
  	mod_vec4: 'tsl_mod_vec4',
  	equals_bool: 'tsl_equals_bool',
  	equals_bvec2: 'tsl_equals_bvec2',
  	equals_bvec3: 'tsl_equals_bvec3',
  	equals_bvec4: 'tsl_equals_bvec4',
  	inversesqrt: 'inverseSqrt',
  	bitcast: 'bitcast<f32>'
  };

  // WebGPU issue: does not support pow() with negative base on Windows

  if ( /Windows/g.test( navigator.userAgent ) ) {

  	wgslPolyfill.pow_float = new CodeNode( 'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }' );
  	wgslPolyfill.pow_vec2 = new CodeNode( 'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [ wgslPolyfill.pow_float ] );
  	wgslPolyfill.pow_vec3 = new CodeNode( 'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [ wgslPolyfill.pow_float ] );
  	wgslPolyfill.pow_vec4 = new CodeNode( 'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [ wgslPolyfill.pow_float ] );

  	wgslMethods.pow_float = 'tsl_pow_float';
  	wgslMethods.pow_vec2 = 'tsl_pow_vec2';
  	wgslMethods.pow_vec3 = 'tsl_pow_vec3';
  	wgslMethods.pow_vec4 = 'tsl_pow_vec4';

  }

  //

  let diagnostics = '';

  if ( /Firefox/g.test( navigator.userAgent ) !== true ) {

  	diagnostics += 'diagnostic( off, derivative_uniformity );\n';

  }

  //

  class WGSLNodeBuilder extends NodeBuilder {

  	constructor( object, renderer ) {

  		super( object, renderer, new WGSLNodeParser() );

  		this.uniformGroups = {};

  		this.builtins = {};

  		this.directives = {};

  		this.scopedArrays = new Map();

  	}

  	needsToWorkingColorSpace( texture ) {

  		return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;

  	}

  	_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			if ( depthSnippet ) {

  				return `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;

  			} else {

  				return `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;

  			}

  		} else if ( this.isFilteredTexture( texture ) ) {

  			return this.generateFilteredTexture( texture, textureProperty, uvSnippet );

  		} else {

  			return this.generateTextureLod( texture, textureProperty, uvSnippet, '0' );

  		}

  	}

  	_generateVideoSample( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			return `textureSampleBaseClampToEdge( ${ textureProperty }, ${ textureProperty }_sampler, vec2<f32>( ${ uvSnippet }.x, 1.0 - ${ uvSnippet }.y ) )`;

  		} else {

  			console.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );

  		}

  	}

  	_generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false ) {

  			return `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;

  		} else if ( this.isFilteredTexture( texture ) ) {

  			return this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );

  		} else {

  			return this.generateTextureLod( texture, textureProperty, uvSnippet, levelSnippet );

  		}

  	}

  	generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet = '0' ) {

  		this._include( 'biquadraticTexture' );

  		return `tsl_biquadraticTexture( ${ textureProperty }, ${ uvSnippet }, i32( ${ levelSnippet } ) )`;

  	}

  	generateTextureLod( texture, textureProperty, uvSnippet, levelSnippet = '0' ) {

  		this._include( 'repeatWrapping' );

  		const dimension = texture.isMultisampleRenderTargetTexture === true ? `textureDimensions( ${ textureProperty } )` : `textureDimensions( ${ textureProperty }, 0 )`;

  		return `textureLoad( ${ textureProperty }, tsl_repeatWrapping( ${ uvSnippet }, ${ dimension } ), i32( ${ levelSnippet } ) )`;

  	}

  	generateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u' ) {

  		if ( depthSnippet ) {

  			return `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, ${ levelSnippet } )`;

  		} else {

  			return `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;

  		}

  	}

  	generateTextureStore( texture, textureProperty, uvIndexSnippet, valueSnippet ) {

  		return `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;

  	}

  	isUnfilterable( texture ) {

  		return this.getComponentTypeFromTexture( texture ) !== 'float' || ( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) || texture.isMultisampleRenderTargetTexture === true;

  	}

  	generateTexture( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		let snippet = null;

  		if ( texture.isVideoTexture === true ) {

  			snippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );

  		} else if ( this.isUnfilterable( texture ) ) {

  			snippet = this.generateTextureLod( texture, textureProperty, uvSnippet, '0', depthSnippet, shaderStage );

  		} else {

  			snippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage );

  		}

  		return snippet;

  	}

  	generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy
  			return `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;

  		} else {

  			console.error( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );

  		}

  	}

  	generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			return `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;

  		} else {

  			console.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );

  		}

  	}

  	generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		let snippet = null;

  		if ( texture.isVideoTexture === true ) {

  			snippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );

  		} else {

  			snippet = this._generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage );

  		}

  		return snippet;

  	}

  	generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage ) {

  		if ( shaderStage === 'fragment' ) {

  			return `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;

  		} else {

  			console.error( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );

  		}

  	}

  	getPropertyName( node, shaderStage = this.shaderStage ) {

  		if ( node.isNodeVarying === true && node.needsInterpolation === true ) {

  			if ( shaderStage === 'vertex' ) {

  				return `varyings.${ node.name }`;

  			}

  		} else if ( node.isNodeUniform === true ) {

  			const name = node.name;
  			const type = node.type;

  			if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {

  				return name;

  			} else if ( type === 'buffer' || type === 'storageBuffer' ) {

  				return `NodeBuffer_${ node.id }.${name}`;

  			} else {

  				return node.groupNode.name + '.' + name;

  			}

  		}

  		return super.getPropertyName( node );

  	}

  	getOutputStructName() {

  		return 'output';

  	}

  	_getUniformGroupCount( shaderStage ) {

  		return Object.keys( this.uniforms[ shaderStage ] ).length;

  	}

  	getFunctionOperator( op ) {

  		const fnOp = wgslFnOpLib[ op ];

  		if ( fnOp !== undefined ) {

  			this._include( fnOp );

  			return fnOp;

  		}

  		return null;

  	}

  	getStorageAccess( node ) {

  		if ( node.isStorageTextureNode ) {

  			switch ( node.access ) {

  				case GPUStorageTextureAccess.ReadOnly:

  					return 'read';

  				case GPUStorageTextureAccess.WriteOnly:

  					return 'write';

  				default:

  					return 'read_write';

  			}

  		} else {

  			switch ( node.access ) {

  				case GPUBufferBindingType.Storage:

  					return 'read_write';


  				case GPUBufferBindingType.ReadOnlyStorage:

  					return 'read';

  				default:

  					return 'write';

  			}

  		}

  	}

  	getUniformFromNode( node, type, shaderStage, name = null ) {

  		const uniformNode = super.getUniformFromNode( node, type, shaderStage, name );
  		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

  		if ( nodeData.uniformGPU === undefined ) {

  			let uniformGPU;

  			const group = node.groupNode;
  			const groupName = group.name;

  			const bindings = this.getBindGroupArray( groupName, shaderStage );

  			if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {

  				let texture = null;

  				if ( type === 'texture' || type === 'storageTexture' ) {

  					texture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, node.access ? node.access : null );

  				} else if ( type === 'cubeTexture' ) {

  					texture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, node.access ? node.access : null );

  				} else if ( type === 'texture3D' ) {

  					texture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, node.access ? node.access : null );

  				}

  				texture.store = node.isStorageTextureNode === true;
  				texture.setVisibility( gpuShaderStageLib[ shaderStage ] );

  				if ( shaderStage === 'fragment' && this.isUnfilterable( node.value ) === false && texture.store === false ) {

  					const sampler = new NodeSampler( `${uniformNode.name}_sampler`, uniformNode.node, group );
  					sampler.setVisibility( gpuShaderStageLib[ shaderStage ] );

  					bindings.push( sampler, texture );

  					uniformGPU = [ sampler, texture ];

  				} else {

  					bindings.push( texture );

  					uniformGPU = [ texture ];

  				}

  			} else if ( type === 'buffer' || type === 'storageBuffer' ) {

  				const bufferClass = type === 'storageBuffer' ? NodeStorageBuffer : NodeUniformBuffer;
  				const buffer = new bufferClass( node, group );
  				buffer.setVisibility( gpuShaderStageLib[ shaderStage ] );

  				bindings.push( buffer );

  				uniformGPU = buffer;

  			} else {

  				const uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );

  				let uniformsGroup = uniformsStage[ groupName ];

  				if ( uniformsGroup === undefined ) {

  					uniformsGroup = new NodeUniformsGroup( groupName, group );
  					uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

  					uniformsStage[ groupName ] = uniformsGroup;

  					bindings.push( uniformsGroup );

  				}

  				uniformGPU = this.getNodeUniform( uniformNode, type );

  				uniformsGroup.addUniform( uniformGPU );

  			}

  			nodeData.uniformGPU = uniformGPU;

  		}

  		return uniformNode;

  	}

  	getBuiltin( name, property, type, shaderStage = this.shaderStage ) {

  		const map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );

  		if ( map.has( name ) === false ) {

  			map.set( name, {
  				name,
  				property,
  				type
  			} );

  		}

  		return property;

  	}

  	hasBuiltin( name, shaderStage = this.shaderStage ) {

  		return ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );

  	}

  	getVertexIndex() {

  		if ( this.shaderStage === 'vertex' ) {

  			return this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );

  		}

  		return 'vertexIndex';

  	}

  	buildFunctionCode( shaderNode ) {

  		const layout = shaderNode.layout;
  		const flowData = this.flowShaderNode( shaderNode );

  		const parameters = [];

  		for ( const input of layout.inputs ) {

  			parameters.push( input.name + ' : ' + this.getType( input.type ) );

  		}

  		//

  		let code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {
${ flowData.vars }
${ flowData.code }
`;

  		if ( flowData.result ) {

  			code += `\treturn ${ flowData.result };\n`;

  		}

  		code += '\n}\n';

  		//

  		return code;

  	}

  	getInstanceIndex() {

  		if ( this.shaderStage === 'vertex' ) {

  			return this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );

  		}

  		return 'instanceIndex';

  	}

  	getInvocationLocalIndex() {

  		return this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );

  	}

  	getSubgroupSize() {

  		this.enableSubGroups();

  		return this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );

  	}

  	getInvocationSubgroupIndex() {

  		this.enableSubGroups();

  		return this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );

  	}

  	getSubgroupIndex() {

  		this.enableSubGroups();

  		return this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );

  	}

  	getDrawIndex() {

  		return null;

  	}

  	getFrontFacing() {

  		return this.getBuiltin( 'front_facing', 'isFront', 'bool' );

  	}

  	getFragCoord() {

  		return this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';

  	}

  	getFragDepth() {

  		return 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );

  	}

  	isFlipY() {

  		return false;

  	}

  	enableDirective( name, shaderStage = this.shaderStage ) {

  		const stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );
  		stage.add( name );

  	}

  	getDirectives( shaderStage ) {

  		const snippets = [];
  		const directives = this.directives[ shaderStage ];

  		if ( directives !== undefined ) {

  			for ( const directive of directives ) {

  				snippets.push( `enable ${directive};` );

  			}

  		}

  		return snippets.join( '\n' );

  	}

  	enableSubGroups() {

  		this.enableDirective( 'subgroups' );

  	}

  	enableSubgroupsF16() {

  		this.enableDirective( 'subgroups-f16' );

  	}

  	enableClipDistances() {

  		this.enableDirective( 'clip_distances' );

  	}

  	enableShaderF16() {

  		this.enableDirective( 'f16' );

  	}

  	enableDualSourceBlending() {

  		this.enableDirective( 'dual_source_blending' );

  	}

  	getBuiltins( shaderStage ) {

  		const snippets = [];
  		const builtins = this.builtins[ shaderStage ];

  		if ( builtins !== undefined ) {

  			for ( const { name, property, type } of builtins.values() ) {

  				snippets.push( `@builtin( ${name} ) ${property} : ${type}` );

  			}

  		}

  		return snippets.join( ',\n\t' );

  	}

  	getScopedArray( name, scope, bufferType, bufferCount ) {

  		if ( this.scopedArrays.has( name ) === false ) {

  			this.scopedArrays.set( name, {
  				name,
  				scope,
  				bufferType,
  				bufferCount
  			} );

  		}

  		return name;

  	}

  	getScopedArrays( shaderStage ) {

  		if ( shaderStage !== 'compute' ) {

  			return;

  		}

  		const snippets = [];

  		for ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {

  			const type = this.getType( bufferType );

  			snippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );

  		}

  		return snippets.join( '\n' );

  	}

  	getAttributes( shaderStage ) {

  		const snippets = [];

  		if ( shaderStage === 'compute' ) {

  			this.getBuiltin( 'global_invocation_id', 'id', 'vec3<u32>', 'attribute' );
  			this.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );
  			this.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );
  			this.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );

  			if ( this.renderer.hasFeature( 'subgroups' ) ) {

  				this.enableDirective( 'subgroups', shaderStage );
  				this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );

  			}

  		}

  		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

  			const builtins = this.getBuiltins( 'attribute' );

  			if ( builtins ) snippets.push( builtins );

  			const attributes = this.getAttributesArray();

  			for ( let index = 0, length = attributes.length; index < length; index ++ ) {

  				const attribute = attributes[ index ];
  				const name = attribute.name;
  				const type = this.getType( attribute.type );

  				snippets.push( `@location( ${index} ) ${ name } : ${ type }` );

  			}

  		}

  		return snippets.join( ',\n\t' );

  	}

  	getStructMembers( struct ) {

  		const snippets = [];
  		const members = struct.getMemberTypes();

  		for ( let i = 0; i < members.length; i ++ ) {

  			const member = members[ i ];
  			snippets.push( `\t@location( ${i} ) m${i} : ${ member }<f32>` );

  		}

  		const builtins = this.getBuiltins( 'output' );

  		if ( builtins ) snippets.push( '\t' + builtins );

  		return snippets.join( ',\n' );

  	}

  	getStructs( shaderStage ) {

  		const snippets = [];
  		const structs = this.structs[ shaderStage ];

  		for ( let index = 0, length = structs.length; index < length; index ++ ) {

  			const struct = structs[ index ];
  			const name = struct.name;

  			let snippet = `\struct ${ name } {\n`;
  			snippet += this.getStructMembers( struct );
  			snippet += '\n}';


  			snippets.push( snippet );

  			snippets.push( `\nvar<private> output : ${ name };\n\n` );

  		}

  		return snippets.join( '\n\n' );

  	}

  	getVar( type, name ) {

  		return `var ${ name } : ${ this.getType( type ) }`;

  	}

  	getVars( shaderStage ) {

  		const snippets = [];
  		const vars = this.vars[ shaderStage ];

  		if ( vars !== undefined ) {

  			for ( const variable of vars ) {

  				snippets.push( `\t${ this.getVar( variable.type, variable.name ) };` );

  			}

  		}

  		return `\n${ snippets.join( '\n' ) }\n`;

  	}

  	getVaryings( shaderStage ) {

  		const snippets = [];

  		if ( shaderStage === 'vertex' ) {

  			this.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );

  		}

  		if ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {

  			const varyings = this.varyings;
  			const vars = this.vars[ shaderStage ];

  			for ( let index = 0; index < varyings.length; index ++ ) {

  				const varying = varyings[ index ];

  				if ( varying.needsInterpolation ) {

  					let attributesSnippet = `@location( ${index} )`;

  					if ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {

  						attributesSnippet += ' @interpolate( flat )';


  					}

  					snippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );

  				} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {

  					vars.push( varying );

  				}

  			}

  		}

  		const builtins = this.getBuiltins( shaderStage );

  		if ( builtins ) snippets.push( builtins );

  		const code = snippets.join( ',\n\t' );

  		return shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\t' + code ) : code;

  	}

  	getUniforms( shaderStage ) {

  		const uniforms = this.uniforms[ shaderStage ];

  		const bindingSnippets = [];
  		const bufferSnippets = [];
  		const structSnippets = [];
  		const uniformGroups = {};

  		for ( const uniform of uniforms ) {

  			const groupName = uniform.groupNode.name;
  			const uniformIndexes = this.bindingsIndexes[ groupName ];

  			if ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {

  				const texture = uniform.node.value;

  				if ( shaderStage === 'fragment' && this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {

  					if ( texture.isDepthTexture === true && texture.compareFunction !== null ) {

  						bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );

  					} else {

  						bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );

  					}

  				}

  				let textureType;

  				let multisampled = '';

  				if ( texture.isMultisampleRenderTargetTexture === true ) {

  					multisampled = '_multisampled';

  				}

  				if ( texture.isCubeTexture === true ) {

  					textureType = 'texture_cube<f32>';

  				} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

  					textureType = 'texture_2d_array<f32>';

  				} else if ( texture.isDepthTexture === true ) {

  					textureType = `texture_depth${multisampled}_2d`;

  				} else if ( texture.isVideoTexture === true ) {

  					textureType = 'texture_external';

  				} else if ( texture.isData3DTexture === true ) {

  					textureType = 'texture_3d<f32>';

  				} else if ( uniform.node.isStorageTextureNode === true ) {

  					const format = getFormat( texture );
  					const access = this.getStorageAccess( uniform.node );

  					textureType = `texture_storage_2d<${ format }, ${ access }>`;

  				} else {

  					const componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );

  					textureType = `texture${multisampled}_2d<${ componentPrefix }32>`;

  				}

  				bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );

  			} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' ) {

  				const bufferNode = uniform.node;
  				const bufferType = this.getType( bufferNode.bufferType );
  				const bufferCount = bufferNode.bufferCount;

  				const bufferCountSnippet = bufferCount > 0 ? ', ' + bufferCount : '';
  				const bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;
  				const bufferSnippet = `\t${ uniform.name } : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >\n`;
  				const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode ) }` : 'uniform';

  				bufferSnippets.push( this._getWGSLStructBinding( 'NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );

  			} else {

  				const vectorType = this.getType( this.getVectorType( uniform.type ) );
  				const groupName = uniform.groupNode.name;

  				const group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {
  					index: uniformIndexes.binding ++,
  					id: uniformIndexes.group,
  					snippets: []
  				} );

  				group.snippets.push( `\t${ uniform.name } : ${ vectorType }` );

  			}

  		}

  		for ( const name in uniformGroups ) {

  			const group = uniformGroups[ name ];

  			structSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\n' ), 'uniform', group.index, group.id ) );

  		}

  		let code = bindingSnippets.join( '\n' );
  		code += bufferSnippets.join( '\n' );
  		code += structSnippets.join( '\n' );

  		return code;

  	}

  	buildCode() {

  		const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };

  		this.sortBindingGroups();

  		for ( const shaderStage in shadersData ) {

  			const stageData = shadersData[ shaderStage ];
  			stageData.uniforms = this.getUniforms( shaderStage );
  			stageData.attributes = this.getAttributes( shaderStage );
  			stageData.varyings = this.getVaryings( shaderStage );
  			stageData.structs = this.getStructs( shaderStage );
  			stageData.vars = this.getVars( shaderStage );
  			stageData.codes = this.getCodes( shaderStage );
  			stageData.directives = this.getDirectives( shaderStage );
  			stageData.scopedArrays = this.getScopedArrays( shaderStage );

  			//

  			let flow = '// code\n\n';
  			flow += this.flowCode[ shaderStage ];

  			const flowNodes = this.flowNodes[ shaderStage ];
  			const mainNode = flowNodes[ flowNodes.length - 1 ];

  			const outputNode = mainNode.outputNode;
  			const isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );

  			for ( const node of flowNodes ) {

  				const flowSlotData = this.getFlowData( node/*, shaderStage*/ );
  				const slotName = node.name;

  				if ( slotName ) {

  					if ( flow.length > 0 ) flow += '\n';

  					flow += `\t// flow -> ${ slotName }\n\t`;

  				}

  				flow += `${ flowSlotData.code }\n\t`;

  				if ( node === mainNode && shaderStage !== 'compute' ) {

  					flow += '// result\n\n\t';

  					if ( shaderStage === 'vertex' ) {

  						flow += `varyings.Vertex = ${ flowSlotData.result };`;

  					} else if ( shaderStage === 'fragment' ) {

  						if ( isOutputStruct ) {

  							stageData.returnType = outputNode.nodeType;

  							flow += `return ${ flowSlotData.result };`;

  						} else {

  							let structSnippet = '\t@location(0) color: vec4<f32>';

  							const builtins = this.getBuiltins( 'output' );

  							if ( builtins ) structSnippet += ',\n\t' + builtins;

  							stageData.returnType = 'OutputStruct';
  							stageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );
  							stageData.structs += '\nvar<private> output : OutputStruct;\n\n';

  							flow += `output.color = ${ flowSlotData.result };\n\n\treturn output;`;

  						}

  					}

  				}

  			}

  			stageData.flow = flow;


  		}

  		if ( this.material !== null ) {

  			this.vertexShader = this._getWGSLVertexCode( shadersData.vertex );
  			this.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );

  		} else {

  			this.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );

  		}

  	}

  	getMethod( method, output = null ) {

  		let wgslMethod;

  		if ( output !== null ) {

  			wgslMethod = this._getWGSLMethod( method + '_' + output );

  		}

  		if ( wgslMethod === undefined ) {

  			wgslMethod = this._getWGSLMethod( method );

  		}

  		return wgslMethod || method;

  	}

  	getType( type ) {

  		return wgslTypeLib[ type ] || type;

  	}

  	isAvailable( name ) {

  		let result = supports[ name ];

  		if ( result === undefined ) {

  			if ( name === 'float32Filterable' ) {

  				result = this.renderer.hasFeature( 'float32-filterable' );

  			}

  			supports[ name ] = result;

  		}

  		return result;

  	}

  	_getWGSLMethod( method ) {

  		if ( wgslPolyfill[ method ] !== undefined ) {

  			this._include( method );

  		}

  		return wgslMethods[ method ];

  	}

  	_include( name ) {

  		const codeNode = wgslPolyfill[ name ];
  		codeNode.build( this );

  		if ( this.currentFunctionNode !== null ) {

  			this.currentFunctionNode.includes.push( codeNode );

  		}

  		return codeNode;

  	}

  	_getWGSLVertexCode( shaderData ) {

  		return `${ this.getSignature() }
// directives
${shaderData.directives}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;

  	}

  	_getWGSLFragmentCode( shaderData ) {

  		return `${ this.getSignature() }
// global
${ diagnostics }

// uniforms
${shaderData.uniforms}

// structs
${shaderData.structs}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

  	}

  	_getWGSLComputeCode( shaderData, workgroupSize ) {

  		return `${ this.getSignature() }
// directives
${shaderData.directives}

// system
var<private> instanceIndex : u32;

// locals
${shaderData.scopedArrays}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSize} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = id.x + id.y * numWorkgroups.x * u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

  	}

  	_getWGSLStruct( name, vars ) {

  		return `
struct ${name} {
${vars}
};`;

  	}

  	_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {

  		const structName = name + 'Struct';
  		const structSnippet = this._getWGSLStruct( structName, vars );

  		return `${structSnippet}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;

  	}

  }

  class WebGPUUtils {

  	constructor( backend ) {

  		this.backend = backend;

  	}

  	getCurrentDepthStencilFormat( renderContext ) {

  		let format;

  		if ( renderContext.depthTexture !== null ) {

  			format = this.getTextureFormatGPU( renderContext.depthTexture );

  		} else if ( renderContext.depth && renderContext.stencil ) {

  			format = GPUTextureFormat.Depth24PlusStencil8;

  		} else if ( renderContext.depth ) {

  			format = GPUTextureFormat.Depth24Plus;

  		}

  		return format;

  	}

  	getTextureFormatGPU( texture ) {

  		return this.backend.get( texture ).format;

  	}

  	getCurrentColorFormat( renderContext ) {

  		let format;

  		if ( renderContext.textures !== null ) {

  			format = this.getTextureFormatGPU( renderContext.textures[ 0 ] );


  		} else {

  			format = this.getPreferredCanvasFormat(); // default context format

  		}

  		return format;

  	}

  	getCurrentColorSpace( renderContext ) {

  		if ( renderContext.textures !== null ) {

  			return renderContext.textures[ 0 ].colorSpace;

  		}

  		return this.backend.renderer.outputColorSpace;

  	}

  	getPrimitiveTopology( object, material ) {

  		if ( object.isPoints ) return GPUPrimitiveTopology.PointList;
  		else if ( object.isLineSegments || ( object.isMesh && material.wireframe === true ) ) return GPUPrimitiveTopology.LineList;
  		else if ( object.isLine ) return GPUPrimitiveTopology.LineStrip;
  		else if ( object.isMesh ) return GPUPrimitiveTopology.TriangleList;

  	}

  	getSampleCount( sampleCount ) {

  		let count = 1;

  		if ( sampleCount > 1 ) {

  			// WebGPU only supports power-of-two sample counts and 2 is not a valid value
  			count = Math.pow( 2, Math.floor( Math.log2( sampleCount ) ) );

  			if ( count === 2 ) {

  				count = 4;

  			}

  		}

  		return count;

  	}

  	getSampleCountRenderContext( renderContext ) {

  		if ( renderContext.textures !== null ) {

  			return this.getSampleCount( renderContext.sampleCount );

  		}

  		return this.getSampleCount( this.backend.renderer.samples );

  	}

  	getPreferredCanvasFormat() {

  		// TODO: Remove this check when Quest 34.5 is out
  		// https://github.com/mrdoob/three.js/pull/29221/files#r1731833949

  		if ( navigator.userAgent.includes( 'Quest' ) ) {

  			return GPUTextureFormat.BGRA8Unorm;

  		} else {

  			return navigator.gpu.getPreferredCanvasFormat();

  		}

  	}

  }

  const typedArraysToVertexFormatPrefix = new Map( [
  	[ Int8Array, [ 'sint8', 'snorm8' ]],
  	[ Uint8Array, [ 'uint8', 'unorm8' ]],
  	[ Int16Array, [ 'sint16', 'snorm16' ]],
  	[ Uint16Array, [ 'uint16', 'unorm16' ]],
  	[ Int32Array, [ 'sint32', 'snorm32' ]],
  	[ Uint32Array, [ 'uint32', 'unorm32' ]],
  	[ Float32Array, [ 'float32', ]],
  ] );

  const typedAttributeToVertexFormatPrefix = new Map( [
  	[ Float16BufferAttribute, [ 'float16', ]],
  ] );

  const typeArraysToVertexFormatPrefixForItemSize1 = new Map( [
  	[ Int32Array, 'sint32' ],
  	[ Int16Array, 'sint32' ], // patch for INT16
  	[ Uint32Array, 'uint32' ],
  	[ Uint16Array, 'uint32' ], // patch for UINT16
  	[ Float32Array, 'float32' ]
  ] );

  class WebGPUAttributeUtils {

  	constructor( backend ) {

  		this.backend = backend;

  	}

  	createAttribute( attribute, usage ) {

  		const bufferAttribute = this._getBufferAttribute( attribute );

  		const backend = this.backend;
  		const bufferData = backend.get( bufferAttribute );

  		let buffer = bufferData.buffer;

  		if ( buffer === undefined ) {

  			const device = backend.device;

  			let array = bufferAttribute.array;

  			// patch for INT16 and UINT16
  			if ( attribute.normalized === false && ( array.constructor === Int16Array || array.constructor === Uint16Array ) ) {

  				const tempArray = new Uint32Array( array.length );
  				for ( let i = 0; i < array.length; i ++ ) {

  					tempArray[ i ] = array[ i ];

  				}

  				array = tempArray;

  			}

  			bufferAttribute.array = array;

  			if ( ( bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute ) && bufferAttribute.itemSize === 3 ) {

  				array = new array.constructor( bufferAttribute.count * 4 );

  				for ( let i = 0; i < bufferAttribute.count; i ++ ) {

  					array.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );

  				}

  				// Update BufferAttribute
  				bufferAttribute.itemSize = 4;
  				bufferAttribute.array = array;

  			}

  			const size = array.byteLength + ( ( 4 - ( array.byteLength % 4 ) ) % 4 ); // ensure 4 byte alignment, see #20441

  			buffer = device.createBuffer( {
  				label: bufferAttribute.name,
  				size: size,
  				usage: usage,
  				mappedAtCreation: true
  			} );

  			new array.constructor( buffer.getMappedRange() ).set( array );

  			buffer.unmap();

  			bufferData.buffer = buffer;

  		}

  	}

  	updateAttribute( attribute ) {

  		const bufferAttribute = this._getBufferAttribute( attribute );

  		const backend = this.backend;
  		const device = backend.device;

  		const buffer = backend.get( bufferAttribute ).buffer;

  		const array = bufferAttribute.array;
  		const updateRanges = bufferAttribute.updateRanges;

  		if ( updateRanges.length === 0 ) {

  			// Not using update ranges

  			device.queue.writeBuffer(
  				buffer,
  				0,
  				array,
  				0
  			);

  		} else {

  			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

  				const range = updateRanges[ i ];
  				device.queue.writeBuffer(
  					buffer,
  					0,
  					array,
  					range.start * array.BYTES_PER_ELEMENT,
  					range.count * array.BYTES_PER_ELEMENT
  				);

  			}

  			bufferAttribute.clearUpdateRanges();

  		}

  	}

  	createShaderVertexBuffers( renderObject ) {

  		const attributes = renderObject.getAttributes();
  		const vertexBuffers = new Map();

  		for ( let slot = 0; slot < attributes.length; slot ++ ) {

  			const geometryAttribute = attributes[ slot ];
  			const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
  			const bufferAttribute = this._getBufferAttribute( geometryAttribute );

  			let vertexBufferLayout = vertexBuffers.get( bufferAttribute );

  			if ( vertexBufferLayout === undefined ) {

  				let arrayStride, stepMode;

  				if ( geometryAttribute.isInterleavedBufferAttribute === true ) {

  					arrayStride = geometryAttribute.data.stride * bytesPerElement;
  					stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

  				} else {

  					arrayStride = geometryAttribute.itemSize * bytesPerElement;
  					stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

  				}

  				// patch for INT16 and UINT16
  				if ( geometryAttribute.normalized === false && ( geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array ) ) {

  					arrayStride = 4;

  				}

  				vertexBufferLayout = {
  					arrayStride,
  					attributes: [],
  					stepMode
  				};

  				vertexBuffers.set( bufferAttribute, vertexBufferLayout );

  			}

  			const format = this._getVertexFormat( geometryAttribute );
  			const offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;

  			vertexBufferLayout.attributes.push( {
  				shaderLocation: slot,
  				offset,
  				format
  			} );

  		}

  		return Array.from( vertexBuffers.values() );

  	}

  	destroyAttribute( attribute ) {

  		const backend = this.backend;
  		const data = backend.get( this._getBufferAttribute( attribute ) );

  		data.buffer.destroy();

  		backend.delete( attribute );

  	}

  	async getArrayBufferAsync( attribute ) {

  		const backend = this.backend;
  		const device = backend.device;

  		const data = backend.get( this._getBufferAttribute( attribute ) );

  		const bufferGPU = data.buffer;
  		const size = bufferGPU.size;

  		const readBufferGPU = device.createBuffer( {
  			label: attribute.name,
  			size,
  			usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  		} );


  		const cmdEncoder = device.createCommandEncoder( {} );

  		cmdEncoder.copyBufferToBuffer(
  			bufferGPU,
  			0,
  			readBufferGPU,
  			0,
  			size
  		);

  		readBufferGPU.unmap();

  		const gpuCommands = cmdEncoder.finish();
  		device.queue.submit( [ gpuCommands ] );

  		await readBufferGPU.mapAsync( GPUMapMode.READ );

  		const arrayBuffer = readBufferGPU.getMappedRange();

  		return arrayBuffer;

  	}

  	_getVertexFormat( geometryAttribute ) {

  		const { itemSize, normalized } = geometryAttribute;
  		const ArrayType = geometryAttribute.array.constructor;
  		const AttributeType = geometryAttribute.constructor;

  		let format;

  		if ( itemSize == 1 ) {

  			format = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );

  		} else {

  			const prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );
  			const prefix = prefixOptions[ normalized ? 1 : 0 ];

  			if ( prefix ) {

  				const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
  				const paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;
  				const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;

  				if ( paddedItemSize % 1 ) {

  					throw new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );

  				}

  				format = `${prefix}x${paddedItemSize}`;

  			}

  		}

  		if ( ! format ) {

  			console.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );

  		}

  		return format;

  	}

  	_getBufferAttribute( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		return attribute;

  	}

  }

  class WebGPUBindingUtils {

  	constructor( backend ) {

  		this.backend = backend;
  		this.bindGroupLayoutCache = new WeakMap();

  	}

  	createBindingsLayout( bindGroup ) {

  		const backend = this.backend;
  		const device = backend.device;

  		const entries = [];

  		let index = 0;

  		for ( const binding of bindGroup.bindings ) {

  			const bindingGPU = {
  				binding: index ++,
  				visibility: binding.visibility
  			};

  			if ( binding.isUniformBuffer || binding.isStorageBuffer ) {

  				const buffer = {}; // GPUBufferBindingLayout

  				if ( binding.isStorageBuffer ) {

  					buffer.type = binding.access;

  				}

  				bindingGPU.buffer = buffer;

  			} else if ( binding.isSampler ) {

  				const sampler = {}; // GPUSamplerBindingLayout

  				if ( binding.texture.isDepthTexture ) {

  					if ( binding.texture.compareFunction !== null ) {

  						sampler.type = 'comparison';

  					}

  				}

  				bindingGPU.sampler = sampler;

  			} else if ( binding.isSampledTexture && binding.texture.isVideoTexture ) {

  				bindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout

  			} else if ( binding.isSampledTexture && binding.store ) {

  				const format = this.backend.get( binding.texture ).texture.format;
  				const access = binding.access;

  				bindingGPU.storageTexture = { format, access }; // GPUStorageTextureBindingLayout

  			} else if ( binding.isSampledTexture ) {

  				const texture = {}; // GPUTextureBindingLayout

  				if ( binding.texture.isMultisampleRenderTargetTexture === true ) {

  					texture.multisampled = true;

  				}

  				if ( binding.texture.isDepthTexture ) {

  					texture.sampleType = GPUTextureSampleType.Depth;

  				} else if ( binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture ) {

  					const type = binding.texture.type;

  					if ( type === IntType ) {

  						texture.sampleType = GPUTextureSampleType.SInt;

  					} else if ( type === UnsignedIntType ) {

  						texture.sampleType = GPUTextureSampleType.UInt;

  					} else if ( type === FloatType ) {

  						if ( this.backend.hasFeature( 'float32-filterable' ) ) {

  							texture.sampleType = GPUTextureSampleType.Float;

  						} else {

  							texture.sampleType = GPUTextureSampleType.UnfilterableFloat;

  						}

  					}

  				}

  				if ( binding.isSampledCubeTexture ) {

  					texture.viewDimension = GPUTextureViewDimension.Cube;

  				} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {

  					texture.viewDimension = GPUTextureViewDimension.TwoDArray;

  				} else if ( binding.isSampledTexture3D ) {

  					texture.viewDimension = GPUTextureViewDimension.ThreeD;

  				}

  				bindingGPU.texture = texture;

  			} else {

  				console.error( `WebGPUBindingUtils: Unsupported binding "${ binding }".` );

  			}

  			entries.push( bindingGPU );

  		}

  		return device.createBindGroupLayout( { entries } );

  	}

  	createBindings( bindGroup ) {

  		const { backend, bindGroupLayoutCache } = this;
  		const bindingsData = backend.get( bindGroup );

  		// setup (static) binding layout and (dynamic) binding group

  		let bindLayoutGPU = bindGroupLayoutCache.get( bindGroup.bindingsReference );

  		if ( bindLayoutGPU === undefined ) {

  			bindLayoutGPU = this.createBindingsLayout( bindGroup );
  			bindGroupLayoutCache.set( bindGroup.bindingsReference, bindLayoutGPU );

  		}

  		const bindGroupGPU = this.createBindGroup( bindGroup, bindLayoutGPU );

  		bindingsData.layout = bindLayoutGPU;
  		bindingsData.group = bindGroupGPU;

  	}

  	updateBinding( binding ) {

  		const backend = this.backend;
  		const device = backend.device;

  		const buffer = binding.buffer;
  		const bufferGPU = backend.get( binding ).buffer;

  		device.queue.writeBuffer( bufferGPU, 0, buffer, 0 );

  	}

  	createBindGroup( bindGroup, layoutGPU ) {

  		const backend = this.backend;
  		const device = backend.device;

  		let bindingPoint = 0;
  		const entriesGPU = [];

  		for ( const binding of bindGroup.bindings ) {

  			if ( binding.isUniformBuffer ) {

  				const bindingData = backend.get( binding );

  				if ( bindingData.buffer === undefined ) {

  					const byteLength = binding.byteLength;

  					const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;

  					const bufferGPU = device.createBuffer( {
  						label: 'bindingBuffer_' + binding.name,
  						size: byteLength,
  						usage: usage
  					} );

  					bindingData.buffer = bufferGPU;

  				}

  				entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

  			} else if ( binding.isStorageBuffer ) {

  				const bindingData = backend.get( binding );

  				if ( bindingData.buffer === undefined ) {

  					const attribute = binding.attribute;
  					//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;

  					//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer

  					bindingData.buffer = backend.get( attribute ).buffer;

  				}

  				entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

  			} else if ( binding.isSampler ) {

  				const textureGPU = backend.get( binding.texture );

  				entriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );

  			} else if ( binding.isSampledTexture ) {

  				const textureData = backend.get( binding.texture );

  				let resourceGPU;

  				if ( textureData.externalTexture !== undefined ) {

  					resourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );

  				} else {

  					const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;
  					const propertyName = `view-${ textureData.texture.width }-${ textureData.texture.height }-${ mipLevelCount }`;

  					resourceGPU = textureData[ propertyName ];

  					if ( resourceGPU === undefined ) {

  						const aspectGPU = GPUTextureAspect.All;

  						let dimensionViewGPU;

  						if ( binding.isSampledCubeTexture ) {

  							dimensionViewGPU = GPUTextureViewDimension.Cube;

  						} else if ( binding.isSampledTexture3D ) {

  							dimensionViewGPU = GPUTextureViewDimension.ThreeD;

  						} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {

  							dimensionViewGPU = GPUTextureViewDimension.TwoDArray;

  						} else {

  							dimensionViewGPU = GPUTextureViewDimension.TwoD;

  						}

  						resourceGPU = textureData[ propertyName ] = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount } );

  					}

  				}

  				entriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );

  			}

  			bindingPoint ++;

  		}

  		return device.createBindGroup( {
  			label: 'bindGroup_' + bindGroup.name,
  			layout: layoutGPU,
  			entries: entriesGPU
  		} );

  	}

  }

  class WebGPUPipelineUtils {

  	constructor( backend ) {

  		this.backend = backend;

  	}

  	_getSampleCount( renderObjectContext ) {

  		return this.backend.utils.getSampleCountRenderContext( renderObjectContext );

  	}

  	createRenderPipeline( renderObject, promises ) {

  		const { object, material, geometry, pipeline } = renderObject;
  		const { vertexProgram, fragmentProgram } = pipeline;

  		const backend = this.backend;
  		const device = backend.device;
  		const utils = backend.utils;

  		const pipelineData = backend.get( pipeline );

  		// bind group layouts

  		const bindGroupLayouts = [];

  		for ( const bindGroup of renderObject.getBindings() ) {

  			const bindingsData = backend.get( bindGroup );

  			bindGroupLayouts.push( bindingsData.layout );

  		}

  		// vertex buffers

  		const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers( renderObject );

  		// blending

  		let blending;

  		if ( material.transparent === true && material.blending !== NoBlending ) {

  			blending = this._getBlending( material );

  		}

  		// stencil

  		let stencilFront = {};

  		if ( material.stencilWrite === true ) {

  			stencilFront = {
  				compare: this._getStencilCompare( material ),
  				failOp: this._getStencilOperation( material.stencilFail ),
  				depthFailOp: this._getStencilOperation( material.stencilZFail ),
  				passOp: this._getStencilOperation( material.stencilZPass )
  			};

  		}

  		const colorWriteMask = this._getColorWriteMask( material );

  		const targets = [];

  		if ( renderObject.context.textures !== null ) {

  			const textures = renderObject.context.textures;

  			for ( let i = 0; i < textures.length; i ++ ) {

  				const colorFormat = utils.getTextureFormatGPU( textures[ i ] );

  				targets.push( {
  					format: colorFormat,
  					blend: blending,
  					writeMask: colorWriteMask
  				} );

  			}

  		} else {

  			const colorFormat = utils.getCurrentColorFormat( renderObject.context );

  			targets.push( {
  				format: colorFormat,
  				blend: blending,
  				writeMask: colorWriteMask
  			} );

  		}

  		const vertexModule = backend.get( vertexProgram ).module;
  		const fragmentModule = backend.get( fragmentProgram ).module;

  		const primitiveState = this._getPrimitiveState( object, geometry, material );
  		const depthCompare = this._getDepthCompare( material );
  		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );

  		const sampleCount = this._getSampleCount( renderObject.context );

  		const pipelineDescriptor = {
  			label: `renderPipeline_${ material.name || material.type }_${ material.id }`,
  			vertex: Object.assign( {}, vertexModule, { buffers: vertexBuffers } ),
  			fragment: Object.assign( {}, fragmentModule, { targets } ),
  			primitive: primitiveState,
  			depthStencil: {
  				format: depthStencilFormat,
  				depthWriteEnabled: material.depthWrite,
  				depthCompare: depthCompare,
  				stencilFront: stencilFront,
  				stencilBack: {}, // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)
  				stencilReadMask: material.stencilFuncMask,
  				stencilWriteMask: material.stencilWriteMask
  			},
  			multisample: {
  				count: sampleCount,
  				alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1
  			},
  			layout: device.createPipelineLayout( {
  				bindGroupLayouts
  			} )
  		};

  		if ( promises === null ) {

  			pipelineData.pipeline = device.createRenderPipeline( pipelineDescriptor );

  		} else {

  			const p = new Promise( ( resolve /*, reject*/ ) => {

  				device.createRenderPipelineAsync( pipelineDescriptor ).then( pipeline => {

  					pipelineData.pipeline = pipeline;
  					resolve();

  				} );

  			} );

  			promises.push( p );

  		}

  	}

  	createBundleEncoder( renderContext ) {

  		const backend = this.backend;
  		const { utils, device } = backend;

  		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderContext );
  		const colorFormat = utils.getCurrentColorFormat( renderContext );
  		const sampleCount = this._getSampleCount( renderContext );

  		const descriptor = {
  			label: 'renderBundleEncoder',
  			colorFormats: [ colorFormat ],
  			depthStencilFormat,
  			sampleCount
  		};

  		return device.createRenderBundleEncoder( descriptor );

  	}

  	createComputePipeline( pipeline, bindings ) {

  		const backend = this.backend;
  		const device = backend.device;

  		const computeProgram = backend.get( pipeline.computeProgram ).module;

  		const pipelineGPU = backend.get( pipeline );

  		// bind group layouts

  		const bindGroupLayouts = [];

  		for ( const bindingsGroup of bindings ) {

  			const bindingsData = backend.get( bindingsGroup );

  			bindGroupLayouts.push( bindingsData.layout );

  		}

  		pipelineGPU.pipeline = device.createComputePipeline( {
  			compute: computeProgram,
  			layout: device.createPipelineLayout( {
  				bindGroupLayouts
  			} )
  		} );

  	}

  	_getBlending( material ) {

  		let color, alpha;

  		const blending = material.blending;
  		const blendSrc = material.blendSrc;
  		const blendDst = material.blendDst;
  		const blendEquation = material.blendEquation;


  		if ( blending === CustomBlending ) {

  			const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
  			const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
  			const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;

  			color = {
  				srcFactor: this._getBlendFactor( blendSrc ),
  				dstFactor: this._getBlendFactor( blendDst ),
  				operation: this._getBlendOperation( blendEquation )
  			};

  			alpha = {
  				srcFactor: this._getBlendFactor( blendSrcAlpha ),
  				dstFactor: this._getBlendFactor( blendDstAlpha ),
  				operation: this._getBlendOperation( blendEquationAlpha )
  			};

  		} else {

  			const premultipliedAlpha = material.premultipliedAlpha;

  			const setBlend = ( srcRGB, dstRGB, srcAlpha, dstAlpha ) => {

  				color = {
  					srcFactor: srcRGB,
  					dstFactor: dstRGB,
  					operation: GPUBlendOperation.Add
  				};

  				alpha = {
  					srcFactor: srcAlpha,
  					dstFactor: dstAlpha,
  					operation: GPUBlendOperation.Add
  				};

  			};

  			if ( premultipliedAlpha ) {

  				switch ( blending ) {

  					case NormalBlending:
  						setBlend( GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
  						break;

  					case AdditiveBlending:
  						setBlend( GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );
  						break;

  					case SubtractiveBlending:
  						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );
  						break;

  					case MultiplyBlending:
  						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha );
  						break;

  				}

  			} else {

  				switch ( blending ) {

  					case NormalBlending:
  						setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
  						break;

  					case AdditiveBlending:
  						setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One );
  						break;

  					case SubtractiveBlending:
  						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );
  						break;

  					case MultiplyBlending:
  						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src );
  						break;

  				}

  			}

  		}

  		if ( color !== undefined && alpha !== undefined ) {

  			return { color, alpha };

  		} else {

  			console.error( 'THREE.WebGPURenderer: Invalid blending: ', blending );

  		}

  	}

  	_getBlendFactor( blend ) {

  		let blendFactor;

  		switch ( blend ) {

  			case ZeroFactor:
  				blendFactor = GPUBlendFactor.Zero;
  				break;

  			case OneFactor:
  				blendFactor = GPUBlendFactor.One;
  				break;

  			case SrcColorFactor:
  				blendFactor = GPUBlendFactor.Src;
  				break;

  			case OneMinusSrcColorFactor:
  				blendFactor = GPUBlendFactor.OneMinusSrc;
  				break;

  			case SrcAlphaFactor:
  				blendFactor = GPUBlendFactor.SrcAlpha;
  				break;

  			case OneMinusSrcAlphaFactor:
  				blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
  				break;

  			case DstColorFactor:
  				blendFactor = GPUBlendFactor.Dst;
  				break;

  			case OneMinusDstColorFactor:
  				blendFactor = GPUBlendFactor.OneMinusDstColor;
  				break;

  			case DstAlphaFactor:
  				blendFactor = GPUBlendFactor.DstAlpha;
  				break;

  			case OneMinusDstAlphaFactor:
  				blendFactor = GPUBlendFactor.OneMinusDstAlpha;
  				break;

  			case SrcAlphaSaturateFactor:
  				blendFactor = GPUBlendFactor.SrcAlphaSaturated;
  				break;

  			case BlendColorFactor:
  				blendFactor = GPUBlendFactor.Constant;
  				break;

  			case OneMinusBlendColorFactor:
  				blendFactor = GPUBlendFactor.OneMinusConstant;
  				break;

  			default:
  				console.error( 'THREE.WebGPURenderer: Blend factor not supported.', blend );

  		}

  		return blendFactor;

  	}

  	_getStencilCompare( material ) {

  		let stencilCompare;

  		const stencilFunc = material.stencilFunc;

  		switch ( stencilFunc ) {

  			case NeverStencilFunc:
  				stencilCompare = GPUCompareFunction.Never;
  				break;

  			case AlwaysStencilFunc:
  				stencilCompare = GPUCompareFunction.Always;
  				break;

  			case LessStencilFunc:
  				stencilCompare = GPUCompareFunction.Less;
  				break;

  			case LessEqualStencilFunc:
  				stencilCompare = GPUCompareFunction.LessEqual;
  				break;

  			case EqualStencilFunc:
  				stencilCompare = GPUCompareFunction.Equal;
  				break;

  			case GreaterEqualStencilFunc:
  				stencilCompare = GPUCompareFunction.GreaterEqual;
  				break;

  			case GreaterStencilFunc:
  				stencilCompare = GPUCompareFunction.Greater;
  				break;

  			case NotEqualStencilFunc:
  				stencilCompare = GPUCompareFunction.NotEqual;
  				break;

  			default:
  				console.error( 'THREE.WebGPURenderer: Invalid stencil function.', stencilFunc );

  		}

  		return stencilCompare;

  	}

  	_getStencilOperation( op ) {

  		let stencilOperation;

  		switch ( op ) {

  			case KeepStencilOp:
  				stencilOperation = GPUStencilOperation.Keep;
  				break;

  			case ZeroStencilOp:
  				stencilOperation = GPUStencilOperation.Zero;
  				break;

  			case ReplaceStencilOp:
  				stencilOperation = GPUStencilOperation.Replace;
  				break;

  			case InvertStencilOp:
  				stencilOperation = GPUStencilOperation.Invert;
  				break;

  			case IncrementStencilOp:
  				stencilOperation = GPUStencilOperation.IncrementClamp;
  				break;

  			case DecrementStencilOp:
  				stencilOperation = GPUStencilOperation.DecrementClamp;
  				break;

  			case IncrementWrapStencilOp:
  				stencilOperation = GPUStencilOperation.IncrementWrap;
  				break;

  			case DecrementWrapStencilOp:
  				stencilOperation = GPUStencilOperation.DecrementWrap;
  				break;

  			default:
  				console.error( 'THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation );

  		}

  		return stencilOperation;

  	}

  	_getBlendOperation( blendEquation ) {

  		let blendOperation;

  		switch ( blendEquation ) {

  			case AddEquation:
  				blendOperation = GPUBlendOperation.Add;
  				break;

  			case SubtractEquation:
  				blendOperation = GPUBlendOperation.Subtract;
  				break;

  			case ReverseSubtractEquation:
  				blendOperation = GPUBlendOperation.ReverseSubtract;
  				break;

  			case MinEquation:
  				blendOperation = GPUBlendOperation.Min;
  				break;

  			case MaxEquation:
  				blendOperation = GPUBlendOperation.Max;
  				break;

  			default:
  				console.error( 'THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation );

  		}

  		return blendOperation;

  	}

  	_getPrimitiveState( object, geometry, material ) {

  		const descriptor = {};
  		const utils = this.backend.utils;

  		descriptor.topology = utils.getPrimitiveTopology( object, material );

  		if ( geometry.index !== null && object.isLine === true && object.isLineSegments !== true ) {

  			descriptor.stripIndexFormat = ( geometry.index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;

  		}

  		switch ( material.side ) {

  			case FrontSide:
  				descriptor.frontFace = GPUFrontFace.CCW;
  				descriptor.cullMode = GPUCullMode.Back;
  				break;

  			case BackSide:
  				descriptor.frontFace = GPUFrontFace.CCW;
  				descriptor.cullMode = GPUCullMode.Front;
  				break;

  			case DoubleSide:
  				descriptor.frontFace = GPUFrontFace.CCW;
  				descriptor.cullMode = GPUCullMode.None;
  				break;

  			default:
  				console.error( 'THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side );
  				break;

  		}

  		return descriptor;

  	}

  	_getColorWriteMask( material ) {

  		return ( material.colorWrite === true ) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;

  	}

  	_getDepthCompare( material ) {

  		let depthCompare;

  		if ( material.depthTest === false ) {

  			depthCompare = GPUCompareFunction.Always;

  		} else {

  			const depthFunc = material.depthFunc;

  			switch ( depthFunc ) {

  				case NeverDepth:
  					depthCompare = GPUCompareFunction.Never;
  					break;

  				case AlwaysDepth:
  					depthCompare = GPUCompareFunction.Always;
  					break;

  				case LessDepth:
  					depthCompare = GPUCompareFunction.Less;
  					break;

  				case LessEqualDepth:
  					depthCompare = GPUCompareFunction.LessEqual;
  					break;

  				case EqualDepth:
  					depthCompare = GPUCompareFunction.Equal;
  					break;

  				case GreaterEqualDepth:
  					depthCompare = GPUCompareFunction.GreaterEqual;
  					break;

  				case GreaterDepth:
  					depthCompare = GPUCompareFunction.Greater;
  					break;

  				case NotEqualDepth:
  					depthCompare = GPUCompareFunction.NotEqual;
  					break;

  				default:
  					console.error( 'THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc );

  			}

  		}

  		return depthCompare;

  	}

  }

  /*// debugger tools
  import 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';
  //*/


  //

  class WebGPUBackend extends Backend {

  	constructor( parameters = {} ) {

  		super( parameters );

  		this.isWebGPUBackend = true;

  		// some parameters require default values other than "undefined"
  		this.parameters.alpha = ( parameters.alpha === undefined ) ? true : parameters.alpha;

  		this.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;

  		this.trackTimestamp = ( parameters.trackTimestamp === true );

  		this.device = null;
  		this.context = null;
  		this.colorBuffer = null;
  		this.defaultRenderPassdescriptor = null;

  		this.utils = new WebGPUUtils( this );
  		this.attributeUtils = new WebGPUAttributeUtils( this );
  		this.bindingUtils = new WebGPUBindingUtils( this );
  		this.pipelineUtils = new WebGPUPipelineUtils( this );
  		this.textureUtils = new WebGPUTextureUtils( this );
  		this.occludedResolveCache = new Map();

  	}

  	async init( renderer ) {

  		await super.init( renderer );

  		//

  		const parameters = this.parameters;

  		// create the device if it is not passed with parameters

  		let device;

  		if ( parameters.device === undefined ) {

  			const adapterOptions = {
  				powerPreference: parameters.powerPreference
  			};

  			const adapter = await navigator.gpu.requestAdapter( adapterOptions );

  			if ( adapter === null ) {

  				throw new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );

  			}

  			// feature support

  			const features = Object.values( GPUFeatureName );

  			const supportedFeatures = [];

  			for ( const name of features ) {

  				if ( adapter.features.has( name ) ) {

  					supportedFeatures.push( name );

  				}

  			}

  			const deviceDescriptor = {
  				requiredFeatures: supportedFeatures,
  				requiredLimits: parameters.requiredLimits
  			};

  			device = await adapter.requestDevice( deviceDescriptor );

  		} else {

  			device = parameters.device;

  		}

  		const context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );

  		this.device = device;
  		this.context = context;

  		const alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';

  		this.trackTimestamp = this.trackTimestamp && this.hasFeature( GPUFeatureName.TimestampQuery );

  		this.context.configure( {
  			device: this.device,
  			format: this.utils.getPreferredCanvasFormat(),
  			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
  			alphaMode: alphaMode
  		} );

  		this.updateSize();

  	}

  	get coordinateSystem() {

  		return WebGPUCoordinateSystem;

  	}

  	async getArrayBufferAsync( attribute ) {

  		return await this.attributeUtils.getArrayBufferAsync( attribute );

  	}

  	getContext() {

  		return this.context;

  	}

  	_getDefaultRenderPassDescriptor() {

  		let descriptor = this.defaultRenderPassdescriptor;

  		if ( descriptor === null ) {

  			const renderer = this.renderer;

  			descriptor = {
  				colorAttachments: [ {
  					view: null
  				} ],
  				depthStencilAttachment: {
  					view: this.textureUtils.getDepthBuffer( renderer.depth, renderer.stencil ).createView()
  				}
  			};

  			const colorAttachment = descriptor.colorAttachments[ 0 ];

  			if ( this.renderer.samples > 0 ) {

  				colorAttachment.view = this.colorBuffer.createView();

  			} else {

  				colorAttachment.resolveTarget = undefined;

  			}

  			this.defaultRenderPassdescriptor = descriptor;

  		}

  		const colorAttachment = descriptor.colorAttachments[ 0 ];

  		if ( this.renderer.samples > 0 ) {

  			colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();

  		} else {

  			colorAttachment.view = this.context.getCurrentTexture().createView();

  		}

  		return descriptor;

  	}

  	_getRenderPassDescriptor( renderContext ) {

  		const renderTarget = renderContext.renderTarget;
  		const renderTargetData = this.get( renderTarget );

  		let descriptors = renderTargetData.descriptors;

  		if ( descriptors === undefined ||
  			renderTargetData.width !== renderTarget.width ||
  			renderTargetData.height !== renderTarget.height ||
  			renderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel ||
  			renderTargetData.samples !== renderTarget.samples
  		) {

  			descriptors = {};

  			renderTargetData.descriptors = descriptors;

  			// dispose

  			const onDispose = () => {

  				renderTarget.removeEventListener( 'dispose', onDispose );

  				this.delete( renderTarget );

  			};

  			renderTarget.addEventListener( 'dispose', onDispose );

  		}

  		const cacheKey = renderContext.getCacheKey();

  		let descriptor = descriptors[ cacheKey ];

  		if ( descriptor === undefined ) {

  			const textures = renderContext.textures;
  			const colorAttachments = [];

  			for ( let i = 0; i < textures.length; i ++ ) {

  				const textureData = this.get( textures[ i ] );

  				const textureView = textureData.texture.createView( {
  					baseMipLevel: renderContext.activeMipmapLevel,
  					mipLevelCount: 1,
  					baseArrayLayer: renderContext.activeCubeFace,
  					dimension: GPUTextureViewDimension.TwoD
  				} );

  				let view, resolveTarget;

  				if ( textureData.msaaTexture !== undefined ) {

  					view = textureData.msaaTexture.createView();
  					resolveTarget = textureView;

  				} else {

  					view = textureView;
  					resolveTarget = undefined;

  				}

  				colorAttachments.push( {
  					view,
  					resolveTarget,
  					loadOp: GPULoadOp.Load,
  					storeOp: GPUStoreOp.Store
  				} );

  			}

  			const depthTextureData = this.get( renderContext.depthTexture );

  			const depthStencilAttachment = {
  				view: depthTextureData.texture.createView()
  			};

  			descriptor = {
  				colorAttachments,
  				depthStencilAttachment
  			};

  			descriptors[ cacheKey ] = descriptor;

  			renderTargetData.width = renderTarget.width;
  			renderTargetData.height = renderTarget.height;
  			renderTargetData.samples = renderTarget.samples;
  			renderTargetData.activeMipmapLevel = renderTarget.activeMipmapLevel;

  		}

  		return descriptor;

  	}

  	beginRender( renderContext ) {

  		const renderContextData = this.get( renderContext );

  		const device = this.device;
  		const occlusionQueryCount = renderContext.occlusionQueryCount;

  		let occlusionQuerySet;

  		if ( occlusionQueryCount > 0 ) {

  			if ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();
  			if ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();

  			// Get a reference to the array of objects with queries. The renderContextData property
  			// can be changed by another render pass before the buffer.mapAsyc() completes.
  			renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
  			renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
  			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;

  			//

  			occlusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount } );

  			renderContextData.occlusionQuerySet = occlusionQuerySet;
  			renderContextData.occlusionQueryIndex = 0;
  			renderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );

  			renderContextData.lastOcclusionObject = null;

  		}

  		let descriptor;

  		if ( renderContext.textures === null ) {

  			descriptor = this._getDefaultRenderPassDescriptor();

  		} else {

  			descriptor = this._getRenderPassDescriptor( renderContext );

  		}

  		this.initTimestampQuery( renderContext, descriptor );

  		descriptor.occlusionQuerySet = occlusionQuerySet;

  		const depthStencilAttachment = descriptor.depthStencilAttachment;

  		if ( renderContext.textures !== null ) {

  			const colorAttachments = descriptor.colorAttachments;

  			for ( let i = 0; i < colorAttachments.length; i ++ ) {

  				const colorAttachment = colorAttachments[ i ];

  				if ( renderContext.clearColor ) {

  					colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };
  					colorAttachment.loadOp = GPULoadOp.Clear;
  					colorAttachment.storeOp = GPUStoreOp.Store;

  				} else {

  					colorAttachment.loadOp = GPULoadOp.Load;
  					colorAttachment.storeOp = GPUStoreOp.Store;

  				}

  			}

  		} else {

  			const colorAttachment = descriptor.colorAttachments[ 0 ];

  			if ( renderContext.clearColor ) {

  				colorAttachment.clearValue = renderContext.clearColorValue;
  				colorAttachment.loadOp = GPULoadOp.Clear;
  				colorAttachment.storeOp = GPUStoreOp.Store;

  			} else {

  				colorAttachment.loadOp = GPULoadOp.Load;
  				colorAttachment.storeOp = GPUStoreOp.Store;

  			}

  		}

  		//

  		if ( renderContext.depth ) {

  			if ( renderContext.clearDepth ) {

  				depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
  				depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
  				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

  			} else {

  				depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
  				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

  			}

  		}

  		if ( renderContext.stencil ) {

  			if ( renderContext.clearStencil ) {

  				depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
  				depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
  				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

  			} else {

  				depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
  				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

  			}

  		}

  		//

  		const encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );
  		const currentPass = encoder.beginRenderPass( descriptor );

  		//

  		renderContextData.descriptor = descriptor;
  		renderContextData.encoder = encoder;
  		renderContextData.currentPass = currentPass;
  		renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
  		renderContextData.renderBundles = [];

  		//

  		if ( renderContext.viewport ) {

  			this.updateViewport( renderContext );

  		}

  		if ( renderContext.scissor ) {

  			const { x, y, width, height } = renderContext.scissorValue;

  			currentPass.setScissorRect( x, y, width, height );

  		}

  	}

  	finishRender( renderContext ) {

  		const renderContextData = this.get( renderContext );
  		const occlusionQueryCount = renderContext.occlusionQueryCount;

  		if ( renderContextData.renderBundles.length > 0 ) {

  			renderContextData.currentPass.executeBundles( renderContextData.renderBundles );

  		}

  		if ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {

  			renderContextData.currentPass.endOcclusionQuery();

  		}

  		renderContextData.currentPass.end();

  		if ( occlusionQueryCount > 0 ) {

  			const bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results

  			//

  			let queryResolveBuffer = this.occludedResolveCache.get( bufferSize );

  			if ( queryResolveBuffer === undefined ) {

  				queryResolveBuffer = this.device.createBuffer(
  					{
  						size: bufferSize,
  						usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
  					}
  				);

  				this.occludedResolveCache.set( bufferSize, queryResolveBuffer );

  			}

  			//

  			const readBuffer = this.device.createBuffer(
  				{
  					size: bufferSize,
  					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  				}
  			);

  			// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined
  			renderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );
  			renderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );

  			renderContextData.occlusionQueryBuffer = readBuffer;

  			//

  			this.resolveOccludedAsync( renderContext );

  		}

  		this.prepareTimestampBuffer( renderContext, renderContextData.encoder );

  		this.device.queue.submit( [ renderContextData.encoder.finish() ] );


  		//

  		if ( renderContext.textures !== null ) {

  			const textures = renderContext.textures;

  			for ( let i = 0; i < textures.length; i ++ ) {

  				const texture = textures[ i ];

  				if ( texture.generateMipmaps === true ) {

  					this.textureUtils.generateMipmaps( texture );

  				}

  			}

  		}

  	}

  	isOccluded( renderContext, object ) {

  		const renderContextData = this.get( renderContext );

  		return renderContextData.occluded && renderContextData.occluded.has( object );

  	}

  	async resolveOccludedAsync( renderContext ) {

  		const renderContextData = this.get( renderContext );

  		// handle occlusion query results

  		const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;

  		if ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {

  			const occluded = new WeakSet();

  			renderContextData.currentOcclusionQueryObjects = null;
  			renderContextData.currentOcclusionQueryBuffer = null;

  			await currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );

  			const buffer = currentOcclusionQueryBuffer.getMappedRange();
  			const results = new BigUint64Array( buffer );

  			for ( let i = 0; i < currentOcclusionQueryObjects.length; i ++ ) {

  				if ( results[ i ] !== BigInt( 0 ) ) {

  					occluded.add( currentOcclusionQueryObjects[ i ] );

  				}

  			}

  			currentOcclusionQueryBuffer.destroy();

  			renderContextData.occluded = occluded;

  		}

  	}

  	updateViewport( renderContext ) {

  		const { currentPass } = this.get( renderContext );
  		const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;

  		currentPass.setViewport( x, y, width, height, minDepth, maxDepth );

  	}

  	clear( color, depth, stencil, renderTargetData = null ) {

  		const device = this.device;
  		const renderer = this.renderer;

  		let colorAttachments = [];

  		let depthStencilAttachment;
  		let clearValue;

  		let supportsDepth;
  		let supportsStencil;

  		if ( color ) {

  			const clearColor = this.getClearColor();

  			if ( this.renderer.alpha === true ) {

  				// premultiply alpha

  				const a = clearColor.a;

  				clearValue = { r: clearColor.r * a, g: clearColor.g * a, b: clearColor.b * a, a: a };

  			} else {

  				clearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };

  			}

  		}

  		if ( renderTargetData === null ) {

  			supportsDepth = renderer.depth;
  			supportsStencil = renderer.stencil;

  			const descriptor = this._getDefaultRenderPassDescriptor();

  			if ( color ) {

  				colorAttachments = descriptor.colorAttachments;

  				const colorAttachment = colorAttachments[ 0 ];

  				colorAttachment.clearValue = clearValue;
  				colorAttachment.loadOp = GPULoadOp.Clear;
  				colorAttachment.storeOp = GPUStoreOp.Store;

  			}

  			if ( supportsDepth || supportsStencil ) {

  				depthStencilAttachment = descriptor.depthStencilAttachment;

  			}

  		} else {

  			supportsDepth = renderTargetData.depth;
  			supportsStencil = renderTargetData.stencil;

  			if ( color ) {

  				for ( const texture of renderTargetData.textures ) {

  					const textureData = this.get( texture );
  					const textureView = textureData.texture.createView();

  					let view, resolveTarget;

  					if ( textureData.msaaTexture !== undefined ) {

  						view = textureData.msaaTexture.createView();
  						resolveTarget = textureView;

  					} else {

  						view = textureView;
  						resolveTarget = undefined;

  					}

  					colorAttachments.push( {
  						view,
  						resolveTarget,
  						clearValue,
  						loadOp: GPULoadOp.Clear,
  						storeOp: GPUStoreOp.Store
  					} );

  				}

  			}

  			if ( supportsDepth || supportsStencil ) {

  				const depthTextureData = this.get( renderTargetData.depthTexture );

  				depthStencilAttachment = {
  					view: depthTextureData.texture.createView()
  				};

  			}

  		}

  		//

  		if ( supportsDepth ) {

  			if ( depth ) {

  				depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
  				depthStencilAttachment.depthClearValue = renderer.getClearDepth();
  				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

  			} else {

  				depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
  				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

  			}

  		}

  		//

  		if ( supportsStencil ) {

  			if ( stencil ) {

  				depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
  				depthStencilAttachment.stencilClearValue = renderer.getClearStencil();
  				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

  			} else {

  				depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
  				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

  			}

  		}

  		//

  		const encoder = device.createCommandEncoder( {} );
  		const currentPass = encoder.beginRenderPass( {
  			colorAttachments,
  			depthStencilAttachment
  		} );

  		currentPass.end();

  		device.queue.submit( [ encoder.finish() ] );

  	}

  	// compute

  	beginCompute( computeGroup ) {

  		const groupGPU = this.get( computeGroup );


  		const descriptor = {};

  		this.initTimestampQuery( computeGroup, descriptor );

  		groupGPU.cmdEncoderGPU = this.device.createCommandEncoder();

  		groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass( descriptor );

  	}

  	compute( computeGroup, computeNode, bindings, pipeline ) {

  		const { passEncoderGPU } = this.get( computeGroup );

  		// pipeline

  		const pipelineGPU = this.get( pipeline ).pipeline;
  		passEncoderGPU.setPipeline( pipelineGPU );

  		// bind groups

  		for ( let i = 0, l = bindings.length; i < l; i ++ ) {

  			const bindGroup = bindings[ i ];
  			const bindingsData = this.get( bindGroup );

  			passEncoderGPU.setBindGroup( i, bindingsData.group );

  		}

  		const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;

  		const computeNodeData = this.get( computeNode );

  		if ( computeNodeData.dispatchSize === undefined ) computeNodeData.dispatchSize = { x: 0, y: 1, z: 1 };

  		const { dispatchSize } = computeNodeData;

  		if ( computeNode.dispatchCount > maxComputeWorkgroupsPerDimension ) {

  			dispatchSize.x = Math.min( computeNode.dispatchCount, maxComputeWorkgroupsPerDimension );
  			dispatchSize.y = Math.ceil( computeNode.dispatchCount / maxComputeWorkgroupsPerDimension );

  		} else {

  			dispatchSize.x = computeNode.dispatchCount;

  		}

  		passEncoderGPU.dispatchWorkgroups(
  			dispatchSize.x,
  			dispatchSize.y,
  			dispatchSize.z
  		);

  	}

  	finishCompute( computeGroup ) {

  		const groupData = this.get( computeGroup );

  		groupData.passEncoderGPU.end();

  		this.prepareTimestampBuffer( computeGroup, groupData.cmdEncoderGPU );

  		this.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );

  	}

  	// render object

  	draw( renderObject, info ) {

  		const { object, context, pipeline } = renderObject;
  		const bindings = renderObject.getBindings();
  		const renderContextData = this.get( context );
  		const pipelineGPU = this.get( pipeline ).pipeline;
  		const currentSets = renderContextData.currentSets;
  		const passEncoderGPU = renderContextData.currentPass;

  		const drawParms = renderObject.getDrawParameters();

  		if ( drawParms === null ) return;

  		// pipeline

  		if ( currentSets.pipeline !== pipelineGPU ) {

  			passEncoderGPU.setPipeline( pipelineGPU );

  			currentSets.pipeline = pipelineGPU;

  		}

  		// bind groups

  		const currentBindingGroups = currentSets.bindingGroups;

  		for ( let i = 0, l = bindings.length; i < l; i ++ ) {

  			const bindGroup = bindings[ i ];
  			const bindingsData = this.get( bindGroup );

  			if ( currentBindingGroups[ bindGroup.index ] !== bindGroup.id ) {

  				passEncoderGPU.setBindGroup( bindGroup.index, bindingsData.group );
  				currentBindingGroups[ bindGroup.index ] = bindGroup.id;

  			}

  		}

  		// attributes

  		const index = renderObject.getIndex();

  		const hasIndex = ( index !== null );

  		// index

  		if ( hasIndex === true ) {

  			if ( currentSets.index !== index ) {

  				const buffer = this.get( index ).buffer;
  				const indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;

  				passEncoderGPU.setIndexBuffer( buffer, indexFormat );

  				currentSets.index = index;

  			}

  		}

  		// vertex buffers

  		const vertexBuffers = renderObject.getVertexBuffers();

  		for ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {

  			const vertexBuffer = vertexBuffers[ i ];

  			if ( currentSets.attributes[ i ] !== vertexBuffer ) {

  				const buffer = this.get( vertexBuffer ).buffer;
  				passEncoderGPU.setVertexBuffer( i, buffer );

  				currentSets.attributes[ i ] = vertexBuffer;

  			}

  		}

  		// occlusion queries - handle multiple consecutive draw calls for an object

  		if ( renderContextData.occlusionQuerySet !== undefined ) {

  			const lastObject = renderContextData.lastOcclusionObject;

  			if ( lastObject !== object ) {

  				if ( lastObject !== null && lastObject.occlusionTest === true ) {

  					passEncoderGPU.endOcclusionQuery();
  					renderContextData.occlusionQueryIndex ++;

  				}

  				if ( object.occlusionTest === true ) {

  					passEncoderGPU.beginOcclusionQuery( renderContextData.occlusionQueryIndex );
  					renderContextData.occlusionQueryObjects[ renderContextData.occlusionQueryIndex ] = object;

  				}

  				renderContextData.lastOcclusionObject = object;

  			}

  		}

  		// draw

  		if ( object.isBatchedMesh === true ) {

  			const starts = object._multiDrawStarts;
  			const counts = object._multiDrawCounts;
  			const drawCount = object._multiDrawCount;
  			const drawInstances = object._multiDrawInstances;

  			const bytesPerElement = hasIndex ? index.array.BYTES_PER_ELEMENT : 1;

  			for ( let i = 0; i < drawCount; i ++ ) {

  				const count = drawInstances ? drawInstances[ i ] : 1;
  				const firstInstance = count > 1 ? 0 : i;

  				passEncoderGPU.drawIndexed( counts[ i ], count, starts[ i ] / bytesPerElement, 0, firstInstance );

  			}

  		} else if ( hasIndex === true ) {

  			const { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParms;

  			passEncoderGPU.drawIndexed( indexCount, instanceCount, firstIndex, 0, 0 );

  			info.update( object, indexCount, instanceCount );

  		} else {

  			const { vertexCount, instanceCount, firstVertex } = drawParms;

  			passEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );

  			info.update( object, vertexCount, instanceCount );

  		}

  	}

  	// cache key

  	needsRenderUpdate( renderObject ) {

  		const data = this.get( renderObject );

  		const { object, material } = renderObject;

  		const utils = this.utils;

  		const sampleCount = utils.getSampleCountRenderContext( renderObject.context );
  		const colorSpace = utils.getCurrentColorSpace( renderObject.context );
  		const colorFormat = utils.getCurrentColorFormat( renderObject.context );
  		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );
  		const primitiveTopology = utils.getPrimitiveTopology( object, material );

  		let needsUpdate = false;

  		if ( data.material !== material || data.materialVersion !== material.version ||
  			data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||
  			data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||
  			data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||
  			data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||
  			data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||
  			data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||
  			data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||
  			data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||
  			data.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||
  			data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||
  			data.primitiveTopology !== primitiveTopology ||
  			data.clippingContextCacheKey !== renderObject.clippingContext.cacheKey
  		) {

  			data.material = material; data.materialVersion = material.version;
  			data.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;
  			data.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;
  			data.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;
  			data.colorWrite = material.colorWrite;
  			data.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;
  			data.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;
  			data.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;
  			data.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;
  			data.side = material.side; data.alphaToCoverage = material.alphaToCoverage;
  			data.sampleCount = sampleCount;
  			data.colorSpace = colorSpace;
  			data.colorFormat = colorFormat;
  			data.depthStencilFormat = depthStencilFormat;
  			data.primitiveTopology = primitiveTopology;
  			data.clippingContextCacheKey = renderObject.clippingContext.cacheKey;

  			needsUpdate = true;

  		}

  		return needsUpdate;

  	}

  	getRenderCacheKey( renderObject ) {

  		const { object, material } = renderObject;

  		const utils = this.utils;
  		const renderContext = renderObject.context;

  		return [
  			material.transparent, material.blending, material.premultipliedAlpha,
  			material.blendSrc, material.blendDst, material.blendEquation,
  			material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,
  			material.colorWrite,
  			material.depthWrite, material.depthTest, material.depthFunc,
  			material.stencilWrite, material.stencilFunc,
  			material.stencilFail, material.stencilZFail, material.stencilZPass,
  			material.stencilFuncMask, material.stencilWriteMask,
  			material.side,
  			utils.getSampleCountRenderContext( renderContext ),
  			utils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),
  			utils.getPrimitiveTopology( object, material ),
  			renderObject.clippingContext.cacheKey
  		].join();

  	}

  	// textures

  	createSampler( texture ) {

  		this.textureUtils.createSampler( texture );

  	}

  	destroySampler( texture ) {

  		this.textureUtils.destroySampler( texture );

  	}

  	createDefaultTexture( texture ) {

  		this.textureUtils.createDefaultTexture( texture );

  	}

  	createTexture( texture, options ) {

  		this.textureUtils.createTexture( texture, options );

  	}

  	updateTexture( texture, options ) {

  		this.textureUtils.updateTexture( texture, options );

  	}

  	generateMipmaps( texture ) {

  		this.textureUtils.generateMipmaps( texture );

  	}

  	destroyTexture( texture ) {

  		this.textureUtils.destroyTexture( texture );

  	}

  	copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

  		return this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );

  	}


  	initTimestampQuery( renderContext, descriptor ) {

  		if ( ! this.trackTimestamp ) return;

  		const renderContextData = this.get( renderContext );

  		if ( ! renderContextData.timeStampQuerySet ) {

  			// Create a GPUQuerySet which holds 2 timestamp query results: one for the
  			// beginning and one for the end of compute pass execution.
  			const timeStampQuerySet = this.device.createQuerySet( { type: 'timestamp', count: 2 } );

  			const timestampWrites = {
  				querySet: timeStampQuerySet,
  				beginningOfPassWriteIndex: 0, // Write timestamp in index 0 when pass begins.
  				endOfPassWriteIndex: 1, // Write timestamp in index 1 when pass ends.
  			};

  			Object.assign( descriptor, {
  				timestampWrites,
  			} );

  			renderContextData.timeStampQuerySet = timeStampQuerySet;

  		}

  	}

  	// timestamp utils

  	prepareTimestampBuffer( renderContext, encoder ) {

  		if ( ! this.trackTimestamp ) return;

  		const renderContextData = this.get( renderContext );


  		const size = 2 * BigInt64Array.BYTES_PER_ELEMENT;

  		if ( renderContextData.currentTimestampQueryBuffers === undefined ) {

  			renderContextData.currentTimestampQueryBuffers = {
  				resolveBuffer: this.device.createBuffer( {
  					label: 'timestamp resolve buffer',
  					size: size,
  					usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
  				} ),
  				resultBuffer: this.device.createBuffer( {
  					label: 'timestamp result buffer',
  					size: size,
  					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
  				} ),
  				isMappingPending: false,
  			};

  		}

  		const { resolveBuffer, resultBuffer, isMappingPending } = renderContextData.currentTimestampQueryBuffers;

  		if ( isMappingPending === true ) return;

  		encoder.resolveQuerySet( renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0 );
  		encoder.copyBufferToBuffer( resolveBuffer, 0, resultBuffer, 0, size );

  	}

  	async resolveTimestampAsync( renderContext, type = 'render' ) {

  		if ( ! this.trackTimestamp ) return;

  		const renderContextData = this.get( renderContext );

  		if ( renderContextData.currentTimestampQueryBuffers === undefined ) return;

  		const { resultBuffer, isMappingPending } = renderContextData.currentTimestampQueryBuffers;

  		if ( isMappingPending === true ) return;

  		renderContextData.currentTimestampQueryBuffers.isMappingPending = true;

  		resultBuffer.mapAsync( GPUMapMode.READ ).then( () => {

  			const times = new BigUint64Array( resultBuffer.getMappedRange() );
  			const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;


  			this.renderer.info.updateTimestamp( type, duration );

  			resultBuffer.unmap();

  			renderContextData.currentTimestampQueryBuffers.isMappingPending = false;

  		} );

  	}

  	// node builder

  	createNodeBuilder( object, renderer ) {

  		return new WGSLNodeBuilder( object, renderer );

  	}

  	// program

  	createProgram( program ) {

  		const programGPU = this.get( program );

  		programGPU.module = {
  			module: this.device.createShaderModule( { code: program.code, label: program.stage } ),
  			entryPoint: 'main'
  		};

  	}

  	destroyProgram( program ) {

  		this.delete( program );

  	}

  	// pipelines

  	createRenderPipeline( renderObject, promises ) {

  		this.pipelineUtils.createRenderPipeline( renderObject, promises );

  	}

  	createComputePipeline( computePipeline, bindings ) {

  		this.pipelineUtils.createComputePipeline( computePipeline, bindings );

  	}

  	beginBundle( renderContext ) {

  		const renderContextData = this.get( renderContext );

  		renderContextData._currentPass = renderContextData.currentPass;
  		renderContextData._currentSets = renderContextData.currentSets;

  		renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
  		renderContextData.currentPass = this.pipelineUtils.createBundleEncoder( renderContext );

  	}

  	finishBundle( renderContext, bundle ) {

  		const renderContextData = this.get( renderContext );

  		const bundleEncoder = renderContextData.currentPass;
  		const bundleGPU = bundleEncoder.finish();

  		this.get( bundle ).bundleGPU = bundleGPU;

  		// restore render pass state

  		renderContextData.currentSets = renderContextData._currentSets;
  		renderContextData.currentPass = renderContextData._currentPass;

  	}

  	addBundle( renderContext, bundle ) {

  		const renderContextData = this.get( renderContext );

  		renderContextData.renderBundles.push( this.get( bundle ).bundleGPU );

  	}

  	// bindings

  	createBindings( bindGroup ) {

  		this.bindingUtils.createBindings( bindGroup );

  	}

  	updateBindings( bindGroup ) {

  		this.bindingUtils.createBindings( bindGroup );

  	}

  	updateBinding( binding ) {

  		this.bindingUtils.updateBinding( binding );

  	}

  	// attributes

  	createIndexAttribute( attribute ) {

  		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

  	}

  	createAttribute( attribute ) {

  		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

  	}

  	createStorageAttribute( attribute ) {

  		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

  	}

  	updateAttribute( attribute ) {

  		this.attributeUtils.updateAttribute( attribute );

  	}

  	destroyAttribute( attribute ) {

  		this.attributeUtils.destroyAttribute( attribute );

  	}

  	// canvas

  	updateSize() {

  		this.colorBuffer = this.textureUtils.getColorBuffer();
  		this.defaultRenderPassdescriptor = null;

  	}

  	// utils public

  	getMaxAnisotropy() {

  		return 16;

  	}

  	hasFeature( name ) {

  		return this.device.features.has( name );

  	}

  	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

  		let dstX = 0;
  		let dstY = 0;
  		let dstLayer = 0;

  		let srcX = 0;
  		let srcY = 0;
  		let srcLayer = 0;

  		let srcWidth = srcTexture.image.width;
  		let srcHeight = srcTexture.image.height;

  		if ( srcRegion !== null ) {

  			srcX = srcRegion.x;
  			srcY = srcRegion.y;
  			srcLayer = srcRegion.z || 0;
  			srcWidth = srcRegion.width;
  			srcHeight = srcRegion.height;

  		}

  		if ( dstPosition !== null ) {

  			dstX = dstPosition.x;
  			dstY = dstPosition.y;
  			dstLayer = dstPosition.z || 0;

  		}

  		const encoder = this.device.createCommandEncoder( { label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id } );

  		const sourceGPU = this.get( srcTexture ).texture;
  		const destinationGPU = this.get( dstTexture ).texture;

  		encoder.copyTextureToTexture(
  			{
  				texture: sourceGPU,
  				mipLevel: level,
  				origin: { x: srcX, y: srcY, z: srcLayer }
  			},
  			{
  				texture: destinationGPU,
  				mipLevel: level,
  				origin: { x: dstX, y: dstY, z: dstLayer }
  			},
  			[
  				srcWidth,
  				srcHeight,
  				1
  			]
  		);

  		this.device.queue.submit( [ encoder.finish() ] );

  	}

  	copyFramebufferToTexture( texture, renderContext, rectangle ) {

  		const renderContextData = this.get( renderContext );

  		const { encoder, descriptor } = renderContextData;

  		let sourceGPU = null;

  		if ( renderContext.renderTarget ) {

  			if ( texture.isDepthTexture ) {

  				sourceGPU = this.get( renderContext.depthTexture ).texture;

  			} else {

  				sourceGPU = this.get( renderContext.textures[ 0 ] ).texture;

  			}

  		} else {

  			if ( texture.isDepthTexture ) {

  				sourceGPU = this.textureUtils.getDepthBuffer( renderContext.depth, renderContext.stencil );

  			} else {

  				sourceGPU = this.context.getCurrentTexture();

  			}

  		}

  		const destinationGPU = this.get( texture ).texture;

  		if ( sourceGPU.format !== destinationGPU.format ) {

  			console.error( 'WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format );

  			return;

  		}

  		renderContextData.currentPass.end();

  		encoder.copyTextureToTexture(
  			{
  				texture: sourceGPU,
  				origin: { x: rectangle.x, y: rectangle.y, z: 0 }
  			},
  			{
  				texture: destinationGPU
  			},
  			[
  				rectangle.z,
  				rectangle.w
  			]
  		);

  		if ( texture.generateMipmaps ) this.textureUtils.generateMipmaps( texture );

  		for ( let i = 0; i < descriptor.colorAttachments.length; i ++ ) {

  			descriptor.colorAttachments[ i ].loadOp = GPULoadOp.Load;

  		}

  		if ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
  		if ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;

  		renderContextData.currentPass = encoder.beginRenderPass( descriptor );
  		renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };

  	}

  }

  class IESSpotLight extends SpotLight {

  	constructor( color, intensity, distance, angle, penumbra, decay ) {

  		super( color, intensity, distance, angle, penumbra, decay );

  		this.iesMap = null;

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.iesMap = source.iesMap;

  		return this;

  	}

  }

  class StandardNodeLibrary extends NodeLibrary {

  	constructor() {

  		super();

  		this.addMaterial( MeshPhongNodeMaterial, MeshPhongMaterial );
  		this.addMaterial( MeshStandardNodeMaterial, MeshStandardMaterial );
  		this.addMaterial( MeshPhysicalNodeMaterial, MeshPhysicalMaterial );
  		this.addMaterial( MeshToonNodeMaterial, MeshToonMaterial );
  		this.addMaterial( MeshBasicNodeMaterial, MeshBasicMaterial );
  		this.addMaterial( MeshLambertNodeMaterial, MeshLambertMaterial );
  		this.addMaterial( MeshNormalNodeMaterial, MeshNormalMaterial );
  		this.addMaterial( MeshMatcapNodeMaterial, MeshMatcapMaterial );
  		this.addMaterial( LineBasicNodeMaterial, LineBasicMaterial );
  		this.addMaterial( LineDashedNodeMaterial, LineDashedMaterial );
  		this.addMaterial( PointsNodeMaterial, PointsMaterial );
  		this.addMaterial( SpriteNodeMaterial, SpriteMaterial );
  		this.addMaterial( ShadowNodeMaterial, ShadowMaterial );

  		this.addLight( PointLightNode, PointLight );
  		this.addLight( DirectionalLightNode, DirectionalLight );
  		this.addLight( RectAreaLightNode, RectAreaLight );
  		this.addLight( SpotLightNode, SpotLight );
  		this.addLight( AmbientLightNode, AmbientLight );
  		this.addLight( HemisphereLightNode, HemisphereLight );
  		this.addLight( LightProbeNode, LightProbe );
  		this.addLight( IESSpotLightNode, IESSpotLight );

  		this.addToneMapping( linearToneMapping, LinearToneMapping );
  		this.addToneMapping( reinhardToneMapping, ReinhardToneMapping );
  		this.addToneMapping( cineonToneMapping, CineonToneMapping );
  		this.addToneMapping( acesFilmicToneMapping, ACESFilmicToneMapping );
  		this.addToneMapping( agxToneMapping, AgXToneMapping );
  		this.addToneMapping( neutralToneMapping, NeutralToneMapping );

  		this.addColorSpace( linearSRGBTosRGB, getColorSpaceMethod( LinearSRGBColorSpace, SRGBColorSpace ) );
  		this.addColorSpace( sRGBToLinearSRGB, getColorSpaceMethod( SRGBColorSpace, LinearSRGBColorSpace ) );

  	}

  }

  /*
  const debugHandler = {

  	get: function ( target, name ) {

  		// Add |update
  		if ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );

  		return target[ name ];

  	}

  };
  */
  class WebGPURenderer extends Renderer {

  	constructor( parameters = {} ) {

  		let BackendClass;

  		if ( parameters.forceWebGL ) {

  			BackendClass = WebGLBackend;

  		} else {

  			BackendClass = WebGPUBackend;

  			parameters.getFallback = () => {

  				console.warn( 'THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.' );

  				return new WebGLBackend( parameters );

  			};

  		}

  		const backend = new BackendClass( parameters );

  		//super( new Proxy( backend, debugHandler ) );
  		super( backend, parameters );

  		this.nodes.library = new StandardNodeLibrary();

  		this.isWebGPURenderer = true;

  	}

  }

  if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
  		revision: REVISION,
  	} } ) );

  }

  if ( typeof window !== 'undefined' ) {

  	if ( window.__THREE__ ) {

  		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

  	} else {

  		window.__THREE__ = REVISION;

  	}

  }

  const _changeEvent$2 = { type: 'change' };
  const _startEvent$1 = { type: 'start' };
  const _endEvent$1 = { type: 'end' };

  const _EPS$2 = 0.000001;
  const _STATE$1 = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

  const _v2 = new three$1.Vector2();
  const _mouseChange = new three$1.Vector2();
  const _objectUp = new three$1.Vector3();
  const _pan = new three$1.Vector3();
  const _axis = new three$1.Vector3();
  const _quaternion = new three$1.Quaternion();
  const _eyeDirection = new three$1.Vector3();
  const _objectUpDirection = new three$1.Vector3();
  const _objectSidewaysDirection = new three$1.Vector3();
  const _moveDirection = new three$1.Vector3();

  class TrackballControls extends three$1.Controls {

  	constructor( object, domElement = null ) {

  		super( object, domElement );

  		// API

  		this.enabled = true;

  		this.screen = { left: 0, top: 0, width: 0, height: 0 };

  		this.rotateSpeed = 1.0;
  		this.zoomSpeed = 1.2;
  		this.panSpeed = 0.3;

  		this.noRotate = false;
  		this.noZoom = false;
  		this.noPan = false;

  		this.staticMoving = false;
  		this.dynamicDampingFactor = 0.2;

  		this.minDistance = 0;
  		this.maxDistance = Infinity;

  		this.minZoom = 0;
  		this.maxZoom = Infinity;

  		this.keys = [ 'KeyA' /*A*/, 'KeyS' /*S*/, 'KeyD' /*D*/ ];

  		this.mouseButtons = { LEFT: three$1.MOUSE.ROTATE, MIDDLE: three$1.MOUSE.DOLLY, RIGHT: three$1.MOUSE.PAN };
  		this.state = _STATE$1.NONE;
  		this.keyState = _STATE$1.NONE;

  		this.target = new three$1.Vector3();

  		// internals

  		this._lastPosition = new three$1.Vector3();
  		this._lastZoom = 1;
  		this._touchZoomDistanceStart = 0;
  		this._touchZoomDistanceEnd = 0;
  		this._lastAngle = 0;

  		this._eye = new three$1.Vector3();

  		this._movePrev = new three$1.Vector2();
  		this._moveCurr = new three$1.Vector2();

  		this._lastAxis = new three$1.Vector3();

  		this._zoomStart = new three$1.Vector2();
  		this._zoomEnd = new three$1.Vector2();

  		this._panStart = new three$1.Vector2();
  		this._panEnd = new three$1.Vector2();

  		this._pointers = [];
  		this._pointerPositions = {};

  		// event listeners

  		this._onPointerMove = onPointerMove$2.bind( this );
  		this._onPointerDown = onPointerDown$2.bind( this );
  		this._onPointerUp = onPointerUp$2.bind( this );
  		this._onPointerCancel = onPointerCancel$1.bind( this );
  		this._onContextMenu = onContextMenu$2.bind( this );
  		this._onMouseWheel = onMouseWheel$1.bind( this );
  		this._onKeyDown = onKeyDown$2.bind( this );
  		this._onKeyUp = onKeyUp$1.bind( this );

  		this._onTouchStart = onTouchStart$1.bind( this );
  		this._onTouchMove = onTouchMove$1.bind( this );
  		this._onTouchEnd = onTouchEnd.bind( this );

  		this._onMouseDown = onMouseDown$1.bind( this );
  		this._onMouseMove = onMouseMove$1.bind( this );
  		this._onMouseUp = onMouseUp.bind( this );

  		// for reset

  		this._target0 = this.target.clone();
  		this._position0 = this.object.position.clone();
  		this._up0 = this.object.up.clone();
  		this._zoom0 = this.object.zoom;

  		if ( domElement !== null ) {

  			this.connect();

  			this.handleResize();

  		}

  		// force an update at start
  		this.update();

  	}

  	connect() {

  		window.addEventListener( 'keydown', this._onKeyDown );
  		window.addEventListener( 'keyup', this._onKeyUp );

  		this.domElement.addEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.addEventListener( 'pointercancel', this._onPointerCancel );
  		this.domElement.addEventListener( 'wheel', this._onMouseWheel, { passive: false } );
  		this.domElement.addEventListener( 'contextmenu', this._onContextMenu );

  		this.domElement.style.touchAction = 'none'; // disable touch scroll

  	}

  	disconnect() {

  		window.removeEventListener( 'keydown', this._onKeyDown );
  		window.removeEventListener( 'keyup', this._onKeyUp );

  		this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );
  		this.domElement.removeEventListener( 'pointercancel', this._onPointerCancel );
  		this.domElement.removeEventListener( 'wheel', this._onMouseWheel );
  		this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );

  		this.domElement.style.touchAction = 'auto'; // disable touch scroll

  	}

  	dispose() {

  		this.disconnect();

  	}

  	handleResize() {

  		const box = this.domElement.getBoundingClientRect();
  		// adjustments come from similar code in the jquery offset() function
  		const d = this.domElement.ownerDocument.documentElement;

  		this.screen.left = box.left + window.pageXOffset - d.clientLeft;
  		this.screen.top = box.top + window.pageYOffset - d.clientTop;
  		this.screen.width = box.width;
  		this.screen.height = box.height;

  	}

  	update() {

  		this._eye.subVectors( this.object.position, this.target );

  		if ( ! this.noRotate ) {

  			this._rotateCamera();

  		}

  		if ( ! this.noZoom ) {

  			this._zoomCamera();

  		}

  		if ( ! this.noPan ) {

  			this._panCamera();

  		}

  		this.object.position.addVectors( this.target, this._eye );

  		if ( this.object.isPerspectiveCamera ) {

  			this._checkDistances();

  			this.object.lookAt( this.target );

  			if ( this._lastPosition.distanceToSquared( this.object.position ) > _EPS$2 ) {

  				this.dispatchEvent( _changeEvent$2 );

  				this._lastPosition.copy( this.object.position );

  			}

  		} else if ( this.object.isOrthographicCamera ) {

  			this.object.lookAt( this.target );

  			if ( this._lastPosition.distanceToSquared( this.object.position ) > _EPS$2 || this._lastZoom !== this.object.zoom ) {

  				this.dispatchEvent( _changeEvent$2 );

  				this._lastPosition.copy( this.object.position );
  				this._lastZoom = this.object.zoom;

  			}

  		} else {

  			console.warn( 'THREE.TrackballControls: Unsupported camera type.' );

  		}

  	}

  	reset() {

  		this.state = _STATE$1.NONE;
  		this.keyState = _STATE$1.NONE;

  		this.target.copy( this._target0 );
  		this.object.position.copy( this._position0 );
  		this.object.up.copy( this._up0 );
  		this.object.zoom = this._zoom0;

  		this.object.updateProjectionMatrix();

  		this._eye.subVectors( this.object.position, this.target );

  		this.object.lookAt( this.target );

  		this.dispatchEvent( _changeEvent$2 );

  		this._lastPosition.copy( this.object.position );
  		this._lastZoom = this.object.zoom;

  	}

  	_panCamera() {

  		_mouseChange.copy( this._panEnd ).sub( this._panStart );

  		if ( _mouseChange.lengthSq() ) {

  			if ( this.object.isOrthographicCamera ) {

  				const scale_x = ( this.object.right - this.object.left ) / this.object.zoom / this.domElement.clientWidth;
  				const scale_y = ( this.object.top - this.object.bottom ) / this.object.zoom / this.domElement.clientWidth;

  				_mouseChange.x *= scale_x;
  				_mouseChange.y *= scale_y;

  			}

  			_mouseChange.multiplyScalar( this._eye.length() * this.panSpeed );

  			_pan.copy( this._eye ).cross( this.object.up ).setLength( _mouseChange.x );
  			_pan.add( _objectUp.copy( this.object.up ).setLength( _mouseChange.y ) );

  			this.object.position.add( _pan );
  			this.target.add( _pan );

  			if ( this.staticMoving ) {

  				this._panStart.copy( this._panEnd );

  			} else {

  				this._panStart.add( _mouseChange.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.dynamicDampingFactor ) );

  			}

  		}

  	}

  	_rotateCamera() {

  		_moveDirection.set( this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0 );
  		let angle = _moveDirection.length();

  		if ( angle ) {

  			this._eye.copy( this.object.position ).sub( this.target );

  			_eyeDirection.copy( this._eye ).normalize();
  			_objectUpDirection.copy( this.object.up ).normalize();
  			_objectSidewaysDirection.crossVectors( _objectUpDirection, _eyeDirection ).normalize();

  			_objectUpDirection.setLength( this._moveCurr.y - this._movePrev.y );
  			_objectSidewaysDirection.setLength( this._moveCurr.x - this._movePrev.x );

  			_moveDirection.copy( _objectUpDirection.add( _objectSidewaysDirection ) );

  			_axis.crossVectors( _moveDirection, this._eye ).normalize();

  			angle *= this.rotateSpeed;
  			_quaternion.setFromAxisAngle( _axis, angle );

  			this._eye.applyQuaternion( _quaternion );
  			this.object.up.applyQuaternion( _quaternion );

  			this._lastAxis.copy( _axis );
  			this._lastAngle = angle;

  		} else if ( ! this.staticMoving && this._lastAngle ) {

  			this._lastAngle *= Math.sqrt( 1.0 - this.dynamicDampingFactor );
  			this._eye.copy( this.object.position ).sub( this.target );
  			_quaternion.setFromAxisAngle( this._lastAxis, this._lastAngle );
  			this._eye.applyQuaternion( _quaternion );
  			this.object.up.applyQuaternion( _quaternion );

  		}

  		this._movePrev.copy( this._moveCurr );

  	}

  	_zoomCamera() {

  		let factor;

  		if ( this.state === _STATE$1.TOUCH_ZOOM_PAN ) {

  			factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;
  			this._touchZoomDistanceStart = this._touchZoomDistanceEnd;

  			if ( this.object.isPerspectiveCamera ) {

  				this._eye.multiplyScalar( factor );

  			} else if ( this.object.isOrthographicCamera ) {

  				this.object.zoom = three$1.MathUtils.clamp( this.object.zoom / factor, this.minZoom, this.maxZoom );

  				if ( this._lastZoom !== this.object.zoom ) {

  					this.object.updateProjectionMatrix();

  				}

  			} else {

  				console.warn( 'THREE.TrackballControls: Unsupported camera type' );

  			}

  		} else {

  			factor = 1.0 + ( this._zoomEnd.y - this._zoomStart.y ) * this.zoomSpeed;

  			if ( factor !== 1.0 && factor > 0.0 ) {

  				if ( this.object.isPerspectiveCamera ) {

  					this._eye.multiplyScalar( factor );

  				} else if ( this.object.isOrthographicCamera ) {

  					this.object.zoom = three$1.MathUtils.clamp( this.object.zoom / factor, this.minZoom, this.maxZoom );

  					if ( this._lastZoom !== this.object.zoom ) {

  						this.object.updateProjectionMatrix();

  					}

  				} else {

  					console.warn( 'THREE.TrackballControls: Unsupported camera type' );

  				}

  			}

  			if ( this.staticMoving ) {

  				this._zoomStart.copy( this._zoomEnd );

  			} else {

  				this._zoomStart.y += ( this._zoomEnd.y - this._zoomStart.y ) * this.dynamicDampingFactor;

  			}

  		}

  	}

  	_getMouseOnScreen( pageX, pageY ) {

  		_v2.set(
  			( pageX - this.screen.left ) / this.screen.width,
  			( pageY - this.screen.top ) / this.screen.height
  		);

  		return _v2;

  	}

  	_getMouseOnCircle( pageX, pageY ) {

  		_v2.set(
  			( ( pageX - this.screen.width * 0.5 - this.screen.left ) / ( this.screen.width * 0.5 ) ),
  			( ( this.screen.height + 2 * ( this.screen.top - pageY ) ) / this.screen.width ) // screen.width intentional
  		);

  		return _v2;

  	}

  	_addPointer( event ) {

  		this._pointers.push( event );

  	}

  	_removePointer( event ) {

  		delete this._pointerPositions[ event.pointerId ];

  		for ( let i = 0; i < this._pointers.length; i ++ ) {

  			if ( this._pointers[ i ].pointerId == event.pointerId ) {

  				this._pointers.splice( i, 1 );
  				return;

  			}

  		}

  	}

  	_trackPointer( event ) {

  		let position = this._pointerPositions[ event.pointerId ];

  		if ( position === undefined ) {

  			position = new three$1.Vector2();
  			this._pointerPositions[ event.pointerId ] = position;

  		}

  		position.set( event.pageX, event.pageY );

  	}

  	_getSecondPointerPosition( event ) {

  		const pointer = ( event.pointerId === this._pointers[ 0 ].pointerId ) ? this._pointers[ 1 ] : this._pointers[ 0 ];

  		return this._pointerPositions[ pointer.pointerId ];

  	}

  	_checkDistances() {

  		if ( ! this.noZoom || ! this.noPan ) {

  			if ( this._eye.lengthSq() > this.maxDistance * this.maxDistance ) {

  				this.object.position.addVectors( this.target, this._eye.setLength( this.maxDistance ) );
  				this._zoomStart.copy( this._zoomEnd );

  			}

  			if ( this._eye.lengthSq() < this.minDistance * this.minDistance ) {

  				this.object.position.addVectors( this.target, this._eye.setLength( this.minDistance ) );
  				this._zoomStart.copy( this._zoomEnd );

  			}

  		}

  	}

  }

  function onPointerDown$2( event ) {

  	if ( this.enabled === false ) return;

  	if ( this._pointers.length === 0 ) {

  		this.domElement.setPointerCapture( event.pointerId );

  		this.domElement.addEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.addEventListener( 'pointerup', this._onPointerUp );

  	}

  	//

  	this._addPointer( event );

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchStart( event );

  	} else {

  		this._onMouseDown( event );

  	}

  }

  function onPointerMove$2( event ) {

  	if ( this.enabled === false ) return;

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchMove( event );

  	} else {

  		this._onMouseMove( event );

  	}

  }

  function onPointerUp$2( event ) {

  	if ( this.enabled === false ) return;

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchEnd( event );

  	} else {

  		this._onMouseUp();

  	}

  	//

  	this._removePointer( event );

  	if ( this._pointers.length === 0 ) {

  		this.domElement.releasePointerCapture( event.pointerId );

  		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );

  	}

  }

  function onPointerCancel$1( event ) {

  	this._removePointer( event );

  }

  function onKeyUp$1() {

  	if ( this.enabled === false ) return;

  	this.keyState = _STATE$1.NONE;

  	window.addEventListener( 'keydown', this._onKeyDown );

  }

  function onKeyDown$2( event ) {

  	if ( this.enabled === false ) return;

  	window.removeEventListener( 'keydown', this._onKeyDown );

  	if ( this.keyState !== _STATE$1.NONE ) {

  		return;

  	} else if ( event.code === this.keys[ _STATE$1.ROTATE ] && ! this.noRotate ) {

  		this.keyState = _STATE$1.ROTATE;

  	} else if ( event.code === this.keys[ _STATE$1.ZOOM ] && ! this.noZoom ) {

  		this.keyState = _STATE$1.ZOOM;

  	} else if ( event.code === this.keys[ _STATE$1.PAN ] && ! this.noPan ) {

  		this.keyState = _STATE$1.PAN;

  	}

  }

  function onMouseDown$1( event ) {

  	let mouseAction;

  	switch ( event.button ) {

  		case 0:
  			mouseAction = this.mouseButtons.LEFT;
  			break;

  		case 1:
  			mouseAction = this.mouseButtons.MIDDLE;
  			break;

  		case 2:
  			mouseAction = this.mouseButtons.RIGHT;
  			break;

  		default:
  			mouseAction = - 1;

  	}

  	switch ( mouseAction ) {

  		case three$1.MOUSE.DOLLY:
  			this.state = _STATE$1.ZOOM;
  			break;

  		case three$1.MOUSE.ROTATE:
  			this.state = _STATE$1.ROTATE;
  			break;

  		case three$1.MOUSE.PAN:
  			this.state = _STATE$1.PAN;
  			break;

  		default:
  			this.state = _STATE$1.NONE;

  	}

  	const state = ( this.keyState !== _STATE$1.NONE ) ? this.keyState : this.state;

  	if ( state === _STATE$1.ROTATE && ! this.noRotate ) {

  		this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );
  		this._movePrev.copy( this._moveCurr );

  	} else if ( state === _STATE$1.ZOOM && ! this.noZoom ) {

  		this._zoomStart.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );
  		this._zoomEnd.copy( this._zoomStart );

  	} else if ( state === _STATE$1.PAN && ! this.noPan ) {

  		this._panStart.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );
  		this._panEnd.copy( this._panStart );

  	}

  	this.dispatchEvent( _startEvent$1 );

  }

  function onMouseMove$1( event ) {

  	const state = ( this.keyState !== _STATE$1.NONE ) ? this.keyState : this.state;

  	if ( state === _STATE$1.ROTATE && ! this.noRotate ) {

  		this._movePrev.copy( this._moveCurr );
  		this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );

  	} else if ( state === _STATE$1.ZOOM && ! this.noZoom ) {

  		this._zoomEnd.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );

  	} else if ( state === _STATE$1.PAN && ! this.noPan ) {

  		this._panEnd.copy( this._getMouseOnScreen( event.pageX, event.pageY ) );

  	}

  }

  function onMouseUp() {

  	this.state = _STATE$1.NONE;

  	this.dispatchEvent( _endEvent$1 );

  }

  function onMouseWheel$1( event ) {

  	if ( this.enabled === false ) return;

  	if ( this.noZoom === true ) return;

  	event.preventDefault();

  	switch ( event.deltaMode ) {

  		case 2:
  			// Zoom in pages
  			this._zoomStart.y -= event.deltaY * 0.025;
  			break;

  		case 1:
  			// Zoom in lines
  			this._zoomStart.y -= event.deltaY * 0.01;
  			break;

  		default:
  			// undefined, 0, assume pixels
  			this._zoomStart.y -= event.deltaY * 0.00025;
  			break;

  	}

  	this.dispatchEvent( _startEvent$1 );
  	this.dispatchEvent( _endEvent$1 );

  }

  function onContextMenu$2( event ) {

  	if ( this.enabled === false ) return;

  	event.preventDefault();

  }

  function onTouchStart$1( event ) {

  	this._trackPointer( event );

  	switch ( this._pointers.length ) {

  		case 1:
  			this.state = _STATE$1.TOUCH_ROTATE;
  			this._moveCurr.copy( this._getMouseOnCircle( this._pointers[ 0 ].pageX, this._pointers[ 0 ].pageY ) );
  			this._movePrev.copy( this._moveCurr );
  			break;

  		default: // 2 or more
  			this.state = _STATE$1.TOUCH_ZOOM_PAN;
  			const dx = this._pointers[ 0 ].pageX - this._pointers[ 1 ].pageX;
  			const dy = this._pointers[ 0 ].pageY - this._pointers[ 1 ].pageY;
  			this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

  			const x = ( this._pointers[ 0 ].pageX + this._pointers[ 1 ].pageX ) / 2;
  			const y = ( this._pointers[ 0 ].pageY + this._pointers[ 1 ].pageY ) / 2;
  			this._panStart.copy( this._getMouseOnScreen( x, y ) );
  			this._panEnd.copy( this._panStart );
  			break;

  	}

  	this.dispatchEvent( _startEvent$1 );

  }

  function onTouchMove$1( event ) {

  	this._trackPointer( event );

  	switch ( this._pointers.length ) {

  		case 1:
  			this._movePrev.copy( this._moveCurr );
  			this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );
  			break;

  		default: // 2 or more

  			const position = this._getSecondPointerPosition( event );

  			const dx = event.pageX - position.x;
  			const dy = event.pageY - position.y;
  			this._touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

  			const x = ( event.pageX + position.x ) / 2;
  			const y = ( event.pageY + position.y ) / 2;
  			this._panEnd.copy( this._getMouseOnScreen( x, y ) );
  			break;

  	}

  }

  function onTouchEnd( event ) {

  	switch ( this._pointers.length ) {

  		case 0:
  			this.state = _STATE$1.NONE;
  			break;

  		case 1:
  			this.state = _STATE$1.TOUCH_ROTATE;
  			this._moveCurr.copy( this._getMouseOnCircle( event.pageX, event.pageY ) );
  			this._movePrev.copy( this._moveCurr );
  			break;

  		case 2:
  			this.state = _STATE$1.TOUCH_ZOOM_PAN;

  			for ( let i = 0; i < this._pointers.length; i ++ ) {

  				if ( this._pointers[ i ].pointerId !== event.pointerId ) {

  					const position = this._pointerPositions[ this._pointers[ i ].pointerId ];
  					this._moveCurr.copy( this._getMouseOnCircle( position.x, position.y ) );
  					this._movePrev.copy( this._moveCurr );
  					break;

  				}

  			}

  			break;

  	}

  	this.dispatchEvent( _endEvent$1 );

  }

  // OrbitControls performs orbiting, dollying (zooming), and panning.
  // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
  //
  //    Orbit - left mouse / touch: one-finger move
  //    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
  //    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

  const _changeEvent$1 = { type: 'change' };
  const _startEvent = { type: 'start' };
  const _endEvent = { type: 'end' };
  const _ray = new three$1.Ray();
  const _plane = new three$1.Plane();
  const _TILT_LIMIT = Math.cos( 70 * three$1.MathUtils.DEG2RAD );

  const _v = new three$1.Vector3();
  const _twoPI = 2 * Math.PI;

  const _STATE = {
  	NONE: - 1,
  	ROTATE: 0,
  	DOLLY: 1,
  	PAN: 2,
  	TOUCH_ROTATE: 3,
  	TOUCH_PAN: 4,
  	TOUCH_DOLLY_PAN: 5,
  	TOUCH_DOLLY_ROTATE: 6
  };
  const _EPS$1 = 0.000001;

  class OrbitControls extends three$1.Controls {

  	constructor( object, domElement = null ) {

  		super( object, domElement );

  		this.state = _STATE.NONE;

  		// Set to false to disable this control
  		this.enabled = true;

  		// "target" sets the location of focus, where the object orbits around
  		this.target = new three$1.Vector3();

  		// Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect
  		this.cursor = new three$1.Vector3();

  		// How far you can dolly in and out ( PerspectiveCamera only )
  		this.minDistance = 0;
  		this.maxDistance = Infinity;

  		// How far you can zoom in and out ( OrthographicCamera only )
  		this.minZoom = 0;
  		this.maxZoom = Infinity;

  		// Limit camera target within a spherical area around the cursor
  		this.minTargetRadius = 0;
  		this.maxTargetRadius = Infinity;

  		// How far you can orbit vertically, upper and lower limits.
  		// Range is 0 to Math.PI radians.
  		this.minPolarAngle = 0; // radians
  		this.maxPolarAngle = Math.PI; // radians

  		// How far you can orbit horizontally, upper and lower limits.
  		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
  		this.minAzimuthAngle = - Infinity; // radians
  		this.maxAzimuthAngle = Infinity; // radians

  		// Set to true to enable damping (inertia)
  		// If damping is enabled, you must call controls.update() in your animation loop
  		this.enableDamping = false;
  		this.dampingFactor = 0.05;

  		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  		// Set to false to disable zooming
  		this.enableZoom = true;
  		this.zoomSpeed = 1.0;

  		// Set to false to disable rotating
  		this.enableRotate = true;
  		this.rotateSpeed = 1.0;

  		// Set to false to disable panning
  		this.enablePan = true;
  		this.panSpeed = 1.0;
  		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
  		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push
  		this.zoomToCursor = false;

  		// Set to true to automatically rotate around the target
  		// If auto-rotate is enabled, you must call controls.update() in your animation loop
  		this.autoRotate = false;
  		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

  		// The four arrow keys
  		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

  		// Mouse buttons
  		this.mouseButtons = { LEFT: three$1.MOUSE.ROTATE, MIDDLE: three$1.MOUSE.DOLLY, RIGHT: three$1.MOUSE.PAN };

  		// Touch fingers
  		this.touches = { ONE: three$1.TOUCH.ROTATE, TWO: three$1.TOUCH.DOLLY_PAN };

  		// for reset
  		this.target0 = this.target.clone();
  		this.position0 = this.object.position.clone();
  		this.zoom0 = this.object.zoom;

  		// the target DOM element for key events
  		this._domElementKeyEvents = null;

  		// internals

  		this._lastPosition = new three$1.Vector3();
  		this._lastQuaternion = new three$1.Quaternion();
  		this._lastTargetPosition = new three$1.Vector3();

  		// so camera.up is the orbit axis
  		this._quat = new three$1.Quaternion().setFromUnitVectors( object.up, new three$1.Vector3( 0, 1, 0 ) );
  		this._quatInverse = this._quat.clone().invert();

  		// current position in spherical coordinates
  		this._spherical = new three$1.Spherical();
  		this._sphericalDelta = new three$1.Spherical();

  		this._scale = 1;
  		this._panOffset = new three$1.Vector3();

  		this._rotateStart = new three$1.Vector2();
  		this._rotateEnd = new three$1.Vector2();
  		this._rotateDelta = new three$1.Vector2();

  		this._panStart = new three$1.Vector2();
  		this._panEnd = new three$1.Vector2();
  		this._panDelta = new three$1.Vector2();

  		this._dollyStart = new three$1.Vector2();
  		this._dollyEnd = new three$1.Vector2();
  		this._dollyDelta = new three$1.Vector2();

  		this._dollyDirection = new three$1.Vector3();
  		this._mouse = new three$1.Vector2();
  		this._performCursorZoom = false;

  		this._pointers = [];
  		this._pointerPositions = {};

  		this._controlActive = false;

  		// event listeners

  		this._onPointerMove = onPointerMove$1.bind( this );
  		this._onPointerDown = onPointerDown$1.bind( this );
  		this._onPointerUp = onPointerUp$1.bind( this );
  		this._onContextMenu = onContextMenu$1.bind( this );
  		this._onMouseWheel = onMouseWheel.bind( this );
  		this._onKeyDown = onKeyDown$1.bind( this );

  		this._onTouchStart = onTouchStart.bind( this );
  		this._onTouchMove = onTouchMove.bind( this );

  		this._onMouseDown = onMouseDown.bind( this );
  		this._onMouseMove = onMouseMove.bind( this );

  		this._interceptControlDown = interceptControlDown.bind( this );
  		this._interceptControlUp = interceptControlUp.bind( this );

  		//

  		if ( this.domElement !== null ) {

  			this.connect();

  		}

  		this.update();

  	}

  	connect() {

  		this.domElement.addEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.addEventListener( 'pointercancel', this._onPointerUp );

  		this.domElement.addEventListener( 'contextmenu', this._onContextMenu );
  		this.domElement.addEventListener( 'wheel', this._onMouseWheel, { passive: false } );

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility
  		document.addEventListener( 'keydown', this._interceptControlDown, { passive: true, capture: true } );

  		this.domElement.style.touchAction = 'none'; // disable touch scroll

  	}

  	disconnect() {

  		this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );
  		this.domElement.removeEventListener( 'pointercancel', this._onPointerUp );

  		this.domElement.removeEventListener( 'wheel', this._onMouseWheel );
  		this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );

  		this.stopListenToKeyEvents();

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility
  		document.removeEventListener( 'keydown', this._interceptControlDown, { capture: true } );

  		this.domElement.style.touchAction = 'auto';

  	}

  	dispose() {

  		this.disconnect();

  	}

  	getPolarAngle() {

  		return this._spherical.phi;

  	}

  	getAzimuthalAngle() {

  		return this._spherical.theta;

  	}

  	getDistance() {

  		return this.object.position.distanceTo( this.target );

  	}

  	listenToKeyEvents( domElement ) {

  		domElement.addEventListener( 'keydown', this._onKeyDown );
  		this._domElementKeyEvents = domElement;

  	}

  	stopListenToKeyEvents() {

  		if ( this._domElementKeyEvents !== null ) {

  			this._domElementKeyEvents.removeEventListener( 'keydown', this._onKeyDown );
  			this._domElementKeyEvents = null;

  		}

  	}

  	saveState() {

  		this.target0.copy( this.target );
  		this.position0.copy( this.object.position );
  		this.zoom0 = this.object.zoom;

  	}

  	reset() {

  		this.target.copy( this.target0 );
  		this.object.position.copy( this.position0 );
  		this.object.zoom = this.zoom0;

  		this.object.updateProjectionMatrix();
  		this.dispatchEvent( _changeEvent$1 );

  		this.update();

  		this.state = _STATE.NONE;

  	}

  	update( deltaTime = null ) {

  		const position = this.object.position;

  		_v.copy( position ).sub( this.target );

  		// rotate offset to "y-axis-is-up" space
  		_v.applyQuaternion( this._quat );

  		// angle from z-axis around y-axis
  		this._spherical.setFromVector3( _v );

  		if ( this.autoRotate && this.state === _STATE.NONE ) {

  			this._rotateLeft( this._getAutoRotationAngle( deltaTime ) );

  		}

  		if ( this.enableDamping ) {

  			this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
  			this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;

  		} else {

  			this._spherical.theta += this._sphericalDelta.theta;
  			this._spherical.phi += this._sphericalDelta.phi;

  		}

  		// restrict theta to be between desired limits

  		let min = this.minAzimuthAngle;
  		let max = this.maxAzimuthAngle;

  		if ( isFinite( min ) && isFinite( max ) ) {

  			if ( min < - Math.PI ) min += _twoPI; else if ( min > Math.PI ) min -= _twoPI;

  			if ( max < - Math.PI ) max += _twoPI; else if ( max > Math.PI ) max -= _twoPI;

  			if ( min <= max ) {

  				this._spherical.theta = Math.max( min, Math.min( max, this._spherical.theta ) );

  			} else {

  				this._spherical.theta = ( this._spherical.theta > ( min + max ) / 2 ) ?
  					Math.max( min, this._spherical.theta ) :
  					Math.min( max, this._spherical.theta );

  			}

  		}

  		// restrict phi to be between desired limits
  		this._spherical.phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, this._spherical.phi ) );

  		this._spherical.makeSafe();


  		// move target to panned location

  		if ( this.enableDamping === true ) {

  			this.target.addScaledVector( this._panOffset, this.dampingFactor );

  		} else {

  			this.target.add( this._panOffset );

  		}

  		// Limit the target distance from the cursor to create a sphere around the center of interest
  		this.target.sub( this.cursor );
  		this.target.clampLength( this.minTargetRadius, this.maxTargetRadius );
  		this.target.add( this.cursor );

  		let zoomChanged = false;
  		// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
  		// we adjust zoom later in these cases
  		if ( this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera ) {

  			this._spherical.radius = this._clampDistance( this._spherical.radius );

  		} else {

  			const prevRadius = this._spherical.radius;
  			this._spherical.radius = this._clampDistance( this._spherical.radius * this._scale );
  			zoomChanged = prevRadius != this._spherical.radius;

  		}

  		_v.setFromSpherical( this._spherical );

  		// rotate offset back to "camera-up-vector-is-up" space
  		_v.applyQuaternion( this._quatInverse );

  		position.copy( this.target ).add( _v );

  		this.object.lookAt( this.target );

  		if ( this.enableDamping === true ) {

  			this._sphericalDelta.theta *= ( 1 - this.dampingFactor );
  			this._sphericalDelta.phi *= ( 1 - this.dampingFactor );

  			this._panOffset.multiplyScalar( 1 - this.dampingFactor );

  		} else {

  			this._sphericalDelta.set( 0, 0, 0 );

  			this._panOffset.set( 0, 0, 0 );

  		}

  		// adjust camera position
  		if ( this.zoomToCursor && this._performCursorZoom ) {

  			let newRadius = null;
  			if ( this.object.isPerspectiveCamera ) {

  				// move the camera down the pointer ray
  				// this method avoids floating point error
  				const prevRadius = _v.length();
  				newRadius = this._clampDistance( prevRadius * this._scale );

  				const radiusDelta = prevRadius - newRadius;
  				this.object.position.addScaledVector( this._dollyDirection, radiusDelta );
  				this.object.updateMatrixWorld();

  				zoomChanged = !! radiusDelta;

  			} else if ( this.object.isOrthographicCamera ) {

  				// adjust the ortho camera position based on zoom changes
  				const mouseBefore = new three$1.Vector3( this._mouse.x, this._mouse.y, 0 );
  				mouseBefore.unproject( this.object );

  				const prevZoom = this.object.zoom;
  				this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );
  				this.object.updateProjectionMatrix();

  				zoomChanged = prevZoom !== this.object.zoom;

  				const mouseAfter = new three$1.Vector3( this._mouse.x, this._mouse.y, 0 );
  				mouseAfter.unproject( this.object );

  				this.object.position.sub( mouseAfter ).add( mouseBefore );
  				this.object.updateMatrixWorld();

  				newRadius = _v.length();

  			} else {

  				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );
  				this.zoomToCursor = false;

  			}

  			// handle the placement of the target
  			if ( newRadius !== null ) {

  				if ( this.screenSpacePanning ) {

  					// position the orbit target in front of the new camera position
  					this.target.set( 0, 0, - 1 )
  						.transformDirection( this.object.matrix )
  						.multiplyScalar( newRadius )
  						.add( this.object.position );

  				} else {

  					// get the ray and translation plane to compute target
  					_ray.origin.copy( this.object.position );
  					_ray.direction.set( 0, 0, - 1 ).transformDirection( this.object.matrix );

  					// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
  					// extremely large values
  					if ( Math.abs( this.object.up.dot( _ray.direction ) ) < _TILT_LIMIT ) {

  						this.object.lookAt( this.target );

  					} else {

  						_plane.setFromNormalAndCoplanarPoint( this.object.up, this.target );
  						_ray.intersectPlane( _plane, this.target );

  					}

  				}

  			}

  		} else if ( this.object.isOrthographicCamera ) {

  			const prevZoom = this.object.zoom;
  			this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );

  			if ( prevZoom !== this.object.zoom ) {

  				this.object.updateProjectionMatrix();
  				zoomChanged = true;

  			}

  		}

  		this._scale = 1;
  		this._performCursorZoom = false;

  		// update condition is:
  		// min(camera displacement, camera rotation in radians)^2 > EPS
  		// using small-angle approximation cos(x/2) = 1 - x^2 / 8

  		if ( zoomChanged ||
  			this._lastPosition.distanceToSquared( this.object.position ) > _EPS$1 ||
  			8 * ( 1 - this._lastQuaternion.dot( this.object.quaternion ) ) > _EPS$1 ||
  			this._lastTargetPosition.distanceToSquared( this.target ) > _EPS$1 ) {

  			this.dispatchEvent( _changeEvent$1 );

  			this._lastPosition.copy( this.object.position );
  			this._lastQuaternion.copy( this.object.quaternion );
  			this._lastTargetPosition.copy( this.target );

  			return true;

  		}

  		return false;

  	}

  	_getAutoRotationAngle( deltaTime ) {

  		if ( deltaTime !== null ) {

  			return ( _twoPI / 60 * this.autoRotateSpeed ) * deltaTime;

  		} else {

  			return _twoPI / 60 / 60 * this.autoRotateSpeed;

  		}

  	}

  	_getZoomScale( delta ) {

  		const normalizedDelta = Math.abs( delta * 0.01 );
  		return Math.pow( 0.95, this.zoomSpeed * normalizedDelta );

  	}

  	_rotateLeft( angle ) {

  		this._sphericalDelta.theta -= angle;

  	}

  	_rotateUp( angle ) {

  		this._sphericalDelta.phi -= angle;

  	}

  	_panLeft( distance, objectMatrix ) {

  		_v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
  		_v.multiplyScalar( - distance );

  		this._panOffset.add( _v );

  	}

  	_panUp( distance, objectMatrix ) {

  		if ( this.screenSpacePanning === true ) {

  			_v.setFromMatrixColumn( objectMatrix, 1 );

  		} else {

  			_v.setFromMatrixColumn( objectMatrix, 0 );
  			_v.crossVectors( this.object.up, _v );

  		}

  		_v.multiplyScalar( distance );

  		this._panOffset.add( _v );

  	}

  	// deltaX and deltaY are in pixels; right and down are positive
  	_pan( deltaX, deltaY ) {

  		const element = this.domElement;

  		if ( this.object.isPerspectiveCamera ) {

  			// perspective
  			const position = this.object.position;
  			_v.copy( position ).sub( this.target );
  			let targetDistance = _v.length();

  			// half of the fov is center to top of screen
  			targetDistance *= Math.tan( ( this.object.fov / 2 ) * Math.PI / 180.0 );

  			// we use only clientHeight here so aspect ratio does not distort speed
  			this._panLeft( 2 * deltaX * targetDistance / element.clientHeight, this.object.matrix );
  			this._panUp( 2 * deltaY * targetDistance / element.clientHeight, this.object.matrix );

  		} else if ( this.object.isOrthographicCamera ) {

  			// orthographic
  			this._panLeft( deltaX * ( this.object.right - this.object.left ) / this.object.zoom / element.clientWidth, this.object.matrix );
  			this._panUp( deltaY * ( this.object.top - this.object.bottom ) / this.object.zoom / element.clientHeight, this.object.matrix );

  		} else {

  			// camera neither orthographic nor perspective
  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
  			this.enablePan = false;

  		}

  	}

  	_dollyOut( dollyScale ) {

  		if ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {

  			this._scale /= dollyScale;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			this.enableZoom = false;

  		}

  	}

  	_dollyIn( dollyScale ) {

  		if ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {

  			this._scale *= dollyScale;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			this.enableZoom = false;

  		}

  	}

  	_updateZoomParameters( x, y ) {

  		if ( ! this.zoomToCursor ) {

  			return;

  		}

  		this._performCursorZoom = true;

  		const rect = this.domElement.getBoundingClientRect();
  		const dx = x - rect.left;
  		const dy = y - rect.top;
  		const w = rect.width;
  		const h = rect.height;

  		this._mouse.x = ( dx / w ) * 2 - 1;
  		this._mouse.y = - ( dy / h ) * 2 + 1;

  		this._dollyDirection.set( this._mouse.x, this._mouse.y, 1 ).unproject( this.object ).sub( this.object.position ).normalize();

  	}

  	_clampDistance( dist ) {

  		return Math.max( this.minDistance, Math.min( this.maxDistance, dist ) );

  	}

  	//
  	// event callbacks - update the object state
  	//

  	_handleMouseDownRotate( event ) {

  		this._rotateStart.set( event.clientX, event.clientY );

  	}

  	_handleMouseDownDolly( event ) {

  		this._updateZoomParameters( event.clientX, event.clientX );
  		this._dollyStart.set( event.clientX, event.clientY );

  	}

  	_handleMouseDownPan( event ) {

  		this._panStart.set( event.clientX, event.clientY );

  	}

  	_handleMouseMoveRotate( event ) {

  		this._rotateEnd.set( event.clientX, event.clientY );

  		this._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );

  		const element = this.domElement;

  		this._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height

  		this._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );

  		this._rotateStart.copy( this._rotateEnd );

  		this.update();

  	}

  	_handleMouseMoveDolly( event ) {

  		this._dollyEnd.set( event.clientX, event.clientY );

  		this._dollyDelta.subVectors( this._dollyEnd, this._dollyStart );

  		if ( this._dollyDelta.y > 0 ) {

  			this._dollyOut( this._getZoomScale( this._dollyDelta.y ) );

  		} else if ( this._dollyDelta.y < 0 ) {

  			this._dollyIn( this._getZoomScale( this._dollyDelta.y ) );

  		}

  		this._dollyStart.copy( this._dollyEnd );

  		this.update();

  	}

  	_handleMouseMovePan( event ) {

  		this._panEnd.set( event.clientX, event.clientY );

  		this._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );

  		this._pan( this._panDelta.x, this._panDelta.y );

  		this._panStart.copy( this._panEnd );

  		this.update();

  	}

  	_handleMouseWheel( event ) {

  		this._updateZoomParameters( event.clientX, event.clientY );

  		if ( event.deltaY < 0 ) {

  			this._dollyIn( this._getZoomScale( event.deltaY ) );

  		} else if ( event.deltaY > 0 ) {

  			this._dollyOut( this._getZoomScale( event.deltaY ) );

  		}

  		this.update();

  	}

  	_handleKeyDown( event ) {

  		let needsUpdate = false;

  		switch ( event.code ) {

  			case this.keys.UP:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					this._rotateUp( _twoPI * this.rotateSpeed / this.domElement.clientHeight );

  				} else {

  					this._pan( 0, this.keyPanSpeed );

  				}

  				needsUpdate = true;
  				break;

  			case this.keys.BOTTOM:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					this._rotateUp( - _twoPI * this.rotateSpeed / this.domElement.clientHeight );

  				} else {

  					this._pan( 0, - this.keyPanSpeed );

  				}

  				needsUpdate = true;
  				break;

  			case this.keys.LEFT:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					this._rotateLeft( _twoPI * this.rotateSpeed / this.domElement.clientHeight );

  				} else {

  					this._pan( this.keyPanSpeed, 0 );

  				}

  				needsUpdate = true;
  				break;

  			case this.keys.RIGHT:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					this._rotateLeft( - _twoPI * this.rotateSpeed / this.domElement.clientHeight );

  				} else {

  					this._pan( - this.keyPanSpeed, 0 );

  				}

  				needsUpdate = true;
  				break;

  		}

  		if ( needsUpdate ) {

  			// prevent the browser from scrolling on cursor keys
  			event.preventDefault();

  			this.update();

  		}


  	}

  	_handleTouchStartRotate( event ) {

  		if ( this._pointers.length === 1 ) {

  			this._rotateStart.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._rotateStart.set( x, y );

  		}

  	}

  	_handleTouchStartPan( event ) {

  		if ( this._pointers.length === 1 ) {

  			this._panStart.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._panStart.set( x, y );

  		}

  	}

  	_handleTouchStartDolly( event ) {

  		const position = this._getSecondPointerPosition( event );

  		const dx = event.pageX - position.x;
  		const dy = event.pageY - position.y;

  		const distance = Math.sqrt( dx * dx + dy * dy );

  		this._dollyStart.set( 0, distance );

  	}

  	_handleTouchStartDollyPan( event ) {

  		if ( this.enableZoom ) this._handleTouchStartDolly( event );

  		if ( this.enablePan ) this._handleTouchStartPan( event );

  	}

  	_handleTouchStartDollyRotate( event ) {

  		if ( this.enableZoom ) this._handleTouchStartDolly( event );

  		if ( this.enableRotate ) this._handleTouchStartRotate( event );

  	}

  	_handleTouchMoveRotate( event ) {

  		if ( this._pointers.length == 1 ) {

  			this._rotateEnd.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._rotateEnd.set( x, y );

  		}

  		this._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );

  		const element = this.domElement;

  		this._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height

  		this._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );

  		this._rotateStart.copy( this._rotateEnd );

  	}

  	_handleTouchMovePan( event ) {

  		if ( this._pointers.length === 1 ) {

  			this._panEnd.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._panEnd.set( x, y );

  		}

  		this._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );

  		this._pan( this._panDelta.x, this._panDelta.y );

  		this._panStart.copy( this._panEnd );

  	}

  	_handleTouchMoveDolly( event ) {

  		const position = this._getSecondPointerPosition( event );

  		const dx = event.pageX - position.x;
  		const dy = event.pageY - position.y;

  		const distance = Math.sqrt( dx * dx + dy * dy );

  		this._dollyEnd.set( 0, distance );

  		this._dollyDelta.set( 0, Math.pow( this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed ) );

  		this._dollyOut( this._dollyDelta.y );

  		this._dollyStart.copy( this._dollyEnd );

  		const centerX = ( event.pageX + position.x ) * 0.5;
  		const centerY = ( event.pageY + position.y ) * 0.5;

  		this._updateZoomParameters( centerX, centerY );

  	}

  	_handleTouchMoveDollyPan( event ) {

  		if ( this.enableZoom ) this._handleTouchMoveDolly( event );

  		if ( this.enablePan ) this._handleTouchMovePan( event );

  	}

  	_handleTouchMoveDollyRotate( event ) {

  		if ( this.enableZoom ) this._handleTouchMoveDolly( event );

  		if ( this.enableRotate ) this._handleTouchMoveRotate( event );

  	}

  	// pointers

  	_addPointer( event ) {

  		this._pointers.push( event.pointerId );

  	}

  	_removePointer( event ) {

  		delete this._pointerPositions[ event.pointerId ];

  		for ( let i = 0; i < this._pointers.length; i ++ ) {

  			if ( this._pointers[ i ] == event.pointerId ) {

  				this._pointers.splice( i, 1 );
  				return;

  			}

  		}

  	}

  	_isTrackingPointer( event ) {

  		for ( let i = 0; i < this._pointers.length; i ++ ) {

  			if ( this._pointers[ i ] == event.pointerId ) return true;

  		}

  		return false;

  	}

  	_trackPointer( event ) {

  		let position = this._pointerPositions[ event.pointerId ];

  		if ( position === undefined ) {

  			position = new three$1.Vector2();
  			this._pointerPositions[ event.pointerId ] = position;

  		}

  		position.set( event.pageX, event.pageY );

  	}

  	_getSecondPointerPosition( event ) {

  		const pointerId = ( event.pointerId === this._pointers[ 0 ] ) ? this._pointers[ 1 ] : this._pointers[ 0 ];

  		return this._pointerPositions[ pointerId ];

  	}

  	//

  	_customWheelEvent( event ) {

  		const mode = event.deltaMode;

  		// minimal wheel event altered to meet delta-zoom demand
  		const newEvent = {
  			clientX: event.clientX,
  			clientY: event.clientY,
  			deltaY: event.deltaY,
  		};

  		switch ( mode ) {

  			case 1: // LINE_MODE
  				newEvent.deltaY *= 16;
  				break;

  			case 2: // PAGE_MODE
  				newEvent.deltaY *= 100;
  				break;

  		}

  		// detect if event was triggered by pinching
  		if ( event.ctrlKey && ! this._controlActive ) {

  			newEvent.deltaY *= 10;

  		}

  		return newEvent;

  	}

  }

  function onPointerDown$1( event ) {

  	if ( this.enabled === false ) return;

  	if ( this._pointers.length === 0 ) {

  		this.domElement.setPointerCapture( event.pointerId );

  		this.domElement.addEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.addEventListener( 'pointerup', this._onPointerUp );

  	}

  	//

  	if ( this._isTrackingPointer( event ) ) return;

  	//

  	this._addPointer( event );

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchStart( event );

  	} else {

  		this._onMouseDown( event );

  	}

  }

  function onPointerMove$1( event ) {

  	if ( this.enabled === false ) return;

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchMove( event );

  	} else {

  		this._onMouseMove( event );

  	}

  }

  function onPointerUp$1( event ) {

  	this._removePointer( event );

  	switch ( this._pointers.length ) {

  		case 0:

  			this.domElement.releasePointerCapture( event.pointerId );

  			this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  			this.domElement.removeEventListener( 'pointerup', this._onPointerUp );

  			this.dispatchEvent( _endEvent );

  			this.state = _STATE.NONE;

  			break;

  		case 1:

  			const pointerId = this._pointers[ 0 ];
  			const position = this._pointerPositions[ pointerId ];

  			// minimal placeholder event - allows state correction on pointer-up
  			this._onTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );

  			break;

  	}

  }

  function onMouseDown( event ) {

  	let mouseAction;

  	switch ( event.button ) {

  		case 0:

  			mouseAction = this.mouseButtons.LEFT;
  			break;

  		case 1:

  			mouseAction = this.mouseButtons.MIDDLE;
  			break;

  		case 2:

  			mouseAction = this.mouseButtons.RIGHT;
  			break;

  		default:

  			mouseAction = - 1;

  	}

  	switch ( mouseAction ) {

  		case three$1.MOUSE.DOLLY:

  			if ( this.enableZoom === false ) return;

  			this._handleMouseDownDolly( event );

  			this.state = _STATE.DOLLY;

  			break;

  		case three$1.MOUSE.ROTATE:

  			if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  				if ( this.enablePan === false ) return;

  				this._handleMouseDownPan( event );

  				this.state = _STATE.PAN;

  			} else {

  				if ( this.enableRotate === false ) return;

  				this._handleMouseDownRotate( event );

  				this.state = _STATE.ROTATE;

  			}

  			break;

  		case three$1.MOUSE.PAN:

  			if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  				if ( this.enableRotate === false ) return;

  				this._handleMouseDownRotate( event );

  				this.state = _STATE.ROTATE;

  			} else {

  				if ( this.enablePan === false ) return;

  				this._handleMouseDownPan( event );

  				this.state = _STATE.PAN;

  			}

  			break;

  		default:

  			this.state = _STATE.NONE;

  	}

  	if ( this.state !== _STATE.NONE ) {

  		this.dispatchEvent( _startEvent );

  	}

  }

  function onMouseMove( event ) {

  	switch ( this.state ) {

  		case _STATE.ROTATE:

  			if ( this.enableRotate === false ) return;

  			this._handleMouseMoveRotate( event );

  			break;

  		case _STATE.DOLLY:

  			if ( this.enableZoom === false ) return;

  			this._handleMouseMoveDolly( event );

  			break;

  		case _STATE.PAN:

  			if ( this.enablePan === false ) return;

  			this._handleMouseMovePan( event );

  			break;

  	}

  }

  function onMouseWheel( event ) {

  	if ( this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE ) return;

  	event.preventDefault();

  	this.dispatchEvent( _startEvent );

  	this._handleMouseWheel( this._customWheelEvent( event ) );

  	this.dispatchEvent( _endEvent );

  }

  function onKeyDown$1( event ) {

  	if ( this.enabled === false || this.enablePan === false ) return;

  	this._handleKeyDown( event );

  }

  function onTouchStart( event ) {

  	this._trackPointer( event );

  	switch ( this._pointers.length ) {

  		case 1:

  			switch ( this.touches.ONE ) {

  				case three$1.TOUCH.ROTATE:

  					if ( this.enableRotate === false ) return;

  					this._handleTouchStartRotate( event );

  					this.state = _STATE.TOUCH_ROTATE;

  					break;

  				case three$1.TOUCH.PAN:

  					if ( this.enablePan === false ) return;

  					this._handleTouchStartPan( event );

  					this.state = _STATE.TOUCH_PAN;

  					break;

  				default:

  					this.state = _STATE.NONE;

  			}

  			break;

  		case 2:

  			switch ( this.touches.TWO ) {

  				case three$1.TOUCH.DOLLY_PAN:

  					if ( this.enableZoom === false && this.enablePan === false ) return;

  					this._handleTouchStartDollyPan( event );

  					this.state = _STATE.TOUCH_DOLLY_PAN;

  					break;

  				case three$1.TOUCH.DOLLY_ROTATE:

  					if ( this.enableZoom === false && this.enableRotate === false ) return;

  					this._handleTouchStartDollyRotate( event );

  					this.state = _STATE.TOUCH_DOLLY_ROTATE;

  					break;

  				default:

  					this.state = _STATE.NONE;

  			}

  			break;

  		default:

  			this.state = _STATE.NONE;

  	}

  	if ( this.state !== _STATE.NONE ) {

  		this.dispatchEvent( _startEvent );

  	}

  }

  function onTouchMove( event ) {

  	this._trackPointer( event );

  	switch ( this.state ) {

  		case _STATE.TOUCH_ROTATE:

  			if ( this.enableRotate === false ) return;

  			this._handleTouchMoveRotate( event );

  			this.update();

  			break;

  		case _STATE.TOUCH_PAN:

  			if ( this.enablePan === false ) return;

  			this._handleTouchMovePan( event );

  			this.update();

  			break;

  		case _STATE.TOUCH_DOLLY_PAN:

  			if ( this.enableZoom === false && this.enablePan === false ) return;

  			this._handleTouchMoveDollyPan( event );

  			this.update();

  			break;

  		case _STATE.TOUCH_DOLLY_ROTATE:

  			if ( this.enableZoom === false && this.enableRotate === false ) return;

  			this._handleTouchMoveDollyRotate( event );

  			this.update();

  			break;

  		default:

  			this.state = _STATE.NONE;

  	}

  }

  function onContextMenu$1( event ) {

  	if ( this.enabled === false ) return;

  	event.preventDefault();

  }

  function interceptControlDown( event ) {

  	if ( event.key === 'Control' ) {

  		this._controlActive = true;

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility

  		document.addEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );

  	}

  }

  function interceptControlUp( event ) {

  	if ( event.key === 'Control' ) {

  		this._controlActive = false;

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility

  		document.removeEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );

  	}

  }

  const _changeEvent = { type: 'change' };

  const _EPS = 0.000001;
  const _tmpQuaternion = new three$1.Quaternion();

  class FlyControls extends three$1.Controls {

  	constructor( object, domElement = null ) {

  		super( object, domElement );

  		this.movementSpeed = 1.0;
  		this.rollSpeed = 0.005;

  		this.dragToLook = false;
  		this.autoForward = false;

  		// internals

  		this._moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
  		this._moveVector = new three$1.Vector3( 0, 0, 0 );
  		this._rotationVector = new three$1.Vector3( 0, 0, 0 );
  		this._lastQuaternion = new three$1.Quaternion();
  		this._lastPosition = new three$1.Vector3();
  		this._status = 0;

  		// event listeners

  		this._onKeyDown = onKeyDown.bind( this );
  		this._onKeyUp = onKeyUp.bind( this );
  		this._onPointerMove = onPointerMove.bind( this );
  		this._onPointerDown = onPointerDown.bind( this );
  		this._onPointerUp = onPointerUp.bind( this );
  		this._onPointerCancel = onPointerCancel.bind( this );
  		this._onContextMenu = onContextMenu.bind( this );

  		//

  		if ( domElement !== null ) {

  			this.connect();

  		}

  	}

  	connect() {

  		window.addEventListener( 'keydown', this._onKeyDown );
  		window.addEventListener( 'keyup', this._onKeyUp );

  		this.domElement.addEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.addEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.addEventListener( 'pointerup', this._onPointerUp );
  		this.domElement.addEventListener( 'pointercancel', this._onPointerCancel );
  		this.domElement.addEventListener( 'contextmenu', this._onContextMenu );

  	}

  	disconnect() {

  		window.removeEventListener( 'keydown', this._onKeyDown );
  		window.removeEventListener( 'keyup', this._onKeyUp );

  		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );
  		this.domElement.removeEventListener( 'pointercancel', this._onPointerCancel );
  		this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );

  	}

  	dispose() {

  		this.disconnect();

  	}

  	update( delta ) {

  		if ( this.enabled === false ) return;

  		const object = this.object;

  		const moveMult = delta * this.movementSpeed;
  		const rotMult = delta * this.rollSpeed;

  		object.translateX( this._moveVector.x * moveMult );
  		object.translateY( this._moveVector.y * moveMult );
  		object.translateZ( this._moveVector.z * moveMult );

  		_tmpQuaternion.set( this._rotationVector.x * rotMult, this._rotationVector.y * rotMult, this._rotationVector.z * rotMult, 1 ).normalize();
  		object.quaternion.multiply( _tmpQuaternion );

  		if (
  			this._lastPosition.distanceToSquared( object.position ) > _EPS ||
  			8 * ( 1 - this._lastQuaternion.dot( object.quaternion ) ) > _EPS
  		) {

  			this.dispatchEvent( _changeEvent );
  			this._lastQuaternion.copy( object.quaternion );
  			this._lastPosition.copy( object.position );

  		}

  	}

  	// private

  	_updateMovementVector() {

  		const forward = ( this._moveState.forward || ( this.autoForward && ! this._moveState.back ) ) ? 1 : 0;

  		this._moveVector.x = ( - this._moveState.left + this._moveState.right );
  		this._moveVector.y = ( - this._moveState.down + this._moveState.up );
  		this._moveVector.z = ( - forward + this._moveState.back );

  		//console.log( 'move:', [ this._moveVector.x, this._moveVector.y, this._moveVector.z ] );

  	}

  	_updateRotationVector() {

  		this._rotationVector.x = ( - this._moveState.pitchDown + this._moveState.pitchUp );
  		this._rotationVector.y = ( - this._moveState.yawRight + this._moveState.yawLeft );
  		this._rotationVector.z = ( - this._moveState.rollRight + this._moveState.rollLeft );

  		//console.log( 'rotate:', [ this._rotationVector.x, this._rotationVector.y, this._rotationVector.z ] );

  	}

  	_getContainerDimensions() {

  		if ( this.domElement != document ) {

  			return {
  				size: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],
  				offset: [ this.domElement.offsetLeft, this.domElement.offsetTop ]
  			};

  		} else {

  			return {
  				size: [ window.innerWidth, window.innerHeight ],
  				offset: [ 0, 0 ]
  			};

  		}

  	}

  }

  function onKeyDown( event ) {

  	if ( event.altKey || this.enabled === false ) {

  		return;

  	}

  	switch ( event.code ) {

  		case 'ShiftLeft':
  		case 'ShiftRight': this.movementSpeedMultiplier = .1; break;

  		case 'KeyW': this._moveState.forward = 1; break;
  		case 'KeyS': this._moveState.back = 1; break;

  		case 'KeyA': this._moveState.left = 1; break;
  		case 'KeyD': this._moveState.right = 1; break;

  		case 'KeyR': this._moveState.up = 1; break;
  		case 'KeyF': this._moveState.down = 1; break;

  		case 'ArrowUp': this._moveState.pitchUp = 1; break;
  		case 'ArrowDown': this._moveState.pitchDown = 1; break;

  		case 'ArrowLeft': this._moveState.yawLeft = 1; break;
  		case 'ArrowRight': this._moveState.yawRight = 1; break;

  		case 'KeyQ': this._moveState.rollLeft = 1; break;
  		case 'KeyE': this._moveState.rollRight = 1; break;

  	}

  	this._updateMovementVector();
  	this._updateRotationVector();

  }

  function onKeyUp( event ) {

  	if ( this.enabled === false ) return;

  	switch ( event.code ) {

  		case 'ShiftLeft':
  		case 'ShiftRight': this.movementSpeedMultiplier = 1; break;

  		case 'KeyW': this._moveState.forward = 0; break;
  		case 'KeyS': this._moveState.back = 0; break;

  		case 'KeyA': this._moveState.left = 0; break;
  		case 'KeyD': this._moveState.right = 0; break;

  		case 'KeyR': this._moveState.up = 0; break;
  		case 'KeyF': this._moveState.down = 0; break;

  		case 'ArrowUp': this._moveState.pitchUp = 0; break;
  		case 'ArrowDown': this._moveState.pitchDown = 0; break;

  		case 'ArrowLeft': this._moveState.yawLeft = 0; break;
  		case 'ArrowRight': this._moveState.yawRight = 0; break;

  		case 'KeyQ': this._moveState.rollLeft = 0; break;
  		case 'KeyE': this._moveState.rollRight = 0; break;

  	}

  	this._updateMovementVector();
  	this._updateRotationVector();

  }

  function onPointerDown( event ) {

  	if ( this.enabled === false ) return;

  	if ( this.dragToLook ) {

  		this._status ++;

  	} else {

  		switch ( event.button ) {

  			case 0: this._moveState.forward = 1; break;
  			case 2: this._moveState.back = 1; break;

  		}

  		this._updateMovementVector();

  	}

  }

  function onPointerMove( event ) {

  	if ( this.enabled === false ) return;

  	if ( ! this.dragToLook || this._status > 0 ) {

  		const container = this._getContainerDimensions();
  		const halfWidth = container.size[ 0 ] / 2;
  		const halfHeight = container.size[ 1 ] / 2;

  		this._moveState.yawLeft = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth ) / halfWidth;
  		this._moveState.pitchDown = ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;

  		this._updateRotationVector();

  	}

  }

  function onPointerUp( event ) {

  	if ( this.enabled === false ) return;

  	if ( this.dragToLook ) {

  		this._status --;

  		this._moveState.yawLeft = this._moveState.pitchDown = 0;

  	} else {

  		switch ( event.button ) {

  			case 0: this._moveState.forward = 0; break;
  			case 2: this._moveState.back = 0; break;

  		}

  		this._updateMovementVector();

  	}

  	this._updateRotationVector();

  }

  function onPointerCancel() {

  	if ( this.enabled === false ) return;

  	if ( this.dragToLook ) {

  		this._status = 0;

  		this._moveState.yawLeft = this._moveState.pitchDown = 0;

  	} else {

  		this._moveState.forward = 0;
  		this._moveState.back = 0;

  		this._updateMovementVector();

  	}

  	this._updateRotationVector();

  }

  function onContextMenu( event ) {

  	if ( this.enabled === false ) return;

  	event.preventDefault();

  }

  /**
   * Full-screen textured quad shader
   */

  const CopyShader = {

  	name: 'CopyShader',

  	uniforms: {

  		'tDiffuse': { value: null },
  		'opacity': { value: 1.0 }

  	},

  	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

  	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`

  };

  class Pass {

  	constructor() {

  		this.isPass = true;

  		// if set to true, the pass is processed by the composer
  		this.enabled = true;

  		// if set to true, the pass indicates to swap read and write buffer after rendering
  		this.needsSwap = true;

  		// if set to true, the pass clears its buffer before rendering
  		this.clear = false;

  		// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
  		this.renderToScreen = false;

  	}

  	setSize( /* width, height */ ) {}

  	render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

  		console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

  	}

  	dispose() {}

  }

  // Helper for passes that need to fill the viewport with a single quad.

  const _camera = new three$1.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

  // https://github.com/mrdoob/three.js/pull/21358

  class FullscreenTriangleGeometry extends three$1.BufferGeometry {

  	constructor() {

  		super();

  		this.setAttribute( 'position', new three$1.Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
  		this.setAttribute( 'uv', new three$1.Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

  	}

  }

  const _geometry = new FullscreenTriangleGeometry();

  class FullScreenQuad {

  	constructor( material ) {

  		this._mesh = new three$1.Mesh( _geometry, material );

  	}

  	dispose() {

  		this._mesh.geometry.dispose();

  	}

  	render( renderer ) {

  		renderer.render( this._mesh, _camera );

  	}

  	get material() {

  		return this._mesh.material;

  	}

  	set material( value ) {

  		this._mesh.material = value;

  	}

  }

  class ShaderPass extends Pass {

  	constructor( shader, textureID ) {

  		super();

  		this.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';

  		if ( shader instanceof three$1.ShaderMaterial ) {

  			this.uniforms = shader.uniforms;

  			this.material = shader;

  		} else if ( shader ) {

  			this.uniforms = three$1.UniformsUtils.clone( shader.uniforms );

  			this.material = new three$1.ShaderMaterial( {

  				name: ( shader.name !== undefined ) ? shader.name : 'unspecified',
  				defines: Object.assign( {}, shader.defines ),
  				uniforms: this.uniforms,
  				vertexShader: shader.vertexShader,
  				fragmentShader: shader.fragmentShader

  			} );

  		}

  		this.fsQuad = new FullScreenQuad( this.material );

  	}

  	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

  		if ( this.uniforms[ this.textureID ] ) {

  			this.uniforms[ this.textureID ].value = readBuffer.texture;

  		}

  		this.fsQuad.material = this.material;

  		if ( this.renderToScreen ) {

  			renderer.setRenderTarget( null );
  			this.fsQuad.render( renderer );

  		} else {

  			renderer.setRenderTarget( writeBuffer );
  			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
  			if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
  			this.fsQuad.render( renderer );

  		}

  	}

  	dispose() {

  		this.material.dispose();

  		this.fsQuad.dispose();

  	}

  }

  class MaskPass extends Pass {

  	constructor( scene, camera ) {

  		super();

  		this.scene = scene;
  		this.camera = camera;

  		this.clear = true;
  		this.needsSwap = false;

  		this.inverse = false;

  	}

  	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

  		const context = renderer.getContext();
  		const state = renderer.state;

  		// don't update color or depth

  		state.buffers.color.setMask( false );
  		state.buffers.depth.setMask( false );

  		// lock buffers

  		state.buffers.color.setLocked( true );
  		state.buffers.depth.setLocked( true );

  		// set up stencil

  		let writeValue, clearValue;

  		if ( this.inverse ) {

  			writeValue = 0;
  			clearValue = 1;

  		} else {

  			writeValue = 1;
  			clearValue = 0;

  		}

  		state.buffers.stencil.setTest( true );
  		state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
  		state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
  		state.buffers.stencil.setClear( clearValue );
  		state.buffers.stencil.setLocked( true );

  		// draw into the stencil buffer

  		renderer.setRenderTarget( readBuffer );
  		if ( this.clear ) renderer.clear();
  		renderer.render( this.scene, this.camera );

  		renderer.setRenderTarget( writeBuffer );
  		if ( this.clear ) renderer.clear();
  		renderer.render( this.scene, this.camera );

  		// unlock color and depth buffer and make them writable for subsequent rendering/clearing

  		state.buffers.color.setLocked( false );
  		state.buffers.depth.setLocked( false );

  		state.buffers.color.setMask( true );
  		state.buffers.depth.setMask( true );

  		// only render where stencil is set to 1

  		state.buffers.stencil.setLocked( false );
  		state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1
  		state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );
  		state.buffers.stencil.setLocked( true );

  	}

  }

  class ClearMaskPass extends Pass {

  	constructor() {

  		super();

  		this.needsSwap = false;

  	}

  	render( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

  		renderer.state.buffers.stencil.setLocked( false );
  		renderer.state.buffers.stencil.setTest( false );

  	}

  }

  class EffectComposer {

  	constructor( renderer, renderTarget ) {

  		this.renderer = renderer;

  		this._pixelRatio = renderer.getPixelRatio();

  		if ( renderTarget === undefined ) {

  			const size = renderer.getSize( new three$1.Vector2() );
  			this._width = size.width;
  			this._height = size.height;

  			renderTarget = new three$1.WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: three$1.HalfFloatType } );
  			renderTarget.texture.name = 'EffectComposer.rt1';

  		} else {

  			this._width = renderTarget.width;
  			this._height = renderTarget.height;

  		}

  		this.renderTarget1 = renderTarget;
  		this.renderTarget2 = renderTarget.clone();
  		this.renderTarget2.texture.name = 'EffectComposer.rt2';

  		this.writeBuffer = this.renderTarget1;
  		this.readBuffer = this.renderTarget2;

  		this.renderToScreen = true;

  		this.passes = [];

  		this.copyPass = new ShaderPass( CopyShader );
  		this.copyPass.material.blending = three$1.NoBlending;

  		this.clock = new three$1.Clock();

  	}

  	swapBuffers() {

  		const tmp = this.readBuffer;
  		this.readBuffer = this.writeBuffer;
  		this.writeBuffer = tmp;

  	}

  	addPass( pass ) {

  		this.passes.push( pass );
  		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

  	}

  	insertPass( pass, index ) {

  		this.passes.splice( index, 0, pass );
  		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

  	}

  	removePass( pass ) {

  		const index = this.passes.indexOf( pass );

  		if ( index !== - 1 ) {

  			this.passes.splice( index, 1 );

  		}

  	}

  	isLastEnabledPass( passIndex ) {

  		for ( let i = passIndex + 1; i < this.passes.length; i ++ ) {

  			if ( this.passes[ i ].enabled ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	render( deltaTime ) {

  		// deltaTime value is in seconds

  		if ( deltaTime === undefined ) {

  			deltaTime = this.clock.getDelta();

  		}

  		const currentRenderTarget = this.renderer.getRenderTarget();

  		let maskActive = false;

  		for ( let i = 0, il = this.passes.length; i < il; i ++ ) {

  			const pass = this.passes[ i ];

  			if ( pass.enabled === false ) continue;

  			pass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );
  			pass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );

  			if ( pass.needsSwap ) {

  				if ( maskActive ) {

  					const context = this.renderer.getContext();
  					const stencil = this.renderer.state.buffers.stencil;

  					//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
  					stencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );

  					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );

  					//context.stencilFunc( context.EQUAL, 1, 0xffffffff );
  					stencil.setFunc( context.EQUAL, 1, 0xffffffff );

  				}

  				this.swapBuffers();

  			}

  			if ( MaskPass !== undefined ) {

  				if ( pass instanceof MaskPass ) {

  					maskActive = true;

  				} else if ( pass instanceof ClearMaskPass ) {

  					maskActive = false;

  				}

  			}

  		}

  		this.renderer.setRenderTarget( currentRenderTarget );

  	}

  	reset( renderTarget ) {

  		if ( renderTarget === undefined ) {

  			const size = this.renderer.getSize( new three$1.Vector2() );
  			this._pixelRatio = this.renderer.getPixelRatio();
  			this._width = size.width;
  			this._height = size.height;

  			renderTarget = this.renderTarget1.clone();
  			renderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

  		}

  		this.renderTarget1.dispose();
  		this.renderTarget2.dispose();
  		this.renderTarget1 = renderTarget;
  		this.renderTarget2 = renderTarget.clone();

  		this.writeBuffer = this.renderTarget1;
  		this.readBuffer = this.renderTarget2;

  	}

  	setSize( width, height ) {

  		this._width = width;
  		this._height = height;

  		const effectiveWidth = this._width * this._pixelRatio;
  		const effectiveHeight = this._height * this._pixelRatio;

  		this.renderTarget1.setSize( effectiveWidth, effectiveHeight );
  		this.renderTarget2.setSize( effectiveWidth, effectiveHeight );

  		for ( let i = 0; i < this.passes.length; i ++ ) {

  			this.passes[ i ].setSize( effectiveWidth, effectiveHeight );

  		}

  	}

  	setPixelRatio( pixelRatio ) {

  		this._pixelRatio = pixelRatio;

  		this.setSize( this._width, this._height );

  	}

  	dispose() {

  		this.renderTarget1.dispose();
  		this.renderTarget2.dispose();

  		this.copyPass.dispose();

  	}

  }

  class RenderPass extends Pass {

  	constructor( scene, camera, overrideMaterial = null, clearColor = null, clearAlpha = null ) {

  		super();

  		this.scene = scene;
  		this.camera = camera;

  		this.overrideMaterial = overrideMaterial;

  		this.clearColor = clearColor;
  		this.clearAlpha = clearAlpha;

  		this.clear = true;
  		this.clearDepth = false;
  		this.needsSwap = false;
  		this._oldClearColor = new three$1.Color();

  	}

  	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

  		const oldAutoClear = renderer.autoClear;
  		renderer.autoClear = false;

  		let oldClearAlpha, oldOverrideMaterial;

  		if ( this.overrideMaterial !== null ) {

  			oldOverrideMaterial = this.scene.overrideMaterial;

  			this.scene.overrideMaterial = this.overrideMaterial;

  		}

  		if ( this.clearColor !== null ) {

  			renderer.getClearColor( this._oldClearColor );
  			renderer.setClearColor( this.clearColor, renderer.getClearAlpha() );

  		}

  		if ( this.clearAlpha !== null ) {

  			oldClearAlpha = renderer.getClearAlpha();
  			renderer.setClearAlpha( this.clearAlpha );

  		}

  		if ( this.clearDepth == true ) {

  			renderer.clearDepth();

  		}

  		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );

  		if ( this.clear === true ) {

  			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
  			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

  		}

  		renderer.render( this.scene, this.camera );

  		// restore

  		if ( this.clearColor !== null ) {

  			renderer.setClearColor( this._oldClearColor );

  		}

  		if ( this.clearAlpha !== null ) {

  			renderer.setClearAlpha( oldClearAlpha );

  		}

  		if ( this.overrideMaterial !== null ) {

  			this.scene.overrideMaterial = oldOverrideMaterial;

  		}

  		renderer.autoClear = oldAutoClear;

  	}

  }

  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }

  function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }

  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }

  function _inheritsLoose(t, o) {
    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
  }

  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
  }

  function _isNativeFunction(t) {
    try {
      return -1 !== Function.toString.call(t).indexOf("[native code]");
    } catch (n) {
      return "function" == typeof t;
    }
  }

  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }

  function _construct(t, e, r) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o = [null];
    o.push.apply(o, e);
    var p = new (t.bind.apply(t, o))();
    return r && _setPrototypeOf(p, r.prototype), p;
  }

  function _wrapNativeSuper(t) {
    var r = "function" == typeof Map ? new Map() : void 0;
    return _wrapNativeSuper = function _wrapNativeSuper(t) {
      if (null === t || !_isNativeFunction(t)) return t;
      if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== r) {
        if (r.has(t)) return r.get(t);
        r.set(t, Wrapper);
      }
      function Wrapper() {
        return _construct(t, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper.prototype = Object.create(t.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), _setPrototypeOf(Wrapper, t);
    }, _wrapNativeSuper(t);
  }

  // based on https://github.com/styled-components/styled-components/blob/fcf6f3804c57a14dd7984dfab7bc06ee2edca044/src/utils/error.js
  /**
   * Parse errors.md and turn it into a simple hash of code: message
   * @private
   */
  var ERRORS = {
    "1": "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n",
    "2": "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n",
    "3": "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n",
    "4": "Couldn't generate valid rgb string from %s, it returned %s.\n\n",
    "5": "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n",
    "6": "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n",
    "7": "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n",
    "8": "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n",
    "9": "Please provide a number of steps to the modularScale helper.\n\n",
    "10": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
    "11": "Invalid value passed as base to modularScale, expected number or em string but got \"%s\"\n\n",
    "12": "Expected a string ending in \"px\" or a number passed as the first argument to %s(), got \"%s\" instead.\n\n",
    "13": "Expected a string ending in \"px\" or a number passed as the second argument to %s(), got \"%s\" instead.\n\n",
    "14": "Passed invalid pixel value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\n\n",
    "15": "Passed invalid base value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\n\n",
    "16": "You must provide a template to this method.\n\n",
    "17": "You passed an unsupported selector state to this method.\n\n",
    "18": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
    "19": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
    "20": "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
    "21": "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    "22": "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    "23": "fontFace expects a name of a font-family.\n\n",
    "24": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
    "25": "fontFace expects localFonts to be an array.\n\n",
    "26": "fontFace expects fileFormats to be an array.\n\n",
    "27": "radialGradient requries at least 2 color-stops to properly render.\n\n",
    "28": "Please supply a filename to retinaImage() as the first argument.\n\n",
    "29": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
    "30": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    "31": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n",
    "32": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n",
    "33": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n",
    "34": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
    "35": "borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\n\n",
    "36": "Property must be a string value.\n\n",
    "37": "Syntax Error at %s.\n\n",
    "38": "Formula contains a function that needs parentheses at %s.\n\n",
    "39": "Formula is missing closing parenthesis at %s.\n\n",
    "40": "Formula has too many closing parentheses at %s.\n\n",
    "41": "All values in a formula must have the same unit or be unitless.\n\n",
    "42": "Please provide a number of steps to the modularScale helper.\n\n",
    "43": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
    "44": "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n",
    "45": "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n",
    "46": "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n",
    "47": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
    "48": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
    "49": "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
    "50": "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n",
    "51": "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n",
    "52": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
    "53": "fontFace expects localFonts to be an array.\n\n",
    "54": "fontFace expects fileFormats to be an array.\n\n",
    "55": "fontFace expects a name of a font-family.\n\n",
    "56": "linearGradient requries at least 2 color-stops to properly render.\n\n",
    "57": "radialGradient requries at least 2 color-stops to properly render.\n\n",
    "58": "Please supply a filename to retinaImage() as the first argument.\n\n",
    "59": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
    "60": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    "61": "Property must be a string value.\n\n",
    "62": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
    "63": "borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\n\n",
    "64": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n",
    "65": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n",
    "66": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n",
    "67": "You must provide a template to this method.\n\n",
    "68": "You passed an unsupported selector state to this method.\n\n",
    "69": "Expected a string ending in \"px\" or a number passed as the first argument to %s(), got %s instead.\n\n",
    "70": "Expected a string ending in \"px\" or a number passed as the second argument to %s(), got %s instead.\n\n",
    "71": "Passed invalid pixel value %s to %s(), please pass a value like \"12px\" or 12.\n\n",
    "72": "Passed invalid base value %s to %s(), please pass a value like \"12px\" or 12.\n\n",
    "73": "Please provide a valid CSS variable.\n\n",
    "74": "CSS variable not found and no default was provided.\n\n",
    "75": "important requires a valid style object, got a %s instead.\n\n",
    "76": "fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\n\n",
    "77": "remToPx expects a value in \"rem\" but you provided it in \"%s\".\n\n",
    "78": "base must be set in \"px\" or \"%\" but you set it in \"%s\".\n"
  };

  /**
   * super basic version of sprintf
   * @private
   */
  function format() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var a = args[0];
    var b = [];
    var c;
    for (c = 1; c < args.length; c += 1) {
      b.push(args[c]);
    }
    b.forEach(function (d) {
      a = a.replace(/%[a-z]/, d);
    });
    return a;
  }

  /**
   * Create an error file out of errors.md for development and a simple web link to the full errors
   * in production mode.
   * @private
   */
  var PolishedError = /*#__PURE__*/function (_Error) {
    _inheritsLoose(PolishedError, _Error);
    function PolishedError(code) {
      var _this;
      if (process.env.NODE_ENV === 'production') {
        _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
      } else {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this;
      }
      return _assertThisInitialized(_this);
    }
    return PolishedError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function colorToInt(color) {
    return Math.round(color * 255);
  }
  function convertToInt(red, green, blue) {
    return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
  }
  function hslToRgb(hue, saturation, lightness, convert) {
    if (convert === void 0) {
      convert = convertToInt;
    }
    if (saturation === 0) {
      // achromatic
      return convert(lightness, lightness, lightness);
    }

    // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV
    var huePrime = (hue % 360 + 360) % 360 / 60;
    var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
    var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
    var red = 0;
    var green = 0;
    var blue = 0;
    if (huePrime >= 0 && huePrime < 1) {
      red = chroma;
      green = secondComponent;
    } else if (huePrime >= 1 && huePrime < 2) {
      red = secondComponent;
      green = chroma;
    } else if (huePrime >= 2 && huePrime < 3) {
      green = chroma;
      blue = secondComponent;
    } else if (huePrime >= 3 && huePrime < 4) {
      green = secondComponent;
      blue = chroma;
    } else if (huePrime >= 4 && huePrime < 5) {
      red = secondComponent;
      blue = chroma;
    } else if (huePrime >= 5 && huePrime < 6) {
      red = chroma;
      blue = secondComponent;
    }
    var lightnessModification = lightness - chroma / 2;
    var finalRed = red + lightnessModification;
    var finalGreen = green + lightnessModification;
    var finalBlue = blue + lightnessModification;
    return convert(finalRed, finalGreen, finalBlue);
  }

  var namedColorMap = {
    aliceblue: 'f0f8ff',
    antiquewhite: 'faebd7',
    aqua: '00ffff',
    aquamarine: '7fffd4',
    azure: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '000',
    blanchedalmond: 'ffebcd',
    blue: '0000ff',
    blueviolet: '8a2be2',
    brown: 'a52a2a',
    burlywood: 'deb887',
    cadetblue: '5f9ea0',
    chartreuse: '7fff00',
    chocolate: 'd2691e',
    coral: 'ff7f50',
    cornflowerblue: '6495ed',
    cornsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: '00ffff',
    darkblue: '00008b',
    darkcyan: '008b8b',
    darkgoldenrod: 'b8860b',
    darkgray: 'a9a9a9',
    darkgreen: '006400',
    darkgrey: 'a9a9a9',
    darkkhaki: 'bdb76b',
    darkmagenta: '8b008b',
    darkolivegreen: '556b2f',
    darkorange: 'ff8c00',
    darkorchid: '9932cc',
    darkred: '8b0000',
    darksalmon: 'e9967a',
    darkseagreen: '8fbc8f',
    darkslateblue: '483d8b',
    darkslategray: '2f4f4f',
    darkslategrey: '2f4f4f',
    darkturquoise: '00ced1',
    darkviolet: '9400d3',
    deeppink: 'ff1493',
    deepskyblue: '00bfff',
    dimgray: '696969',
    dimgrey: '696969',
    dodgerblue: '1e90ff',
    firebrick: 'b22222',
    floralwhite: 'fffaf0',
    forestgreen: '228b22',
    fuchsia: 'ff00ff',
    gainsboro: 'dcdcdc',
    ghostwhite: 'f8f8ff',
    gold: 'ffd700',
    goldenrod: 'daa520',
    gray: '808080',
    green: '008000',
    greenyellow: 'adff2f',
    grey: '808080',
    honeydew: 'f0fff0',
    hotpink: 'ff69b4',
    indianred: 'cd5c5c',
    indigo: '4b0082',
    ivory: 'fffff0',
    khaki: 'f0e68c',
    lavender: 'e6e6fa',
    lavenderblush: 'fff0f5',
    lawngreen: '7cfc00',
    lemonchiffon: 'fffacd',
    lightblue: 'add8e6',
    lightcoral: 'f08080',
    lightcyan: 'e0ffff',
    lightgoldenrodyellow: 'fafad2',
    lightgray: 'd3d3d3',
    lightgreen: '90ee90',
    lightgrey: 'd3d3d3',
    lightpink: 'ffb6c1',
    lightsalmon: 'ffa07a',
    lightseagreen: '20b2aa',
    lightskyblue: '87cefa',
    lightslategray: '789',
    lightslategrey: '789',
    lightsteelblue: 'b0c4de',
    lightyellow: 'ffffe0',
    lime: '0f0',
    limegreen: '32cd32',
    linen: 'faf0e6',
    magenta: 'f0f',
    maroon: '800000',
    mediumaquamarine: '66cdaa',
    mediumblue: '0000cd',
    mediumorchid: 'ba55d3',
    mediumpurple: '9370db',
    mediumseagreen: '3cb371',
    mediumslateblue: '7b68ee',
    mediumspringgreen: '00fa9a',
    mediumturquoise: '48d1cc',
    mediumvioletred: 'c71585',
    midnightblue: '191970',
    mintcream: 'f5fffa',
    mistyrose: 'ffe4e1',
    moccasin: 'ffe4b5',
    navajowhite: 'ffdead',
    navy: '000080',
    oldlace: 'fdf5e6',
    olive: '808000',
    olivedrab: '6b8e23',
    orange: 'ffa500',
    orangered: 'ff4500',
    orchid: 'da70d6',
    palegoldenrod: 'eee8aa',
    palegreen: '98fb98',
    paleturquoise: 'afeeee',
    palevioletred: 'db7093',
    papayawhip: 'ffefd5',
    peachpuff: 'ffdab9',
    peru: 'cd853f',
    pink: 'ffc0cb',
    plum: 'dda0dd',
    powderblue: 'b0e0e6',
    purple: '800080',
    rebeccapurple: '639',
    red: 'f00',
    rosybrown: 'bc8f8f',
    royalblue: '4169e1',
    saddlebrown: '8b4513',
    salmon: 'fa8072',
    sandybrown: 'f4a460',
    seagreen: '2e8b57',
    seashell: 'fff5ee',
    sienna: 'a0522d',
    silver: 'c0c0c0',
    skyblue: '87ceeb',
    slateblue: '6a5acd',
    slategray: '708090',
    slategrey: '708090',
    snow: 'fffafa',
    springgreen: '00ff7f',
    steelblue: '4682b4',
    tan: 'd2b48c',
    teal: '008080',
    thistle: 'd8bfd8',
    tomato: 'ff6347',
    turquoise: '40e0d0',
    violet: 'ee82ee',
    wheat: 'f5deb3',
    white: 'fff',
    whitesmoke: 'f5f5f5',
    yellow: 'ff0',
    yellowgreen: '9acd32'
  };

  /**
   * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
   * @private
   */
  function nameToHex(color) {
    if (typeof color !== 'string') return color;
    var normalizedColorName = color.toLowerCase();
    return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
  }

  var hexRegex = /^#[a-fA-F0-9]{6}$/;
  var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
  var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
  var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
  var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
  var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
  var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
  var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;

  /**
   * Returns an RgbColor or RgbaColor object. This utility function is only useful
   * if want to extract a color component. With the color util `toColorString` you
   * can convert a RgbColor or RgbaColor object back to a string.
   *
   * @example
   * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1
   * const color1 = parseToRgb('rgb(255, 0, 0)');
   * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2
   * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');
   */
  function parseToRgb(color) {
    if (typeof color !== 'string') {
      throw new PolishedError(3);
    }
    var normalizedColor = nameToHex(color);
    if (normalizedColor.match(hexRegex)) {
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
      };
    }
    if (normalizedColor.match(hexRgbaRegex)) {
      var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
        alpha: alpha
      };
    }
    if (normalizedColor.match(reducedHexRegex)) {
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
      };
    }
    if (normalizedColor.match(reducedRgbaHexRegex)) {
      var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
        alpha: _alpha
      };
    }
    var rgbMatched = rgbRegex.exec(normalizedColor);
    if (rgbMatched) {
      return {
        red: parseInt("" + rgbMatched[1], 10),
        green: parseInt("" + rgbMatched[2], 10),
        blue: parseInt("" + rgbMatched[3], 10)
      };
    }
    var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
    if (rgbaMatched) {
      return {
        red: parseInt("" + rgbaMatched[1], 10),
        green: parseInt("" + rgbaMatched[2], 10),
        blue: parseInt("" + rgbaMatched[3], 10),
        alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
      };
    }
    var hslMatched = hslRegex.exec(normalizedColor);
    if (hslMatched) {
      var hue = parseInt("" + hslMatched[1], 10);
      var saturation = parseInt("" + hslMatched[2], 10) / 100;
      var lightness = parseInt("" + hslMatched[3], 10) / 100;
      var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
      var hslRgbMatched = rgbRegex.exec(rgbColorString);
      if (!hslRgbMatched) {
        throw new PolishedError(4, normalizedColor, rgbColorString);
      }
      return {
        red: parseInt("" + hslRgbMatched[1], 10),
        green: parseInt("" + hslRgbMatched[2], 10),
        blue: parseInt("" + hslRgbMatched[3], 10)
      };
    }
    var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
    if (hslaMatched) {
      var _hue = parseInt("" + hslaMatched[1], 10);
      var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
      var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
      var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
      var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
      if (!_hslRgbMatched) {
        throw new PolishedError(4, normalizedColor, _rgbColorString);
      }
      return {
        red: parseInt("" + _hslRgbMatched[1], 10),
        green: parseInt("" + _hslRgbMatched[2], 10),
        blue: parseInt("" + _hslRgbMatched[3], 10),
        alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
      };
    }
    throw new PolishedError(5);
  }

  function rgbToHsl(color) {
    // make sure rgb are contained in a set of [0, 255]
    var red = color.red / 255;
    var green = color.green / 255;
    var blue = color.blue / 255;
    var max = Math.max(red, green, blue);
    var min = Math.min(red, green, blue);
    var lightness = (max + min) / 2;
    if (max === min) {
      // achromatic
      if (color.alpha !== undefined) {
        return {
          hue: 0,
          saturation: 0,
          lightness: lightness,
          alpha: color.alpha
        };
      } else {
        return {
          hue: 0,
          saturation: 0,
          lightness: lightness
        };
      }
    }
    var hue;
    var delta = max - min;
    var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);
    switch (max) {
      case red:
        hue = (green - blue) / delta + (green < blue ? 6 : 0);
        break;
      case green:
        hue = (blue - red) / delta + 2;
        break;
      default:
        // blue case
        hue = (red - green) / delta + 4;
        break;
    }
    hue *= 60;
    if (color.alpha !== undefined) {
      return {
        hue: hue,
        saturation: saturation,
        lightness: lightness,
        alpha: color.alpha
      };
    }
    return {
      hue: hue,
      saturation: saturation,
      lightness: lightness
    };
  }

  /**
   * Returns an HslColor or HslaColor object. This utility function is only useful
   * if want to extract a color component. With the color util `toColorString` you
   * can convert a HslColor or HslaColor object back to a string.
   *
   * @example
   * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1
   * const color1 = parseToHsl('rgb(255, 0, 0)');
   * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2
   * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');
   */
  function parseToHsl(color) {
    // Note: At a later stage we can optimize this function as right now a hsl
    // color would be parsed converted to rgb values and converted back to hsl.
    return rgbToHsl(parseToRgb(color));
  }

  /**
   * Reduces hex values if possible e.g. #ff8866 to #f86
   * @private
   */
  var reduceHexValue = function reduceHexValue(value) {
    if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
      return "#" + value[1] + value[3] + value[5];
    }
    return value;
  };
  var reduceHexValue$1 = reduceHexValue;

  function numberToHex(value) {
    var hex = value.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }

  function colorToHex(color) {
    return numberToHex(Math.round(color * 255));
  }
  function convertToHex(red, green, blue) {
    return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
  }
  function hslToHex(hue, saturation, lightness) {
    return hslToRgb(hue, saturation, lightness, convertToHex);
  }

  /**
   * Returns a string value for the color. The returned result is the smallest possible hex notation.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: hsl(359, 0.75, 0.4),
   *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${hsl(359, 0.75, 0.4)};
   *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#b3191c";
   *   background: "#b3191c";
   * }
   */
  function hsl(value, saturation, lightness) {
    if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number') {
      return hslToHex(value, saturation, lightness);
    } else if (typeof value === 'object' && saturation === undefined && lightness === undefined) {
      return hslToHex(value.hue, value.saturation, value.lightness);
    }
    throw new PolishedError(1);
  }

  /**
   * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: hsla(359, 0.75, 0.4, 0.7),
   *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),
   *   background: hsla(359, 0.75, 0.4, 1),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${hsla(359, 0.75, 0.4, 0.7)};
   *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};
   *   background: ${hsla(359, 0.75, 0.4, 1)};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "rgba(179,25,28,0.7)";
   *   background: "rgba(179,25,28,0.7)";
   *   background: "#b3191c";
   * }
   */
  function hsla(value, saturation, lightness, alpha) {
    if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number' && typeof alpha === 'number') {
      return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
    } else if (typeof value === 'object' && saturation === undefined && lightness === undefined && alpha === undefined) {
      return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
    }
    throw new PolishedError(2);
  }

  /**
   * Returns a string value for the color. The returned result is the smallest possible hex notation.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: rgb(255, 205, 100),
   *   background: rgb({ red: 255, green: 205, blue: 100 }),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${rgb(255, 205, 100)};
   *   background: ${rgb({ red: 255, green: 205, blue: 100 })};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#ffcd64";
   *   background: "#ffcd64";
   * }
   */
  function rgb(value, green, blue) {
    if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {
      return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
    } else if (typeof value === 'object' && green === undefined && blue === undefined) {
      return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
    }
    throw new PolishedError(6);
  }

  /**
   * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
   *
   * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: rgba(255, 205, 100, 0.7),
   *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),
   *   background: rgba(255, 205, 100, 1),
   *   background: rgba('#ffffff', 0.4),
   *   background: rgba('black', 0.7),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${rgba(255, 205, 100, 0.7)};
   *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};
   *   background: ${rgba(255, 205, 100, 1)};
   *   background: ${rgba('#ffffff', 0.4)};
   *   background: ${rgba('black', 0.7)};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "rgba(255,205,100,0.7)";
   *   background: "rgba(255,205,100,0.7)";
   *   background: "#ffcd64";
   *   background: "rgba(255,255,255,0.4)";
   *   background: "rgba(0,0,0,0.7)";
   * }
   */
  function rgba(firstValue, secondValue, thirdValue, fourthValue) {
    if (typeof firstValue === 'string' && typeof secondValue === 'number') {
      var rgbValue = parseToRgb(firstValue);
      return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
    } else if (typeof firstValue === 'number' && typeof secondValue === 'number' && typeof thirdValue === 'number' && typeof fourthValue === 'number') {
      return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
    } else if (typeof firstValue === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {
      return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
    }
    throw new PolishedError(7);
  }

  var isRgb = function isRgb(color) {
    return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
  };
  var isRgba = function isRgba(color) {
    return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && typeof color.alpha === 'number';
  };
  var isHsl = function isHsl(color) {
    return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
  };
  var isHsla = function isHsla(color) {
    return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && typeof color.alpha === 'number';
  };

  /**
   * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.
   * This util is useful in case you only know on runtime which color object is
   * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: toColorString({ red: 255, green: 205, blue: 100 }),
   *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),
   *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),
   *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};
   *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};
   *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};
   *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#ffcd64";
   *   background: "rgba(255,205,100,0.72)";
   *   background: "#00f";
   *   background: "rgba(179,25,25,0.72)";
   * }
   */

  function toColorString(color) {
    if (typeof color !== 'object') throw new PolishedError(8);
    if (isRgba(color)) return rgba(color);
    if (isRgb(color)) return rgb(color);
    if (isHsla(color)) return hsla(color);
    if (isHsl(color)) return hsl(color);
    throw new PolishedError(8);
  }

  // Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js
  // eslint-disable-next-line no-unused-vars
  // eslint-disable-next-line no-unused-vars
  // eslint-disable-next-line no-redeclare
  function curried(f, length, acc) {
    return function fn() {
      // eslint-disable-next-line prefer-rest-params
      var combined = acc.concat(Array.prototype.slice.call(arguments));
      return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
    };
  }

  // eslint-disable-next-line no-redeclare
  function curry(f) {
    // eslint-disable-line no-redeclare
    return curried(f, f.length, []);
  }

  /**
   * Changes the hue of the color. Hue is a number between 0 to 360. The first
   * argument for adjustHue is the amount of degrees the color is rotated around
   * the color wheel, always producing a positive hue value.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: adjustHue(180, '#448'),
   *   background: adjustHue('180', 'rgba(101,100,205,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${adjustHue(180, '#448')};
   *   background: ${adjustHue('180', 'rgba(101,100,205,0.7)')};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#888844";
   *   background: "rgba(136,136,68,0.7)";
   * }
   */
  function adjustHue(degree, color) {
    if (color === 'transparent') return color;
    var hslColor = parseToHsl(color);
    return toColorString(_extends({}, hslColor, {
      hue: hslColor.hue + parseFloat(degree)
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(adjustHue);

  function guard(lowerBoundary, upperBoundary, value) {
    return Math.max(lowerBoundary, Math.min(upperBoundary, value));
  }

  /**
   * Returns a string value for the darkened color.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: darken(0.2, '#FFCD64'),
   *   background: darken('0.2', 'rgba(255,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${darken(0.2, '#FFCD64')};
   *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#ffbd31";
   *   background: "rgba(255,189,49,0.7)";
   * }
   */
  function darken(amount, color) {
    if (color === 'transparent') return color;
    var hslColor = parseToHsl(color);
    return toColorString(_extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(darken);

  /**
   * Decreases the intensity of a color. Its range is between 0 to 1. The first
   * argument of the desaturate function is the amount by how much the color
   * intensity should be decreased.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: desaturate(0.2, '#CCCD64'),
   *   background: desaturate('0.2', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${desaturate(0.2, '#CCCD64')};
   *   background: ${desaturate('0.2', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#b8b979";
   *   background: "rgba(184,185,121,0.7)";
   * }
   */
  function desaturate(amount, color) {
    if (color === 'transparent') return color;
    var hslColor = parseToHsl(color);
    return toColorString(_extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(desaturate);

  /**
   * Returns a string value for the lightened color.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: lighten(0.2, '#CCCD64'),
   *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${lighten(0.2, '#FFCD64')};
   *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#e5e6b1";
   *   background: "rgba(229,230,177,0.7)";
   * }
   */
  function lighten(amount, color) {
    if (color === 'transparent') return color;
    var hslColor = parseToHsl(color);
    return toColorString(_extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(lighten);

  /**
   * Mixes the two provided colors together by calculating the average of each of the RGB components weighted to the first color by the provided weight.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: mix(0.5, '#f00', '#00f')
   *   background: mix(0.25, '#f00', '#00f')
   *   background: mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${mix(0.5, '#f00', '#00f')};
   *   background: ${mix(0.25, '#f00', '#00f')};
   *   background: ${mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#7f007f";
   *   background: "#3f00bf";
   *   background: "rgba(63, 0, 191, 0.75)";
   * }
   */
  function mix(weight, color, otherColor) {
    if (color === 'transparent') return otherColor;
    if (otherColor === 'transparent') return color;
    if (weight === 0) return otherColor;
    var parsedColor1 = parseToRgb(color);
    var color1 = _extends({}, parsedColor1, {
      alpha: typeof parsedColor1.alpha === 'number' ? parsedColor1.alpha : 1
    });
    var parsedColor2 = parseToRgb(otherColor);
    var color2 = _extends({}, parsedColor2, {
      alpha: typeof parsedColor2.alpha === 'number' ? parsedColor2.alpha : 1
    });

    // The formula is copied from the original Sass implementation:
    // http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method
    var alphaDelta = color1.alpha - color2.alpha;
    var x = parseFloat(weight) * 2 - 1;
    var y = x * alphaDelta === -1 ? x : x + alphaDelta;
    var z = 1 + x * alphaDelta;
    var weight1 = (y / z + 1) / 2.0;
    var weight2 = 1 - weight1;
    var mixedColor = {
      red: Math.floor(color1.red * weight1 + color2.red * weight2),
      green: Math.floor(color1.green * weight1 + color2.green * weight2),
      blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),
      alpha: color1.alpha * parseFloat(weight) + color2.alpha * (1 - parseFloat(weight))
    };
    return rgba(mixedColor);
  }

  // prettier-ignore
  var curriedMix = curry /* ::<number | string, string, string, string> */(mix);
  var mix$1 = curriedMix;

  /**
   * Increases the opacity of a color. Its range for the amount is between 0 to 1.
   *
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');
   *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),
   *   background: opacify('0.5', 'rgba(255, 0, 0, 0.2)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};
   *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},
   *   background: ${opacify('0.5', 'rgba(255, 0, 0, 0.2)')},
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#fff";
   *   background: "rgba(255,255,255,0.7)";
   *   background: "rgba(255,0,0,0.7)";
   * }
   */
  function opacify(amount, color) {
    if (color === 'transparent') return color;
    var parsedColor = parseToRgb(color);
    var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;
    var colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
    });
    return rgba(colorWithAlpha);
  }

  // prettier-ignore
  var curriedOpacify = curry /* ::<number | string, string, string> */(opacify);
  var curriedOpacify$1 = curriedOpacify;

  /**
   * Increases the intensity of a color. Its range is between 0 to 1. The first
   * argument of the saturate function is the amount by how much the color
   * intensity should be increased.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: saturate(0.2, '#CCCD64'),
   *   background: saturate('0.2', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${saturate(0.2, '#FFCD64')};
   *   background: ${saturate('0.2', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#e0e250";
   *   background: "rgba(224,226,80,0.7)";
   * }
   */
  function saturate(amount, color) {
    if (color === 'transparent') return color;
    var hslColor = parseToHsl(color);
    return toColorString(_extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(saturate);

  /**
   * Sets the hue of a color to the provided value. The hue range can be
   * from 0 and 359.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: setHue(42, '#CCCD64'),
   *   background: setHue('244', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${setHue(42, '#CCCD64')};
   *   background: ${setHue('244', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#cdae64";
   *   background: "rgba(107,100,205,0.7)";
   * }
   */
  function setHue(hue, color) {
    if (color === 'transparent') return color;
    return toColorString(_extends({}, parseToHsl(color), {
      hue: parseFloat(hue)
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(setHue);

  /**
   * Sets the lightness of a color to the provided value. The lightness range can be
   * from 0 and 1.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: setLightness(0.2, '#CCCD64'),
   *   background: setLightness('0.75', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${setLightness(0.2, '#CCCD64')};
   *   background: ${setLightness('0.75', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#4d4d19";
   *   background: "rgba(223,224,159,0.7)";
   * }
   */
  function setLightness(lightness, color) {
    if (color === 'transparent') return color;
    return toColorString(_extends({}, parseToHsl(color), {
      lightness: parseFloat(lightness)
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(setLightness);

  /**
   * Sets the saturation of a color to the provided value. The saturation range can be
   * from 0 and 1.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: setSaturation(0.2, '#CCCD64'),
   *   background: setSaturation('0.75', 'rgba(204,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${setSaturation(0.2, '#CCCD64')};
   *   background: ${setSaturation('0.75', 'rgba(204,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#adad84";
   *   background: "rgba(228,229,76,0.7)";
   * }
   */
  function setSaturation(saturation, color) {
    if (color === 'transparent') return color;
    return toColorString(_extends({}, parseToHsl(color), {
      saturation: parseFloat(saturation)
    }));
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(setSaturation);

  /**
   * Shades a color by mixing it with black. `shade` can produce
   * hue shifts, where as `darken` manipulates the luminance channel and therefore
   * doesn't produce hue shifts.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: shade(0.25, '#00f')
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${shade(0.25, '#00f')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#00003f";
   * }
   */

  function shade(percentage, color) {
    if (color === 'transparent') return color;
    return mix$1(parseFloat(percentage), 'rgb(0, 0, 0)', color);
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(shade);

  /**
   * Tints a color by mixing it with white. `tint` can produce
   * hue shifts, where as `lighten` manipulates the luminance channel and therefore
   * doesn't produce hue shifts.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: tint(0.25, '#00f')
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${tint(0.25, '#00f')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#bfbfff";
   * }
   */

  function tint(percentage, color) {
    if (color === 'transparent') return color;
    return mix$1(parseFloat(percentage), 'rgb(255, 255, 255)', color);
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(tint);

  /**
   * Decreases the opacity of a color. Its range for the amount is between 0 to 1.
   *
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: transparentize(0.1, '#fff'),
   *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),
   *   background: transparentize('0.5', 'rgba(255, 0, 0, 0.8)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${transparentize(0.1, '#fff')};
   *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')};
   *   background: ${transparentize('0.5', 'rgba(255, 0, 0, 0.8)')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "rgba(255,255,255,0.9)";
   *   background: "rgba(255,255,255,0.8)";
   *   background: "rgba(255,0,0,0.3)";
   * }
   */
  function transparentize(amount, color) {
    if (color === 'transparent') return color;
    var parsedColor = parseToRgb(color);
    var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;
    var colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
    });
    return rgba(colorWithAlpha);
  }

  // prettier-ignore
  curry /* ::<number | string, string, string> */(transparentize);

  /**
   * The Ease class provides a collection of easing functions for use with tween.js.
   */
  var Easing = Object.freeze({
      Linear: Object.freeze({
          None: function (amount) {
              return amount;
          },
          In: function (amount) {
              return amount;
          },
          Out: function (amount) {
              return amount;
          },
          InOut: function (amount) {
              return amount;
          },
      }),
      Quadratic: Object.freeze({
          In: function (amount) {
              return amount * amount;
          },
          Out: function (amount) {
              return amount * (2 - amount);
          },
          InOut: function (amount) {
              if ((amount *= 2) < 1) {
                  return 0.5 * amount * amount;
              }
              return -0.5 * (--amount * (amount - 2) - 1);
          },
      }),
      Cubic: Object.freeze({
          In: function (amount) {
              return amount * amount * amount;
          },
          Out: function (amount) {
              return --amount * amount * amount + 1;
          },
          InOut: function (amount) {
              if ((amount *= 2) < 1) {
                  return 0.5 * amount * amount * amount;
              }
              return 0.5 * ((amount -= 2) * amount * amount + 2);
          },
      }),
      Quartic: Object.freeze({
          In: function (amount) {
              return amount * amount * amount * amount;
          },
          Out: function (amount) {
              return 1 - --amount * amount * amount * amount;
          },
          InOut: function (amount) {
              if ((amount *= 2) < 1) {
                  return 0.5 * amount * amount * amount * amount;
              }
              return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
          },
      }),
      Quintic: Object.freeze({
          In: function (amount) {
              return amount * amount * amount * amount * amount;
          },
          Out: function (amount) {
              return --amount * amount * amount * amount * amount + 1;
          },
          InOut: function (amount) {
              if ((amount *= 2) < 1) {
                  return 0.5 * amount * amount * amount * amount * amount;
              }
              return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
          },
      }),
      Sinusoidal: Object.freeze({
          In: function (amount) {
              return 1 - Math.sin(((1.0 - amount) * Math.PI) / 2);
          },
          Out: function (amount) {
              return Math.sin((amount * Math.PI) / 2);
          },
          InOut: function (amount) {
              return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));
          },
      }),
      Exponential: Object.freeze({
          In: function (amount) {
              return amount === 0 ? 0 : Math.pow(1024, amount - 1);
          },
          Out: function (amount) {
              return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
          },
          InOut: function (amount) {
              if (amount === 0) {
                  return 0;
              }
              if (amount === 1) {
                  return 1;
              }
              if ((amount *= 2) < 1) {
                  return 0.5 * Math.pow(1024, amount - 1);
              }
              return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
          },
      }),
      Circular: Object.freeze({
          In: function (amount) {
              return 1 - Math.sqrt(1 - amount * amount);
          },
          Out: function (amount) {
              return Math.sqrt(1 - --amount * amount);
          },
          InOut: function (amount) {
              if ((amount *= 2) < 1) {
                  return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
              }
              return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
          },
      }),
      Elastic: Object.freeze({
          In: function (amount) {
              if (amount === 0) {
                  return 0;
              }
              if (amount === 1) {
                  return 1;
              }
              return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
          },
          Out: function (amount) {
              if (amount === 0) {
                  return 0;
              }
              if (amount === 1) {
                  return 1;
              }
              return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
          },
          InOut: function (amount) {
              if (amount === 0) {
                  return 0;
              }
              if (amount === 1) {
                  return 1;
              }
              amount *= 2;
              if (amount < 1) {
                  return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
              }
              return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
          },
      }),
      Back: Object.freeze({
          In: function (amount) {
              var s = 1.70158;
              return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);
          },
          Out: function (amount) {
              var s = 1.70158;
              return amount === 0 ? 0 : --amount * amount * ((s + 1) * amount + s) + 1;
          },
          InOut: function (amount) {
              var s = 1.70158 * 1.525;
              if ((amount *= 2) < 1) {
                  return 0.5 * (amount * amount * ((s + 1) * amount - s));
              }
              return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
          },
      }),
      Bounce: Object.freeze({
          In: function (amount) {
              return 1 - Easing.Bounce.Out(1 - amount);
          },
          Out: function (amount) {
              if (amount < 1 / 2.75) {
                  return 7.5625 * amount * amount;
              }
              else if (amount < 2 / 2.75) {
                  return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
              }
              else if (amount < 2.5 / 2.75) {
                  return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
              }
              else {
                  return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
              }
          },
          InOut: function (amount) {
              if (amount < 0.5) {
                  return Easing.Bounce.In(amount * 2) * 0.5;
              }
              return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
          },
      }),
      generatePow: function (power) {
          if (power === void 0) { power = 4; }
          power = power < Number.EPSILON ? Number.EPSILON : power;
          power = power > 10000 ? 10000 : power;
          return {
              In: function (amount) {
                  return Math.pow(amount, power);
              },
              Out: function (amount) {
                  return 1 - Math.pow((1 - amount), power);
              },
              InOut: function (amount) {
                  if (amount < 0.5) {
                      return Math.pow((amount * 2), power) / 2;
                  }
                  return (1 - Math.pow((2 - amount * 2), power)) / 2 + 0.5;
              },
          };
      },
  });

  var now$1 = function () { return performance.now(); };

  /**
   * Controlling groups of tweens
   *
   * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
   * In these cases, you may want to create your own smaller groups of tween
   */
  var Group = /** @class */ (function () {
      function Group() {
          var tweens = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              tweens[_i] = arguments[_i];
          }
          this._tweens = {};
          this._tweensAddedDuringUpdate = {};
          this.add.apply(this, tweens);
      }
      Group.prototype.getAll = function () {
          var _this = this;
          return Object.keys(this._tweens).map(function (tweenId) { return _this._tweens[tweenId]; });
      };
      Group.prototype.removeAll = function () {
          this._tweens = {};
      };
      Group.prototype.add = function () {
          var _a;
          var tweens = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              tweens[_i] = arguments[_i];
          }
          for (var _b = 0, tweens_1 = tweens; _b < tweens_1.length; _b++) {
              var tween = tweens_1[_b];
              // Remove from any other group first, a tween can only be in one group at a time.
              // @ts-expect-error library internal access
              (_a = tween._group) === null || _a === void 0 ? void 0 : _a.remove(tween);
              // @ts-expect-error library internal access
              tween._group = this;
              this._tweens[tween.getId()] = tween;
              this._tweensAddedDuringUpdate[tween.getId()] = tween;
          }
      };
      Group.prototype.remove = function () {
          var tweens = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              tweens[_i] = arguments[_i];
          }
          for (var _a = 0, tweens_2 = tweens; _a < tweens_2.length; _a++) {
              var tween = tweens_2[_a];
              // @ts-expect-error library internal access
              tween._group = undefined;
              delete this._tweens[tween.getId()];
              delete this._tweensAddedDuringUpdate[tween.getId()];
          }
      };
      /** Return true if all tweens in the group are not paused or playing. */
      Group.prototype.allStopped = function () {
          return this.getAll().every(function (tween) { return !tween.isPlaying(); });
      };
      Group.prototype.update = function (time, preserve) {
          if (time === void 0) { time = now$1(); }
          if (preserve === void 0) { preserve = true; }
          var tweenIds = Object.keys(this._tweens);
          if (tweenIds.length === 0)
              return;
          // Tweens are updated in "batches". If you add a new tween during an
          // update, then the new tween will be updated in the next batch.
          // If you remove a tween during an update, it may or may not be updated.
          // However, if the removed tween was added during the current batch,
          // then it will not be updated.
          while (tweenIds.length > 0) {
              this._tweensAddedDuringUpdate = {};
              for (var i = 0; i < tweenIds.length; i++) {
                  var tween = this._tweens[tweenIds[i]];
                  var autoStart = !preserve;
                  if (tween && tween.update(time, autoStart) === false && !preserve)
                      this.remove(tween);
              }
              tweenIds = Object.keys(this._tweensAddedDuringUpdate);
          }
      };
      return Group;
  }());

  /**
   *
   */
  var Interpolation = {
      Linear: function (v, k) {
          var m = v.length - 1;
          var f = m * k;
          var i = Math.floor(f);
          var fn = Interpolation.Utils.Linear;
          if (k < 0) {
              return fn(v[0], v[1], f);
          }
          if (k > 1) {
              return fn(v[m], v[m - 1], m - f);
          }
          return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
      },
      Bezier: function (v, k) {
          var b = 0;
          var n = v.length - 1;
          var pw = Math.pow;
          var bn = Interpolation.Utils.Bernstein;
          for (var i = 0; i <= n; i++) {
              b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
          }
          return b;
      },
      CatmullRom: function (v, k) {
          var m = v.length - 1;
          var f = m * k;
          var i = Math.floor(f);
          var fn = Interpolation.Utils.CatmullRom;
          if (v[0] === v[m]) {
              if (k < 0) {
                  i = Math.floor((f = m * (1 + k)));
              }
              return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
          }
          else {
              if (k < 0) {
                  return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
              }
              if (k > 1) {
                  return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
              }
              return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
          }
      },
      Utils: {
          Linear: function (p0, p1, t) {
              return (p1 - p0) * t + p0;
          },
          Bernstein: function (n, i) {
              var fc = Interpolation.Utils.Factorial;
              return fc(n) / fc(i) / fc(n - i);
          },
          Factorial: (function () {
              var a = [1];
              return function (n) {
                  var s = 1;
                  if (a[n]) {
                      return a[n];
                  }
                  for (var i = n; i > 1; i--) {
                      s *= i;
                  }
                  a[n] = s;
                  return s;
              };
          })(),
          CatmullRom: function (p0, p1, p2, p3, t) {
              var v0 = (p2 - p0) * 0.5;
              var v1 = (p3 - p1) * 0.5;
              var t2 = t * t;
              var t3 = t * t2;
              return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
          },
      },
  };

  /**
   * Utils
   */
  var Sequence = /** @class */ (function () {
      function Sequence() {
      }
      Sequence.nextId = function () {
          return Sequence._nextId++;
      };
      Sequence._nextId = 0;
      return Sequence;
  }());

  var mainGroup = new Group();

  /**
   * Tween.js - Licensed under the MIT license
   * https://github.com/tweenjs/tween.js
   * ----------------------------------------------
   *
   * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
   * Thank you all, you're awesome!
   */
  var Tween = /** @class */ (function () {
      function Tween(object, group) {
          this._isPaused = false;
          this._pauseStart = 0;
          this._valuesStart = {};
          this._valuesEnd = {};
          this._valuesStartRepeat = {};
          this._duration = 1000;
          this._isDynamic = false;
          this._initialRepeat = 0;
          this._repeat = 0;
          this._yoyo = false;
          this._isPlaying = false;
          this._reversed = false;
          this._delayTime = 0;
          this._startTime = 0;
          this._easingFunction = Easing.Linear.None;
          this._interpolationFunction = Interpolation.Linear;
          // eslint-disable-next-line
          this._chainedTweens = [];
          this._onStartCallbackFired = false;
          this._onEveryStartCallbackFired = false;
          this._id = Sequence.nextId();
          this._isChainStopped = false;
          this._propertiesAreSetUp = false;
          this._goToEnd = false;
          this._object = object;
          if (typeof group === 'object') {
              this._group = group;
              group.add(this);
          }
          // Use "true" to restore old behavior (will be removed in future release).
          else if (group === true) {
              this._group = mainGroup;
              mainGroup.add(this);
          }
      }
      Tween.prototype.getId = function () {
          return this._id;
      };
      Tween.prototype.isPlaying = function () {
          return this._isPlaying;
      };
      Tween.prototype.isPaused = function () {
          return this._isPaused;
      };
      Tween.prototype.getDuration = function () {
          return this._duration;
      };
      Tween.prototype.to = function (target, duration) {
          if (duration === void 0) { duration = 1000; }
          if (this._isPlaying)
              throw new Error('Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.');
          this._valuesEnd = target;
          this._propertiesAreSetUp = false;
          this._duration = duration < 0 ? 0 : duration;
          return this;
      };
      Tween.prototype.duration = function (duration) {
          if (duration === void 0) { duration = 1000; }
          this._duration = duration < 0 ? 0 : duration;
          return this;
      };
      Tween.prototype.dynamic = function (dynamic) {
          if (dynamic === void 0) { dynamic = false; }
          this._isDynamic = dynamic;
          return this;
      };
      Tween.prototype.start = function (time, overrideStartingValues) {
          if (time === void 0) { time = now$1(); }
          if (overrideStartingValues === void 0) { overrideStartingValues = false; }
          if (this._isPlaying) {
              return this;
          }
          this._repeat = this._initialRepeat;
          if (this._reversed) {
              // If we were reversed (f.e. using the yoyo feature) then we need to
              // flip the tween direction back to forward.
              this._reversed = false;
              for (var property in this._valuesStartRepeat) {
                  this._swapEndStartRepeatValues(property);
                  this._valuesStart[property] = this._valuesStartRepeat[property];
              }
          }
          this._isPlaying = true;
          this._isPaused = false;
          this._onStartCallbackFired = false;
          this._onEveryStartCallbackFired = false;
          this._isChainStopped = false;
          this._startTime = time;
          this._startTime += this._delayTime;
          if (!this._propertiesAreSetUp || overrideStartingValues) {
              this._propertiesAreSetUp = true;
              // If dynamic is not enabled, clone the end values instead of using the passed-in end values.
              if (!this._isDynamic) {
                  var tmp = {};
                  for (var prop in this._valuesEnd)
                      tmp[prop] = this._valuesEnd[prop];
                  this._valuesEnd = tmp;
              }
              this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);
          }
          return this;
      };
      Tween.prototype.startFromCurrentValues = function (time) {
          return this.start(time, true);
      };
      Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {
          for (var property in _valuesEnd) {
              var startValue = _object[property];
              var startValueIsArray = Array.isArray(startValue);
              var propType = startValueIsArray ? 'array' : typeof startValue;
              var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
              // If `to()` specifies a property that doesn't exist in the source object,
              // we should not set that property in the object
              if (propType === 'undefined' || propType === 'function') {
                  continue;
              }
              // Check if an Array was provided as property value
              if (isInterpolationList) {
                  var endValues = _valuesEnd[property];
                  if (endValues.length === 0) {
                      continue;
                  }
                  // Handle an array of relative values.
                  // Creates a local copy of the Array with the start value at the front
                  var temp = [startValue];
                  for (var i = 0, l = endValues.length; i < l; i += 1) {
                      var value = this._handleRelativeValue(startValue, endValues[i]);
                      if (isNaN(value)) {
                          isInterpolationList = false;
                          console.warn('Found invalid interpolation list. Skipping.');
                          break;
                      }
                      temp.push(value);
                  }
                  if (isInterpolationList) {
                      // if (_valuesStart[property] === undefined) { // handle end values only the first time. NOT NEEDED? setupProperties is now guarded by _propertiesAreSetUp.
                      _valuesEnd[property] = temp;
                      // }
                  }
              }
              // handle the deepness of the values
              if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                  _valuesStart[property] = startValueIsArray ? [] : {};
                  var nestedObject = startValue;
                  for (var prop in nestedObject) {
                      _valuesStart[property][prop] = nestedObject[prop];
                  }
                  // TODO? repeat nested values? And yoyo? And array values?
                  _valuesStartRepeat[property] = startValueIsArray ? [] : {};
                  var endValues = _valuesEnd[property];
                  // If dynamic is not enabled, clone the end values instead of using the passed-in end values.
                  if (!this._isDynamic) {
                      var tmp = {};
                      for (var prop in endValues)
                          tmp[prop] = endValues[prop];
                      _valuesEnd[property] = endValues = tmp;
                  }
                  this._setupProperties(nestedObject, _valuesStart[property], endValues, _valuesStartRepeat[property], overrideStartingValues);
              }
              else {
                  // Save the starting value, but only once unless override is requested.
                  if (typeof _valuesStart[property] === 'undefined' || overrideStartingValues) {
                      _valuesStart[property] = startValue;
                  }
                  if (!startValueIsArray) {
                      // eslint-disable-next-line
                      // @ts-ignore FIXME?
                      _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                  }
                  if (isInterpolationList) {
                      // eslint-disable-next-line
                      // @ts-ignore FIXME?
                      _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                  }
                  else {
                      _valuesStartRepeat[property] = _valuesStart[property] || 0;
                  }
              }
          }
      };
      Tween.prototype.stop = function () {
          if (!this._isChainStopped) {
              this._isChainStopped = true;
              this.stopChainedTweens();
          }
          if (!this._isPlaying) {
              return this;
          }
          this._isPlaying = false;
          this._isPaused = false;
          if (this._onStopCallback) {
              this._onStopCallback(this._object);
          }
          return this;
      };
      Tween.prototype.end = function () {
          this._goToEnd = true;
          this.update(this._startTime + this._duration);
          return this;
      };
      Tween.prototype.pause = function (time) {
          if (time === void 0) { time = now$1(); }
          if (this._isPaused || !this._isPlaying) {
              return this;
          }
          this._isPaused = true;
          this._pauseStart = time;
          return this;
      };
      Tween.prototype.resume = function (time) {
          if (time === void 0) { time = now$1(); }
          if (!this._isPaused || !this._isPlaying) {
              return this;
          }
          this._isPaused = false;
          this._startTime += time - this._pauseStart;
          this._pauseStart = 0;
          return this;
      };
      Tween.prototype.stopChainedTweens = function () {
          for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
              this._chainedTweens[i].stop();
          }
          return this;
      };
      Tween.prototype.group = function (group) {
          if (!group) {
              console.warn('tween.group() without args has been removed, use group.add(tween) instead.');
              return this;
          }
          group.add(this);
          return this;
      };
      /**
       * Removes the tween from whichever group it is in.
       */
      Tween.prototype.remove = function () {
          var _a;
          (_a = this._group) === null || _a === void 0 ? void 0 : _a.remove(this);
          return this;
      };
      Tween.prototype.delay = function (amount) {
          if (amount === void 0) { amount = 0; }
          this._delayTime = amount;
          return this;
      };
      Tween.prototype.repeat = function (times) {
          if (times === void 0) { times = 0; }
          this._initialRepeat = times;
          this._repeat = times;
          return this;
      };
      Tween.prototype.repeatDelay = function (amount) {
          this._repeatDelayTime = amount;
          return this;
      };
      Tween.prototype.yoyo = function (yoyo) {
          if (yoyo === void 0) { yoyo = false; }
          this._yoyo = yoyo;
          return this;
      };
      Tween.prototype.easing = function (easingFunction) {
          if (easingFunction === void 0) { easingFunction = Easing.Linear.None; }
          this._easingFunction = easingFunction;
          return this;
      };
      Tween.prototype.interpolation = function (interpolationFunction) {
          if (interpolationFunction === void 0) { interpolationFunction = Interpolation.Linear; }
          this._interpolationFunction = interpolationFunction;
          return this;
      };
      // eslint-disable-next-line
      Tween.prototype.chain = function () {
          var tweens = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              tweens[_i] = arguments[_i];
          }
          this._chainedTweens = tweens;
          return this;
      };
      Tween.prototype.onStart = function (callback) {
          this._onStartCallback = callback;
          return this;
      };
      Tween.prototype.onEveryStart = function (callback) {
          this._onEveryStartCallback = callback;
          return this;
      };
      Tween.prototype.onUpdate = function (callback) {
          this._onUpdateCallback = callback;
          return this;
      };
      Tween.prototype.onRepeat = function (callback) {
          this._onRepeatCallback = callback;
          return this;
      };
      Tween.prototype.onComplete = function (callback) {
          this._onCompleteCallback = callback;
          return this;
      };
      Tween.prototype.onStop = function (callback) {
          this._onStopCallback = callback;
          return this;
      };
      /**
       * @returns true if the tween is still playing after the update, false
       * otherwise (calling update on a paused tween still returns true because
       * it is still playing, just paused).
       *
       * @param autoStart - When true, calling update will implicitly call start()
       * as well. Note, if you stop() or end() the tween, but are still calling
       * update(), it will start again!
       */
      Tween.prototype.update = function (time, autoStart) {
          var _this = this;
          var _a;
          if (time === void 0) { time = now$1(); }
          if (autoStart === void 0) { autoStart = Tween.autoStartOnUpdate; }
          if (this._isPaused)
              return true;
          var property;
          if (!this._goToEnd && !this._isPlaying) {
              if (autoStart)
                  this.start(time, true);
              else
                  return false;
          }
          this._goToEnd = false;
          if (time < this._startTime) {
              return true;
          }
          if (this._onStartCallbackFired === false) {
              if (this._onStartCallback) {
                  this._onStartCallback(this._object);
              }
              this._onStartCallbackFired = true;
          }
          if (this._onEveryStartCallbackFired === false) {
              if (this._onEveryStartCallback) {
                  this._onEveryStartCallback(this._object);
              }
              this._onEveryStartCallbackFired = true;
          }
          var elapsedTime = time - this._startTime;
          var durationAndDelay = this._duration + ((_a = this._repeatDelayTime) !== null && _a !== void 0 ? _a : this._delayTime);
          var totalTime = this._duration + this._repeat * durationAndDelay;
          var calculateElapsedPortion = function () {
              if (_this._duration === 0)
                  return 1;
              if (elapsedTime > totalTime) {
                  return 1;
              }
              var timesRepeated = Math.trunc(elapsedTime / durationAndDelay);
              var timeIntoCurrentRepeat = elapsedTime - timesRepeated * durationAndDelay;
              // TODO use %?
              // const timeIntoCurrentRepeat = elapsedTime % durationAndDelay
              var portion = Math.min(timeIntoCurrentRepeat / _this._duration, 1);
              if (portion === 0 && elapsedTime === _this._duration) {
                  return 1;
              }
              return portion;
          };
          var elapsed = calculateElapsedPortion();
          var value = this._easingFunction(elapsed);
          // properties transformations
          this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
          if (this._onUpdateCallback) {
              this._onUpdateCallback(this._object, elapsed);
          }
          if (this._duration === 0 || elapsedTime >= this._duration) {
              if (this._repeat > 0) {
                  var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);
                  if (isFinite(this._repeat)) {
                      this._repeat -= completeCount;
                  }
                  // Reassign starting values, restart by making startTime = now
                  for (property in this._valuesStartRepeat) {
                      if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
                          this._valuesStartRepeat[property] =
                              // eslint-disable-next-line
                              // @ts-ignore FIXME?
                              this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                      }
                      if (this._yoyo) {
                          this._swapEndStartRepeatValues(property);
                      }
                      this._valuesStart[property] = this._valuesStartRepeat[property];
                  }
                  if (this._yoyo) {
                      this._reversed = !this._reversed;
                  }
                  this._startTime += durationAndDelay * completeCount;
                  if (this._onRepeatCallback) {
                      this._onRepeatCallback(this._object);
                  }
                  this._onEveryStartCallbackFired = false;
                  return true;
              }
              else {
                  if (this._onCompleteCallback) {
                      this._onCompleteCallback(this._object);
                  }
                  for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                      // Make the chained tweens start exactly at the time they should,
                      // even if the `update()` method was called way past the duration of the tween
                      this._chainedTweens[i].start(this._startTime + this._duration, false);
                  }
                  this._isPlaying = false;
                  return false;
              }
          }
          return true;
      };
      Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
          for (var property in _valuesEnd) {
              // Don't update properties that do not exist in the source object
              if (_valuesStart[property] === undefined) {
                  continue;
              }
              var start = _valuesStart[property] || 0;
              var end = _valuesEnd[property];
              var startIsArray = Array.isArray(_object[property]);
              var endIsArray = Array.isArray(end);
              var isInterpolationList = !startIsArray && endIsArray;
              if (isInterpolationList) {
                  _object[property] = this._interpolationFunction(end, value);
              }
              else if (typeof end === 'object' && end) {
                  // eslint-disable-next-line
                  // @ts-ignore FIXME?
                  this._updateProperties(_object[property], start, end, value);
              }
              else {
                  // Parses relative end values with start as base (e.g.: +10, -3)
                  end = this._handleRelativeValue(start, end);
                  // Protect against non numeric properties.
                  if (typeof end === 'number') {
                      // eslint-disable-next-line
                      // @ts-ignore FIXME?
                      _object[property] = start + (end - start) * value;
                  }
              }
          }
      };
      Tween.prototype._handleRelativeValue = function (start, end) {
          if (typeof end !== 'string') {
              return end;
          }
          if (end.charAt(0) === '+' || end.charAt(0) === '-') {
              return start + parseFloat(end);
          }
          return parseFloat(end);
      };
      Tween.prototype._swapEndStartRepeatValues = function (property) {
          var tmp = this._valuesStartRepeat[property];
          var endValue = this._valuesEnd[property];
          if (typeof endValue === 'string') {
              this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
          }
          else {
              this._valuesStartRepeat[property] = this._valuesEnd[property];
          }
          this._valuesEnd[property] = tmp;
      };
      Tween.autoStartOnUpdate = false;
      return Tween;
  }());
  /**
   * Controlling groups of tweens
   *
   * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
   * In these cases, you may want to create your own smaller groups of tweens.
   */
  var TWEEN = mainGroup;
  // This is the best way to export things in a way that's compatible with both ES
  // Modules and CommonJS, without build hacks, and so as not to break the
  // existing API.
  // https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  TWEEN.getAll.bind(TWEEN);
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  TWEEN.removeAll.bind(TWEEN);
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  TWEEN.add.bind(TWEEN);
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  TWEEN.remove.bind(TWEEN);
  /**
   * @deprecated The global TWEEN Group will be removed in a following major
   * release. To migrate, create a `new Group()` instead of using `TWEEN` as a
   * group.
   *
   * Old code:
   *
   * ```js
   * import * as TWEEN from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new TWEEN.Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   TWEEN.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   *
   * New code:
   *
   * ```js
   * import {Tween, Group} from '@tweenjs/tween.js'
   *
   * //...
   *
   * const tween = new Tween(obj)
   * const tween2 = new TWEEN.Tween(obj2)
   *
   * //...
   *
   * const group = new Group()
   * group.add(tween)
   * group.add(tween2)
   *
   * //...
   *
   * requestAnimationFrame(function loop(time) {
   *   group.update(time)
   *   requestAnimationFrame(loop)
   * })
   * ```
   */
  TWEEN.update.bind(TWEEN);

  var index$1 = (function (p) {
    return typeof p === 'function' ? p // fn
    : typeof p === 'string' ? function (obj) {
      return obj[p];
    } // property name
    : function (obj) {
      return p;
    };
  }); // constant

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root.Date.now();
  };

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /** Built-in value references. */
  var Symbol$1 = root.Symbol;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto$1.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$1.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag);
  }

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max,
      nativeMin = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  function _createClass(e, r, t) {
    return Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }

  var Prop = /*#__PURE__*/_createClass(function Prop(name, _ref) {
    var _ref$default = _ref["default"],
      defaultVal = _ref$default === void 0 ? null : _ref$default,
      _ref$triggerUpdate = _ref.triggerUpdate,
      triggerUpdate = _ref$triggerUpdate === void 0 ? true : _ref$triggerUpdate,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function (newVal, state) {} : _ref$onChange;
    _classCallCheck(this, Prop);
    this.name = name;
    this.defaultVal = defaultVal;
    this.triggerUpdate = triggerUpdate;
    this.onChange = onChange;
  });
  function index (_ref2) {
    var _ref2$stateInit = _ref2.stateInit,
      stateInit = _ref2$stateInit === void 0 ? function () {
        return {};
      } : _ref2$stateInit,
      _ref2$props = _ref2.props,
      rawProps = _ref2$props === void 0 ? {} : _ref2$props,
      _ref2$methods = _ref2.methods,
      methods = _ref2$methods === void 0 ? {} : _ref2$methods,
      _ref2$aliases = _ref2.aliases,
      aliases = _ref2$aliases === void 0 ? {} : _ref2$aliases,
      _ref2$init = _ref2.init,
      initFn = _ref2$init === void 0 ? function () {} : _ref2$init,
      _ref2$update = _ref2.update,
      updateFn = _ref2$update === void 0 ? function () {} : _ref2$update;
    // Parse props into Prop instances
    var props = Object.keys(rawProps).map(function (propName) {
      return new Prop(propName, rawProps[propName]);
    });
    return function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // Holds component state
      var state = Object.assign({}, stateInit instanceof Function ? stateInit(options) : stateInit,
      // Support plain objects for backwards compatibility
      {
        initialised: false
      });

      // keeps track of which props triggered an update
      var changedProps = {};

      // Component constructor
      function comp(nodeElement) {
        initStatic(nodeElement, options);
        digest();
        return comp;
      }
      var initStatic = function initStatic(nodeElement, options) {
        initFn.call(comp, nodeElement, state, options);
        state.initialised = true;
      };
      var digest = debounce(function () {
        if (!state.initialised) {
          return;
        }
        updateFn.call(comp, state, changedProps);
        changedProps = {};
      }, 1);

      // Getter/setter methods
      props.forEach(function (prop) {
        comp[prop.name] = getSetProp(prop);
        function getSetProp(_ref3) {
          var prop = _ref3.name,
            _ref3$triggerUpdate = _ref3.triggerUpdate,
            redigest = _ref3$triggerUpdate === void 0 ? false : _ref3$triggerUpdate,
            _ref3$onChange = _ref3.onChange,
            onChange = _ref3$onChange === void 0 ? function (newVal, state) {} : _ref3$onChange,
            _ref3$defaultVal = _ref3.defaultVal,
            defaultVal = _ref3$defaultVal === void 0 ? null : _ref3$defaultVal;
          return function (_) {
            var curVal = state[prop];
            if (!arguments.length) {
              return curVal;
            } // Getter mode

            var val = _ === undefined ? defaultVal : _; // pick default if value passed is undefined
            state[prop] = val;
            onChange.call(comp, val, state, curVal);

            // track changed props
            !changedProps.hasOwnProperty(prop) && (changedProps[prop] = curVal);
            if (redigest) {
              digest();
            }
            return comp;
          };
        }
      });

      // Other methods
      Object.keys(methods).forEach(function (methodName) {
        comp[methodName] = function () {
          var _methods$methodName;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return (_methods$methodName = methods[methodName]).call.apply(_methods$methodName, [comp, state].concat(args));
        };
      });

      // Link aliases
      Object.entries(aliases).forEach(function (_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2),
          alias = _ref5[0],
          target = _ref5[1];
        return comp[alias] = comp[target];
      });

      // Reset all component props to their default value
      comp.resetProps = function () {
        props.forEach(function (prop) {
          comp[prop.name](prop.defaultVal);
        });
        return comp;
      };

      //

      comp.resetProps(); // Apply all prop defaults
      state._rerender = digest; // Expose digest method

      return comp;
    };
  }

  var three = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
  : {
    WebGLRenderer: three$1.WebGLRenderer,
    Scene: three$1.Scene,
    PerspectiveCamera: three$1.PerspectiveCamera,
    Raycaster: three$1.Raycaster,
    SRGBColorSpace: three$1.SRGBColorSpace,
    TextureLoader: three$1.TextureLoader,
    Vector2: three$1.Vector2,
    Vector3: three$1.Vector3,
    Box3: three$1.Box3,
    Color: three$1.Color,
    Mesh: three$1.Mesh,
    SphereGeometry: three$1.SphereGeometry,
    MeshBasicMaterial: three$1.MeshBasicMaterial,
    BackSide: three$1.BackSide,
    EventDispatcher: three$1.EventDispatcher,
    MOUSE: three$1.MOUSE,
    Quaternion: three$1.Quaternion,
    Spherical: three$1.Spherical,
    Clock: three$1.Clock
  };
  var threeRenderObjects = index({
    props: {
      width: {
        "default": window.innerWidth,
        onChange: function onChange(width, state, prevWidth) {
          isNaN(width) && (state.width = prevWidth);
        }
      },
      height: {
        "default": window.innerHeight,
        onChange: function onChange(height, state, prevHeight) {
          isNaN(height) && (state.height = prevHeight);
        }
      },
      backgroundColor: {
        "default": '#000011'
      },
      backgroundImageUrl: {},
      onBackgroundImageLoaded: {},
      showNavInfo: {
        "default": true
      },
      skyRadius: {
        "default": 50000
      },
      objects: {
        "default": []
      },
      lights: {
        "default": []
      },
      enablePointerInteraction: {
        "default": true,
        onChange: function onChange(_, state) {
          // Reset hover state
          state.hoverObj = null;
          if (state.toolTipElem) state.toolTipElem.innerHTML = '';
        },
        triggerUpdate: false
      },
      lineHoverPrecision: {
        "default": 1,
        triggerUpdate: false
      },
      hoverOrderComparator: {
        "default": function _default() {
          return -1;
        },
        triggerUpdate: false
      },
      // keep existing order by default
      hoverFilter: {
        "default": function _default() {
          return true;
        },
        triggerUpdate: false
      },
      // exclude objects from interaction
      tooltipContent: {
        triggerUpdate: false
      },
      hoverDuringDrag: {
        "default": false,
        triggerUpdate: false
      },
      clickAfterDrag: {
        "default": false,
        triggerUpdate: false
      },
      onHover: {
        "default": function _default() {},
        triggerUpdate: false
      },
      onClick: {
        "default": function _default() {},
        triggerUpdate: false
      },
      onRightClick: {
        triggerUpdate: false
      }
    },
    methods: {
      tick: function tick(state) {
        if (state.initialised) {
          state.controls.update && state.controls.update(Math.min(1, state.clock.getDelta())); // timedelta is required for fly controls

          state.postProcessingComposer ? state.postProcessingComposer.render() // if using postprocessing, switch the output to it
          : state.renderer.render(state.scene, state.camera);
          state.extraRenderers.forEach(function (r) {
            return r.render(state.scene, state.camera);
          });
          if (state.enablePointerInteraction) {
            // Update tooltip and trigger onHover events
            var topObject = null;
            if (state.hoverDuringDrag || !state.isPointerDragging) {
              var intersects = this.intersectingObjects(state.pointerPos.x, state.pointerPos.y).filter(function (d) {
                return state.hoverFilter(d.object);
              }).sort(function (a, b) {
                return state.hoverOrderComparator(a.object, b.object);
              });
              var topIntersect = intersects.length ? intersects[0] : null;
              topObject = topIntersect ? topIntersect.object : null;
              state.intersectionPoint = topIntersect ? topIntersect.point : null;
            }
            if (topObject !== state.hoverObj) {
              state.onHover(topObject, state.hoverObj);
              state.toolTipElem.innerHTML = topObject ? index$1(state.tooltipContent)(topObject) || '' : '';
              state.hoverObj = topObject;
            }
          }
          state.tweenGroup.update(); // update camera animation tweens
        }
        return this;
      },
      getPointerPos: function getPointerPos(state) {
        var _state$pointerPos = state.pointerPos,
          x = _state$pointerPos.x,
          y = _state$pointerPos.y;
        return {
          x: x,
          y: y
        };
      },
      cameraPosition: function cameraPosition(state, position, lookAt, transitionDuration) {
        var camera = state.camera;

        // Setter
        if (position && state.initialised) {
          var finalPos = position;
          var finalLookAt = lookAt || {
            x: 0,
            y: 0,
            z: 0
          };
          if (!transitionDuration) {
            // no animation
            setCameraPos(finalPos);
            setLookAt(finalLookAt);
          } else {
            var camPos = Object.assign({}, camera.position);
            var camLookAt = getLookAt();
            state.tweenGroup.add(new Tween(camPos).to(finalPos, transitionDuration).easing(Easing.Quadratic.Out).onUpdate(setCameraPos).start());

            // Face direction in 1/3rd of time
            state.tweenGroup.add(new Tween(camLookAt).to(finalLookAt, transitionDuration / 3).easing(Easing.Quadratic.Out).onUpdate(setLookAt).start());
          }
          return this;
        }

        // Getter
        return Object.assign({}, camera.position, {
          lookAt: getLookAt()
        });

        //

        function setCameraPos(pos) {
          var x = pos.x,
            y = pos.y,
            z = pos.z;
          if (x !== undefined) camera.position.x = x;
          if (y !== undefined) camera.position.y = y;
          if (z !== undefined) camera.position.z = z;
        }
        function setLookAt(lookAt) {
          var lookAtVect = new three.Vector3(lookAt.x, lookAt.y, lookAt.z);
          if (state.controls.target) {
            state.controls.target = lookAtVect;
          } else {
            // Fly controls doesn't have target attribute
            camera.lookAt(lookAtVect); // note: lookAt may be overridden by other controls in some cases
          }
        }
        function getLookAt() {
          return Object.assign(new three.Vector3(0, 0, -1000).applyQuaternion(camera.quaternion).add(camera.position));
        }
      },
      zoomToFit: function zoomToFit(state) {
        var transitionDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
        for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
          bboxArgs[_key - 3] = arguments[_key];
        }
        return this.fitToBbox(this.getBbox.apply(this, bboxArgs), transitionDuration, padding);
      },
      fitToBbox: function fitToBbox(state, bbox) {
        var transitionDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var padding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
        // based on https://discourse.threejs.org/t/camera-zoom-to-fit-object/936/24
        var camera = state.camera;
        if (bbox) {
          var center = new three.Vector3(0, 0, 0); // reset camera aim to center
          var maxBoxSide = Math.max.apply(Math, _toConsumableArray(Object.entries(bbox).map(function (_ref) {
            var _ref2 = _slicedToArray$1(_ref, 2),
              coordType = _ref2[0],
              coords = _ref2[1];
            return Math.max.apply(Math, _toConsumableArray(coords.map(function (c) {
              return Math.abs(center[coordType] - c);
            })));
          }))) * 2;

          // find distance that fits whole bbox within padded fov
          var paddedFov = (1 - padding * 2 / state.height) * camera.fov;
          var fitHeightDistance = maxBoxSide / Math.atan(paddedFov * Math.PI / 180);
          var fitWidthDistance = fitHeightDistance / camera.aspect;
          var distance = Math.max(fitHeightDistance, fitWidthDistance);
          if (distance > 0) {
            var newCameraPosition = center.clone().sub(camera.position).normalize().multiplyScalar(-distance);
            this.cameraPosition(newCameraPosition, center, transitionDuration);
          }
        }
        return this;
      },
      getBbox: function getBbox(state) {
        var objFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
          return true;
        };
        var box = new three.Box3(new three.Vector3(0, 0, 0), new three.Vector3(0, 0, 0));
        var objs = state.objects.filter(objFilter);
        if (!objs.length) return null;
        objs.forEach(function (obj) {
          return box.expandByObject(obj);
        });

        // extract global x,y,z min/max
        return Object.assign.apply(Object, _toConsumableArray(['x', 'y', 'z'].map(function (c) {
          return _defineProperty({}, c, [box.min[c], box.max[c]]);
        })));
      },
      getScreenCoords: function getScreenCoords(state, x, y, z) {
        var vec = new three.Vector3(x, y, z);
        vec.project(this.camera()); // project to the camera plane
        return {
          // align relative pos to canvas dimensions
          x: (vec.x + 1) * state.width / 2,
          y: -(vec.y - 1) * state.height / 2
        };
      },
      getSceneCoords: function getSceneCoords(state, screenX, screenY) {
        var distance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var relCoords = new three.Vector2(screenX / state.width * 2 - 1, -(screenY / state.height) * 2 + 1);
        var raycaster = new three.Raycaster();
        raycaster.setFromCamera(relCoords, state.camera);
        return Object.assign({}, raycaster.ray.at(distance, new three.Vector3()));
      },
      intersectingObjects: function intersectingObjects(state, x, y) {
        var relCoords = new three.Vector2(x / state.width * 2 - 1, -(y / state.height) * 2 + 1);
        var raycaster = new three.Raycaster();
        raycaster.params.Line.threshold = state.lineHoverPrecision; // set linePrecision
        raycaster.setFromCamera(relCoords, state.camera);
        return raycaster.intersectObjects(state.objects, true);
      },
      renderer: function renderer(state) {
        return state.renderer;
      },
      scene: function scene(state) {
        return state.scene;
      },
      camera: function camera(state) {
        return state.camera;
      },
      postProcessingComposer: function postProcessingComposer(state) {
        return state.postProcessingComposer;
      },
      controls: function controls(state) {
        return state.controls;
      },
      tbControls: function tbControls(state) {
        return state.controls;
      } // to be deprecated
    },
    stateInit: function stateInit() {
      return {
        scene: new three.Scene(),
        camera: new three.PerspectiveCamera(),
        clock: new three.Clock(),
        tweenGroup: new Group()
      };
    },
    init: function init(domNode, state) {
      var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref4$controlType = _ref4.controlType,
        controlType = _ref4$controlType === void 0 ? 'trackball' : _ref4$controlType,
        _ref4$useWebGPU = _ref4.useWebGPU,
        useWebGPU = _ref4$useWebGPU === void 0 ? false : _ref4$useWebGPU,
        _ref4$rendererConfig = _ref4.rendererConfig,
        rendererConfig = _ref4$rendererConfig === void 0 ? {} : _ref4$rendererConfig,
        _ref4$extraRenderers = _ref4.extraRenderers,
        extraRenderers = _ref4$extraRenderers === void 0 ? [] : _ref4$extraRenderers,
        _ref4$waitForLoadComp = _ref4.waitForLoadComplete,
        waitForLoadComplete = _ref4$waitForLoadComp === void 0 ? true : _ref4$waitForLoadComp;
      // Wipe DOM
      domNode.innerHTML = '';

      // Add relative container
      domNode.appendChild(state.container = document.createElement('div'));
      state.container.className = 'scene-container';
      state.container.style.position = 'relative';

      // Add nav info section
      state.container.appendChild(state.navInfo = document.createElement('div'));
      state.navInfo.className = 'scene-nav-info';
      state.navInfo.textContent = {
        orbit: 'Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan',
        trackball: 'Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan',
        fly: 'WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw'
      }[controlType] || '';
      state.navInfo.style.display = state.showNavInfo ? null : 'none';

      // Setup tooltip
      state.toolTipElem = document.createElement('div');
      state.toolTipElem.classList.add('scene-tooltip');
      state.container.appendChild(state.toolTipElem);

      // Capture pointer coords on move or touchstart
      state.pointerPos = new three.Vector2();
      state.pointerPos.x = -2; // Initialize off canvas
      state.pointerPos.y = -2;
      ['pointermove', 'pointerdown'].forEach(function (evType) {
        return state.container.addEventListener(evType, function (ev) {
          // track click state
          evType === 'pointerdown' && (state.isPointerPressed = true);

          // detect point drag
          !state.isPointerDragging && ev.type === 'pointermove' && (ev.pressure > 0 || state.isPointerPressed) // ev.pressure always 0 on Safari, so we used the isPointerPressed tracker
          && (ev.pointerType !== 'touch' || ev.movementX === undefined || [ev.movementX, ev.movementY].some(function (m) {
            return Math.abs(m) > 1;
          })) // relax drag trigger sensitivity on touch events
          && (state.isPointerDragging = true);
          if (state.enablePointerInteraction) {
            // update the pointer pos
            var offset = getOffset(state.container);
            state.pointerPos.x = ev.pageX - offset.left;
            state.pointerPos.y = ev.pageY - offset.top;

            // Move tooltip
            state.toolTipElem.style.top = "".concat(state.pointerPos.y, "px");
            state.toolTipElem.style.left = "".concat(state.pointerPos.x, "px");
            // adjust horizontal position to not exceed canvas boundaries
            state.toolTipElem.style.transform = "translate(-".concat(state.pointerPos.x / state.width * 100, "%, ").concat(
            // flip to above if near bottom
            state.height - state.pointerPos.y < 100 ? 'calc(-100% - 8px)' : '21px', ")");
          }
          function getOffset(el) {
            var rect = el.getBoundingClientRect(),
              scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,
              scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            return {
              top: rect.top + scrollTop,
              left: rect.left + scrollLeft
            };
          }
        }, {
          passive: true
        });
      });

      // Handle click events on objs
      state.container.addEventListener('pointerup', function (ev) {
        state.isPointerPressed = false;
        if (state.isPointerDragging) {
          state.isPointerDragging = false;
          if (!state.clickAfterDrag) return; // don't trigger onClick after pointer drag (camera motion via controls)
        }
        requestAnimationFrame(function () {
          // trigger click events asynchronously, to allow hoverObj to be set (on frame)
          if (ev.button === 0) {
            // left-click
            state.onClick(state.hoverObj || null, ev, state.intersectionPoint); // trigger background clicks with null
          }
          if (ev.button === 2 && state.onRightClick) {
            // right-click
            state.onRightClick(state.hoverObj || null, ev, state.intersectionPoint);
          }
        });
      }, {
        passive: true,
        capture: true
      }); // use capture phase to prevent propagation blocking from controls (specifically for fly)

      state.container.addEventListener('contextmenu', function (ev) {
        if (state.onRightClick) ev.preventDefault(); // prevent default contextmenu behavior and allow pointerup to fire instead
      });

      // Setup renderer, camera and controls
      state.renderer = new (useWebGPU ? WebGPURenderer : three.WebGLRenderer)(Object.assign({
        antialias: true,
        alpha: true
      }, rendererConfig));
      state.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio)); // clamp device pixel ratio
      state.container.appendChild(state.renderer.domElement);

      // Setup extra renderers
      state.extraRenderers = extraRenderers;
      state.extraRenderers.forEach(function (r) {
        // overlay them on top of main renderer
        r.domElement.style.position = 'absolute';
        r.domElement.style.top = '0px';
        r.domElement.style.pointerEvents = 'none';
        state.container.appendChild(r.domElement);
      });

      // configure post-processing composer
      state.postProcessingComposer = new EffectComposer(state.renderer);
      state.postProcessingComposer.addPass(new RenderPass(state.scene, state.camera)); // render scene as first pass

      // configure controls
      state.controls = new {
        trackball: TrackballControls,
        orbit: OrbitControls,
        fly: FlyControls
      }[controlType](state.camera, state.renderer.domElement);
      if (controlType === 'fly') {
        state.controls.movementSpeed = 300;
        state.controls.rollSpeed = Math.PI / 6;
        state.controls.dragToLook = true;
      }
      if (controlType === 'trackball' || controlType === 'orbit') {
        state.controls.minDistance = 0.1;
        state.controls.maxDistance = state.skyRadius;
        state.controls.addEventListener('start', function () {
          state.controlsEngaged = true;
        });
        state.controls.addEventListener('change', function () {
          if (state.controlsEngaged) {
            state.controlsDragging = true;
          }
        });
        state.controls.addEventListener('end', function () {
          state.controlsEngaged = false;
          state.controlsDragging = false;
        });
      }
      [state.renderer, state.postProcessingComposer].concat(_toConsumableArray(state.extraRenderers)).forEach(function (r) {
        return r.setSize(state.width, state.height);
      });
      state.camera.aspect = state.width / state.height;
      state.camera.updateProjectionMatrix();
      state.camera.position.z = 1000;

      // add sky
      state.scene.add(state.skysphere = new three.Mesh());
      state.skysphere.visible = false;
      state.loadComplete = state.scene.visible = !waitForLoadComplete;
      window.scene = state.scene;
    },
    update: function update(state, changedProps) {
      // resize canvas
      if (state.width && state.height && (changedProps.hasOwnProperty('width') || changedProps.hasOwnProperty('height'))) {
        state.container.style.width = "".concat(state.width, "px");
        state.container.style.height = "".concat(state.height, "px");
        [state.renderer, state.postProcessingComposer].concat(_toConsumableArray(state.extraRenderers)).forEach(function (r) {
          return r.setSize(state.width, state.height);
        });
        state.camera.aspect = state.width / state.height;
        state.camera.updateProjectionMatrix();
      }
      if (changedProps.hasOwnProperty('skyRadius') && state.skyRadius) {
        state.controls.hasOwnProperty('maxDistance') && changedProps.skyRadius && (state.controls.maxDistance = Math.min(state.controls.maxDistance, state.skyRadius));
        state.camera.far = state.skyRadius * 2.5;
        state.camera.updateProjectionMatrix();
        state.skysphere.geometry = new three.SphereGeometry(state.skyRadius);
      }
      if (changedProps.hasOwnProperty('backgroundColor')) {
        var alpha = parseToRgb(state.backgroundColor).alpha;
        if (alpha === undefined) alpha = 1;
        state.renderer.setClearColor(new three.Color(curriedOpacify$1(1, state.backgroundColor)), alpha);
      }
      if (changedProps.hasOwnProperty('backgroundImageUrl')) {
        if (!state.backgroundImageUrl) {
          state.skysphere.visible = false;
          state.skysphere.material.map = null;
          !state.loadComplete && finishLoad();
        } else {
          new three.TextureLoader().load(state.backgroundImageUrl, function (texture) {
            texture.colorSpace = three.SRGBColorSpace;
            state.skysphere.material = new three.MeshBasicMaterial({
              map: texture,
              side: three.BackSide
            });
            state.skysphere.visible = true;

            // triggered when background image finishes loading (asynchronously to allow 1 frame to load texture)
            state.onBackgroundImageLoaded && setTimeout(state.onBackgroundImageLoaded);
            !state.loadComplete && finishLoad();
          });
        }
      }
      changedProps.hasOwnProperty('showNavInfo') && (state.navInfo.style.display = state.showNavInfo ? null : 'none');
      if (changedProps.hasOwnProperty('lights')) {
        (changedProps.lights || []).forEach(function (light) {
          return state.scene.remove(light);
        }); // Clear the place
        state.lights.forEach(function (light) {
          return state.scene.add(light);
        }); // Add to scene
      }
      if (changedProps.hasOwnProperty('objects')) {
        (changedProps.objects || []).forEach(function (obj) {
          return state.scene.remove(obj);
        }); // Clear the place
        state.objects.forEach(function (obj) {
          return state.scene.add(obj);
        }); // Add to scene
      }

      //

      function finishLoad() {
        state.loadComplete = state.scene.visible = true;
      }
    }
  });

  return threeRenderObjects;

}));
//# sourceMappingURL=three-render-objects.js.map
